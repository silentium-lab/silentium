<script class="page-title" type="text/template">
  Philosophy
</script>

<section class="text-gray-600 body-font">
  <div class="mx-auto flex py-1 items-center justify-center flex-col">
    <div class="lg:w-2/3 w-full">
      <h1 class="pb-3 text-xl font-semibold text-gray-600">
        Tell don't ask + trust
      </h1>
      <img
        class="float-left m-3 my-0"
src="./assets/img/philosofy/tell.jpg "
width="150"
height="200"
/>
<p class="text-gray-600 text-lg mb-4">
The idea of the project originated from the principle
        <a
          class="inline-block whitespace-nowrap rounded-[0.27rem] bg-primary-100 px-[0.65em] pb-[0.25em] pt-[0.35em] text-center align-baseline text-[0.75em] font-bold leading-none text-white bg-slate-900"
          href="https://toolshed.com/articles/1998-07-01-TellDontAsk.html"
          target="_blank"
          >Tell don't ask</a
        >. The original version of the principle says that we should not
        decide which method of an object to call based on the data from this
        You should just tell the object what it should do.
      </p>
      <p class="text-gray-600 text-lg mb-4">
This principle led to reflections on how objects actually look in
        the program communicates with each other. When object A calls the object's method
        B and waits for the result to be returned by the method of object B via
        return, such an organization of the code causes object B to respond even in those
        the moments when object B doesn't have some good, meaningful result.
      </p>
      <p class="text-gray-600 text-lg mb-4">
This situation, when using return, causes objects like B
        return incomplete results or no results at all.
        For example, if object B works asynchronously by accessing the server, then
        object B cannot return a value in JS conditions. Object B can return
        only a Promise is a promise that the value will be available sometime later, but
the problem is that object B itself is no longer responsible for this result.,
        the result may or may not come back, even if we
        if we handle the error using catch, we still have to respond to something.
        a waiting object, something insignificant that will need to be rechecked,
        therefore, trust in object B will disappear, and every response must be
        check
      </p>
      <p class="text-gray-600 text-lg mb-4">
It is also possible that object B simply does not have an answer and we
        you have to return null, and null transfers responsibility to the object.
        which communicates with object B. And it turns out that with object B already
        It's not pleasant to communicate, because he can't guarantee the result, his
        He needs to double-check all the time, no one trusts him.
      </p>
      <div class="clear-both"></div>
      <h2 class="pb-3 text-xl font-semibold text-gray-600">Responsible</h2>
      <img
        class="float-left m-3 my-0"
src="./assets/img/philosofy/responsible.jpg "
width="150"
height="200"
/>
<p class="text-gray-600 text-lg mb-4">
Everything described above under the heading <b>Tell don't ask</b> tells us about
        that a good object should be able to be responsible for the results that
        other objects expect to receive from him. And so that the implementation of this
        responsibility for the result has become possible - an object that
        the result is there, the person who needs this result should see it in order to
        fully control the return of the result to your
        <link-dynamic
          href="/terminology/visitor"
        >
to the visitor
        </link-dynamic>
        The entire library is built around this key idea. Site visitors
        they are divided into
<link-dynamic
          href="/terminology/guest"
>
guests
        </link-dynamic>
        - those who need to be informed of the value once and forget about it until he himself
        He'll come back if he wants to and
        <link-dynamic
          href="/terminology/patron"
        >
cartridges
        </link-dynamic>
        - those who need to be constantly informed about new values until they themselves
        they will decide to leave the
        <link-dynamic
          href="/patron/patron-pool"
        >
ammo pool
        </link-dynamic>
      </p>
      <div class="clear-both"></div>
      <h2 class="pb-3 text-xl font-semibold text-gray-600">Result</h2>
      <img
        class="float-left m-3 my-0"
        src="./assets/img/philosofy/result.jpg"
width="150"
height="200"
/>
<p class="text-gray-600 text-lg mb-4">
From what is written under the heading <b>Responsible</b> we can make
        the conclusion is that using the Patron Library imposes a restriction on you
        - do not use return, but instead return the data to the visitor
        by calling its give method, or by using a separate function
        <link-dynamic
          href="/utils/give"
        >
          give
        </link-dynamic>
      </p>
      <p class="text-gray-600 text-lg mb-4">
But in this section(Result) I would like to mention one more important thing
        the philosophical basis on which the development of the library is based
        Patron. The classes (static class code) that we create are considered
        the result that we need, according to our logic, later when creating
        we get a partially applied version of the class object from the class.
        a class with data bound to it and later to get a specific one
        the result of the calculation in the form of data, we need to call the object method.
        The sequence described in the previous sentence is the opposite
        the procedural sequence of execution is first calculated then
        result. By programming in the OOP style, we get results before
the calculation takes place. Our classes are representations of the ones we need.
        the results. This idea is considered key to understanding the principle.
        development of the subsequent code. We create a great result, then
        we create smaller results that are necessary for the big one, and so on until we describe it.
        our application. The pyramid of results is built from top to bottom from the very
        from what is important to our business logic to what is less important and more specific
        (concreteness here in the sense of relating to computing on a computer)
</p>
      <div class="clear-both"></div>
      <h2 class="pb-3 text-xl font-semibold text-gray-600">
Visitor + Observer
      </h2>
      <img
        class="float-left m-3 my-0"
        src="./assets/img/philosofy/observable.jpg"
        width="150"
        height="200"
      />
      <p class="text-gray-600 text-lg mb-4">
        We can say that the Patron library is based on (or
inspired by) two patterns (or two patterns) PLO: The Observer and
the Visitor. Objects that have data do not give it to unknown people
        (with the return operator), but instead they wait for the visitor and give back the data
        to a polite visitor who came and
        <link-dynamic
          href="/terminology/introduction"
        >
introduced himself
        </link-dynamic>
        The visitor can introduce himself as a patron, which is for the source object
        this means that if this object has new ones
        If there is any data, then the patron will be interested to know about this data. Communication between
        everything happens respectfully, no one uses anyone and does not
        forces you to give answers. If the data source has nothing to say, then they
can just keep quiet and not give useless answers.
      </p>
      <div class="clear-both"></div>
      <h2 class="pb-3 text-xl font-semibold text-gray-600">
Consumers and Sources
      </h2>
      <p class="text-gray-600 text-lg mb-4">
        The library identifies two main categories of classes. The first is consumers
        these are classes or functions that are compatible with the interface.
        <a
          class="inline-block whitespace-nowrap rounded-[0.27rem] bg-primary-100 px-[0.65em] pb-[0.25em] pt-[0.35em] text-center align-baseline text-[0.75em] font-bold leading-none text-white bg-slate-900"
          href="https://github.com/kosukhin/patron/blob/main/src/Guest/Guest.ts#L17"
        >
          GuestType
        </a>
         this category needs data. The second category has sources
        the data can be given to the consumer, the sources are compatible with the interface
        <a
          class="inline-block whitespace-nowrap rounded-[0.27rem] bg-primary-100 px-[0.65em] pb-[0.25em] pt-[0.35em] text-center align-baseline text-[0.75em] font-bold leading-none text-white bg-slate-900"
          href="https://github.com/kosukhin/patron/blob/main/src/Source/Source.ts#L3-L5"
        >
          SourceType
        </a>
      </p>
      <p class="text-gray-600 text-lg mb-4">
A good example of the division into consumers and sources are the classes for
        <b>REST</b> descriptions, for example, requests with the <b>GET</b> method are
        data sources, because they can return the data after receiving the response.
        from the server, and requests with methods <b>PUT</b>, <b>POST</b>,
<b>DELETE</b> are consumers, because they can perform an action after
        getting the data.
      </p>
    </div>
  </div>
</section>
