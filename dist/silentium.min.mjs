const e=(e,r)=>{if(null==e)throw new Error("value didn't receive source argument");if(void 0===r||null===e)throw new Error("value didn't receive guest argument");return"function"==typeof e?e(r):"object"==typeof e&&"value"in e&&"function"==typeof e.value?e.value(r):o(e,r),e},r=e=>null!==e&&"object"==typeof e&&"value"in e&&"function"==typeof e.value||null!=e,t=r=>{if(void 0===r)throw new Error("Source constructor didn't receive executor function");return t=>{e(r,t)}},o=(e,r)=>{if(void 0===e)throw new Error("give didn't receive data argument");return void 0===r?t(e):("function"==typeof r?r(e):r.give(e),r)},n=e=>{if(void 0===e)throw new Error("isGuest didnt receive mbGuest argument");return"function"==typeof e||"function"==typeof e?.give},i=e=>{if(!e)throw new Error("receiver function was not passed to Guest constructor");const r={give:t=>(e(t),r)};return r},s=(e,r)=>{if(void 0===e)throw new Error("GuestCast didn't receive sourceGuest argument");if(void 0===r)throw new Error("GuestCast didn't receive targetGuest argument");const t={disposed(r){const t=e;return!!t.disposed&&t.disposed(r)},give:e=>(o(e,r),t),introduction:()=>"function"==typeof e?"guest":e.introduction?e.introduction():"guest"};return t},u=e=>{const r={give:t=>(e=t,r),value(){if(void 0===e)throw new Error("no value in GuestSync!");return e}};return r},d=(e,r)=>{if(void 0===e)throw new Error("GuestDisposable didn't receive guest argument");if(void 0===r)throw new Error("GuestDisposable didn't receive disposeCheck argument");const t={disposed:e=>r(e),give:r=>(o(r,e),t)};return t},c=(e,r)=>{const t={give:n=>(o(r(n),e),t)};return t},a=(e,r)=>({give:r((r=>o(r,e)))}),v=e=>"object"==typeof e&&null!==e&&"patron"===e?.introduction?.(),h=()=>"patron",g=e=>{if(void 0===e)throw new Error("Patron didn't receive willBePatron argument");const r={give:t=>(o(t,e),r),disposed(r){const t=e;return t?.disposed?.(r)||!1},introduction:h};return r},f=e=>{if(void 0===e)throw new Error("PatronOnce didn't receive baseGuest argument");let r=!1;const t={give:n=>(r||(r=!0,o(n,e)),t),disposed(t){if(r)return!0;const o=e;return!!o.disposed&&o.disposed(t)},introduction:h};return t};var w=Object.defineProperty,l=(e,r,t)=>((e,r,t)=>r in e?w(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t)(e,"symbol"!=typeof r?r+"":r,t);const p=new Map,E=new Map,m=e=>{e.forEach((e=>{const r=E.get(e);r?.destroy()}))},y=e=>{const r=[];return p.forEach(((t,o)=>{t.has(e)&&r.push(o)})),r},b=e=>{if(void 0===e)throw new Error("removePatronFromPools didnt receive patron argument");p.forEach((r=>{r.delete(e)}))},S=e=>{if(void 0===e)throw new Error("isPatronInPools didnt receive patron argument");let r=!1;return p.forEach((t=>{r||(r=t.has(e))})),r};class G{constructor(e){this.initiator=e,l(this,"patrons"),l(this,"give"),this.patrons=new Set,p.set(this,this.patrons),E.set(this.initiator,this);const r=e=>{this.patrons.forEach((r=>{this.sendValueToGuest(e,r)}))};this.give=e=>(r(e),this)}size(){return this.patrons.size}add(e){if(!e)throw new Error("PatronPool add method received nothing!");return"function"!=typeof e&&e.introduction&&"patron"===e.introduction()&&this.patrons.add(e),this}remove(e){return this.patrons.delete(e),this}distribute(e,r){return this.add(r),this.sendValueToGuest(e,r),this}destroy(){this.patrons.forEach((e=>{this.remove(e)})),p.delete(this),E.delete(this.initiator)}sendValueToGuest(e,r){this.guestDisposed(e,r)||o(e,r)}guestDisposed(e,r){return!!r.disposed?.(e)&&(this.remove(r),!0)}}const P=(e,r)=>{const t=c(e,r),o={give:e=>(t.give(e),o),introduction:h};return o},j=(e,r)=>{const t=a(e,r),o={give:e=>(t.give(e),o),introduction:h};return o},D=t=>{const o={},n=new G(o),s=new G(o);let u=void 0===t;return void 0!==t&&r(t)?e(t,f((e=>{u=void 0===e,t=e}))):u=void 0===t,o.value=e=>u?(v(e)&&s.add(e),o):("function"==typeof e?n.distribute(t,i(e)):n.distribute(t,e),o),o.give=e=>(u=!1,t=e,n.give(t),s.give(t),o),o},z=r=>{const t=new Set(Object.keys(r)),n=new Set,u=Array.isArray(r),d=D({});return Object.entries(r).forEach((([r,o])=>{t.add(r),e(o,g((e=>{d.value(i((t=>{n.add(r);const o={...t,[r]:e};d.give(o)})))})))})),r=>{e((e=>{d.value(s(e,(r=>{n.size>0&&n.size===t.size&&o(u?Object.values(r):r,e)})))}),r)}},O=(t,n)=>{if(void 0===t)throw new Error("SourceSequence didn't receive baseSource argument");if(void 0===n)throw new Error("SourceSequence didn't receive targetSource argument");return i=>{const u=D(),d=n.get(u);e(t,s(i,(t=>{let n=0;const s=[];t.forEach((()=>{s.push(D())}));const c=()=>{void 0!==t[n+1]&&(n+=1,a())};function a(){const o=s[n],i=t[n];r(i)?e(i,f((r=>{u.give(r),e(d,o),c()}))):(u.give(i),e(d,o),c())}void 0!==t[n]?(a(),e(z(s),i)):o([],i)})))}},C=(r,t)=>{if(void 0===r)throw new Error("SourceMap didn't receive baseSource argument");if(void 0===t)throw new Error("SourceMap didn't receive targetSource argument");return o=>{e(r,s(o,(r=>{const n=[];r.forEach((e=>{const r=t.get(e);n.push(r)})),e(z(n),o)})))}},M=r=>{if(void 0===r)throw new Error("SourceRace didnt receive sources argument");return t=>{let n=null;r.forEach((r=>{e(r,s(t,(e=>{n&&n!==r||(o(e,t),n=r)})))}))}},V=(r,t)=>{if(void 0===r)throw new Error("SourceDynamic didn't receive baseGuest argument");if(void 0===t)throw new Error("SourceDynamic didn't receive baseSource argument");const n={value:r=>(e(t,r),n),give(e){return o(e,r),this}};return n},F=(r,t)=>n=>{e(r,s(n,(e=>{o(t(e),n)})))},T=(r,t)=>t((t=>{e(r,t)})),k=(r,t)=>n=>{e(r,s(n,(e=>{!0===t(e)&&o(e,n)})))},q=r=>{let t=void 0!==r;const o=D(r);return{value(r){return e(o,r),this},give(e){return t||(o.give(e),t=!0),this}}},x=r=>{const t=u();return e(r,g(t)),{value(t){return e(r,t),this},syncValue(){try{return t.value()}catch{throw new Error("No value in SourceSync")}}}},A=(e,r={})=>{if(void 0===e)throw new Error("PrivateClass didn't receive constructorFn argument");return{get:(...t)=>new e(...t,r)}},B=e=>{if(void 0===e)throw new Error("personal didn't receive buildingFn argument");return{get:(...r)=>e(...r)}};export{G as PatronPool,m as destroy,o as give,i as guest,c as guestApplied,s as guestCast,d as guestDisposable,a as guestExecutorApplied,u as guestSync,h as introduction,n as isGuest,v as isPatron,S as isPatronInPools,r as isSource,g as patron,P as patronApplied,j as patronExecutorApplied,f as patronOnce,y as patronPools,B as personal,A as personalClass,b as removePatronFromPools,t as source,z as sourceAll,F as sourceApplied,D as sourceChangeable,V as sourceDynamic,T as sourceExecutorApplied,k as sourceFiltered,C as sourceMap,q as sourceOnce,M as sourceRace,O as sourceSequence,x as sourceSync,e as value};
//# sourceMappingURL=silentium.min.mjs.map
