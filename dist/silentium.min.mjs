var e=Object.defineProperty,t=(t,s,n)=>((t,s,n)=>s in t?e(t,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[s]=n)(t,"symbol"!=typeof s?s+"":s,n);const s=class e{constructor(s,n="unknown",r=!0){this.info=s,this.theName=n,this.onlyOneOwner=r,t(this,"theSubInfos",[]),t(this,"destructor"),t(this,"owner"),t(this,"executedCbs"),t(this,"alreadyExecuted",!1),t(this,"debugCbs",[]),e.instances+=1}next(e){return void 0!==this.owner&&(this.owner.give(e),this.doDebug("next value",e)),this}value(e){if(this.onlyOneOwner&&void 0!==this.owner)throw new Error(`owner already connected to info ${this.name()}`);if(this.owner=e,void 0===this.executedCbs||this.alreadyExecuted||(this.executedCbs.forEach((t=>t(e))),this.alreadyExecuted=!0),void 0===this.info)return this;if("function"==typeof this.info){const t=this.info(e);void 0===this.destructor&&void 0!==t&&this.info!==t&&"function"==typeof t&&(this.destructor=t)}else"object"==typeof this.info&&null!==this.info&&"value"in this.info&&"function"==typeof this.info.value?this.info.value(e):this.next(this.info);return this}destroy(){for(;this.theSubInfos.length>0;){const e=this.theSubInfos.shift();e?.destroy()}return this.destructor&&this.destructor(),this.owner=void 0,this.executedCbs=void 0,this.destructor=void 0,this.doDebug("destroyed"),this}subInfo(e){return this.theSubInfos.push(e),this}subInfos(){return this.theSubInfos}name(){return`#info_${this.theName}_${e.instances}`}executed(e){return this.doDebug("executed"),this.executedCbs||(this.executedCbs=[]),this.executedCbs.push(e),this.alreadyExecuted&&void 0!==this.owner&&e(this.owner),this}hasOwner(){return!!this.owner}debug(e){return this.debugCbs.push(e),this}doDebug(...e){this.debugCbs.forEach((t=>t(...e)))}};t(s,"instances",0);let n=s;const r=(e,t="unknown",s=!0)=>e instanceof n?e:new n(e,t,s);var o=Object.defineProperty,i=(e,t,s)=>((e,t,s)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s)(e,t+"",s);class u{constructor(e,t,s){this.ownerFn=e,this.errorFn=t,this.disposedFn=s,i(this,"debugCbs",[])}give(e){return this.doDebug("value",e),this.disposed()||this.ownerFn(e),this}error(e){return this.doDebug("error",e),void 0!==this.errorFn&&this.errorFn(e),this}disposed(){return void 0!==this.disposedFn&&this.disposedFn()}debug(e){return this.debugCbs.push(e),this}doDebug(...e){this.debugCbs.forEach((t=>t(...e)))}}const h=e=>new u(e),d=(...e)=>{const t=new n((s=>{const n=new Set(Object.keys(e)),r=new Set,o={};Object.entries(e).forEach((([e,i])=>{t.subInfo(i),n.add(e),i.value(new u((t=>{r.add(e),o[e]=t,r.size>0&&r.size===n.size&&s.give(Object.values(o))})))}))}));return t},c=(...e)=>r((t=>{e.forEach((e=>{e.value(t),e.subInfo(e)}))})),a=(...e)=>{let t,s;const n=new WeakMap,o=r=>{const i=e[r],u=e[r+1];i.value(h((e=>{u||(s=e,t?.give(e)),u&&void 0!==s&&void 0!==t&&t.give(s),u&&!n.has(i)&&o(r+1),n.set(i,1)})))},i=r((e=>{t=e}));return i.executed((e=>{t=e,o(0)})),i},v=(e,t)=>{const s=new n((s=>{e.value(t(s))}));return s.subInfo(e),s},f=(e,t)=>{const s=r((s=>{e.value(h((e=>{s.give(t(e))})))}));return s.subInfo(e),s},l=(e,t,s)=>new n((n=>{e.value(h((e=>{t(e)?n.give(e):void 0!==s&&n.give(s)})))})).subInfo(e),b=(e,t)=>new u((s=>{e.give(t(s))}),(t=>{e.error(t)}),(()=>e.disposed())),w=(e,t)=>{const s=t((t=>e.give(t)));return new u((e=>{s(e)}))},g=(e,t)=>{let s;return e.value(h((e=>{s=e}))),{syncValue(){if(void 0===s&&void 0===t)throw new Error("info sync is empty");return s??t},filled:()=>void 0!==s}},y=(e,t)=>{const s=new n((t=>{const n=e.get();s.subInfo(n),n.value(t)}));return t&&(s.subInfo(t),t.value(h((()=>{s.destroy()})))),s},p=(e,t)=>{const s=new n((o=>{e.value(h((e=>{const i=[];e.forEach((e=>{let s=e;s instanceof n||(s=r(e));const o=t.get(s);i.push(o)}));const u=d(...i).value(o);s.subInfo(u)})))}));return s.subInfo(e),s},x=e=>{let t,s=e;const r=()=>{void 0!==t&&t.give(s)};return[new n((e=>{t=e,null!=s&&r()}),"of"),new u((e=>{s=e,r()}))]},I=e=>{const t=new n((t=>{let s=!1;e.value(h((e=>{s||(s=!0,t.give(e))})))}));return t.subInfo(e),t};var E=Object.defineProperty,m=(e,t,s)=>((e,t,s)=>t in e?E(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s)(e,"symbol"!=typeof t?t+"":t,s);class C{constructor(){m(this,"owners"),m(this,"innerOwner"),this.owners=new Set,this.innerOwner=new u((e=>{this.owners.forEach((t=>{t.give(e)}))}),(e=>{this.owners.forEach((t=>{t.error(e)}))}))}owner(){return this.innerOwner}size(){return this.owners.size}has(e){return this.owners.has(e)}add(e){return this.owners.add(e),this}remove(e){return this.owners.delete(e),this}destroy(){return this.owners.forEach((e=>{this.remove(e)})),this}}const O=e=>{const t=new C;let s;const r=new n((e=>(void 0===s||t.has(e)||e.give(s),t.add(e),()=>{t.destroy()})),"pool",!1);return r.subInfo(e),r.executed((()=>{const n=t.owner();e.value(new u((e=>{n.give(e),s=e})))})),[r,t]},F=e=>{const t=new C,s=new n((e=>(t.add(e),()=>{t.destroy()})),"pool",!1);return s.subInfo(e),s.executed((s=>{t.add(s),e.value(t.owner())})),[s,t]},S=e=>{const t=r((t=>{const s=[];e.value(h((e=>{s.push(e),t.give(s)})))}));return t.subInfo(e),t},j=e=>r((t=>{e.value(h((e=>{e.forEach((e=>{t.give(e)}))})))})),D=e=>r((t=>{e((e=>{t.give(e)}))})),z=(e,t,s,n)=>r((r=>{const o=(...e)=>{r.give(e)};return e[s](t,o),()=>{void 0!==n&&e[n](t,o)}})),k=e=>r((t=>{e.then((e=>{t.give(e)})).catch((e=>{t.error(e)}))})),P=e=>{if(void 0===e)throw new Error("lazy didn't receive buildingFn argument");return{get:(...t)=>e(...t)}},$=(e,t={})=>{if(void 0===e)throw new Error("PrivateClass didn't receive constructorFn argument");return{get:(...s)=>new e(...s,t)}},N=(e,...t)=>e(...t.map((e=>e instanceof n?e:r(e))));export{r as I,n as Information,h as O,u as Owner,C as OwnerPool,d as all,c as any,N as ap,f as applied,a as chain,v as executorApplied,l as filtered,D as fromCallback,z as fromEvent,k as fromPromise,P as lazy,$ as lazyClass,y as lazyS,p as map,x as of,I as once,b as ownerApplied,w as ownerExecutorApplied,g as ownerSync,O as pool,F as poolStateless,S as sequence,j as stream};
//# sourceMappingURL=silentium.min.mjs.map
