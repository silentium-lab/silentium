const e=(...e)=>{const t=new Set(Object.keys(e)),n=new Set;return r=>{const s={};Object.entries(e).forEach((([e,o])=>{t.add(e),o((o=>{n.add(e),s[e]=o,((e,t)=>e.size>0&&e.size===t.size)(n,t)&&r(Object.values(s))}))}))}},t=(...e)=>t=>{e.forEach((e=>{e(t)}))},n=(e,t)=>n=>{e((e=>{n(t(e))}))},r=(...e)=>t=>{let n;const r=s=>{const o=e[s],i=e[s+1];o((e=>{i||(n=e),n&&t(n),i&&!n&&r(s+1)}))};r(0)},s=(e,t)=>n=>{e(t((e=>{n(e)})))},o=(e,t,n)=>r=>{e((e=>{t(e)?r(e):void 0!==n&&r(n)}))},i=(t,n,r,s)=>{let o=null;const i=e=>{o&&o(e)};return c=>{o=c;return e(t,n,r)((([e,t,n])=>{e?.[n]&&e[n](t,i)})),()=>{if(o=null,!s)return;e(t,n,s)((([e,t,n])=>{e[n](t,i)}))}}},c=(e,t)=>n=>{e.then((e=>{n(e)})).catch((e=>{t?.(e)}))},u=e=>null!=e;var a=Object.defineProperty,l=(e,t,n)=>((e,t,n)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);class h{constructor(){l(this,"owners"),l(this,"innerOwner"),this.owners=new Set,this.innerOwner=e=>{this.owners.forEach((t=>{t(e)}))}}owner(){return this.innerOwner}size(){return this.owners.size}has(e){return this.owners.has(e)}add(e){return this.owners.add(e),this}remove(e){return this.owners.delete(e),this}destroy(){return this.owners.forEach((e=>{this.remove(e)})),this}}const v=e=>{let t=null;const n=e=>{u(e)&&t&&t(e)};return{value:r=>{if(t)throw new Error("Late component gets new user, when another was already connected!");t=r,n(e)},give:e=>{n(e)}}},w=e=>t=>{let n=!1;e((e=>{n||(n=!0,t(e))}))},d=(e,t=!1)=>{const n=new h;let r;const s=v();return w(s.value)((()=>{e((e=>{n.owner()(e),r=e}))})),{value:e=>(s.give(1),t||!u(r)||n.has(e)||e(r),n.add(e),()=>{n.remove(e)}),give:e=>{r=e,n.owner()(e)},pool:()=>n,destroy(){n.destroy()}}},f=(e,t=!1)=>{const n=d(e.value,t);return{value:e=>{n.value(e)},give:t=>{e.give(t)}}},y=e=>{const t=f(v(e));return{value:t.value,give:t.give}},g=(e,t)=>(...n)=>t(e(...n)),p=(e,t,n=0)=>(...r)=>e(...function(e,t,n){const r=e.slice(0,n);for(;r.length<n;)r.push(void 0);return r.concat(t)}(r,t,n));const b=e=>{const t=[];return{get:(...n)=>{const r=e(...n);return t.push(r),r},destroy:()=>{t.forEach((e=>e.destroy()))}}},m=e=>t=>t(e),E=(e,t)=>e(t),O=()=>()=>{},z=(t,n)=>r=>{t((t=>{const s=[];t.forEach((e=>{let t=e;"function"!=typeof t&&(t=m(t));const r=n(t);s.push(r)}));e(...s)(r)}))},j=(e,t=null)=>(e((e=>{t=e})),{[Symbol.toPrimitive]:()=>t,primitive:()=>t}),S=e=>t=>{const n=[];e((e=>{n.push(e),t(n)}))},P=e=>t=>{e((e=>{e.forEach((e=>{t(e)}))}))};export{h as OwnerPool,O as _void,e as all,t as any,n as applied,r as chain,s as executorApplied,o as filtered,i as fromEvent,c as fromPromise,u as isFilled,v as late,y as lateShared,g as lazyApplied,p as lazyArgs,b as lazyDestroyable,z as map,m as of,E as on,w as once,j as primitive,S as sequence,d as shared,f as sharedSource,P as stream};
//# sourceMappingURL=silentium.min.mjs.map
