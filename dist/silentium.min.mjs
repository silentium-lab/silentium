const e=(...e)=>{const t=new Set(Object.keys(e)),n=new Set;return r=>{const o={};Object.entries(e).forEach((([e,s])=>{t.add(e),s((s=>{n.add(e),o[e]=s,((e,t)=>e.size>0&&e.size===t.size)(n,t)&&r(Object.values(o))}))}))}},t=(...e)=>t=>{e.forEach((e=>{e(t)}))},n=(e,t)=>n=>{e((e=>{n(t(e))}))},r=(...e)=>t=>{let n;const r=o=>{const s=e[o],i=e[o+1];s((e=>{i||(n=e),n&&t(n),i&&!n&&r(o+1)}))};r(0)},o=(e,t)=>n=>{e(t((e=>{n(e)})))},s=(e,t,n)=>r=>{e((e=>{t(e)?r(e):void 0!==n&&r(n)}))},i=(t,n,r,o)=>{let s=null;const i=e=>{s&&s(e)};return u=>{s=u;return e(t,n,r)((([e,t,n])=>{e?.[n]&&e[n](t,i)})),()=>{if(s=null,!o)return;e(t,n,o)((([e,t,n])=>{e?.[n]?.(t,i)}))}}},u=(e,t)=>n=>{e.then((e=>{n(e)})).catch((e=>{t?.(e)}))},l=e=>null!=e;var c=Object.defineProperty,a=(e,t,n)=>((e,t,n)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);class h{constructor(){a(this,"owners"),a(this,"innerOwner"),this.owners=new Set,this.innerOwner=e=>{this.owners.forEach((t=>{t(e)}))}}owner(){return this.innerOwner}size(){return this.owners.size}has(e){return this.owners.has(e)}add(e){return this.owners.add(e),this}remove(e){return this.owners.delete(e),this}destroy(){return this.owners.forEach((e=>{this.remove(e)})),this}}const v=e=>{let t=null;const n=e=>{l(e)&&t&&t(e)};return{value:r=>{if(t)throw new Error("Late component gets new user, when another was already connected!");t=r,n(e)},give:e=>{n(e)}}},w=e=>t=>{let n=!1;e((e=>{n||(n=!0,t(e))}))},d=(e,t=!1)=>{const n=new h;let r;const o=v();return w(o.value)((()=>{e((e=>{n.owner()(e),r=e}))})),{value:e=>(o.give(1),t||!l(r)||n.has(e)||e(r),n.add(e),()=>{n.remove(e)}),give:e=>{r=e,n.owner()(e)},pool:()=>n,destroy(){n.destroy()}}},f=(e,t=!1)=>{const n=d(e.value,t);return{value:e=>{n.value(e)},give:t=>{e.give(t)}}},p=e=>{const t=f(v(e));return{value:t.value,give:t.give}},y=(e,t)=>(...n)=>t(e(...n)),g=(e,t,n=0)=>(...r)=>e(...function(e,t,n){const r=e.slice(0,n);for(;r.length<n;)r.push(void 0);return r.concat(t)}(r,t,n));const m=e=>{const t=[];return{get:(...n)=>{const r=e(...n);return t.push(r),r},destroy:()=>{t.forEach((e=>e.destroy()))}}},E=(e,t)=>{let n,r=null;const o=()=>{r=null,n?.()};return{value:s=>(r=s,n=e((e=>{r&&r(e)})),n&&t&&t(o),o),destroy:o}},b=e=>function(t){let n=!1;const r=e((e=>{n||t(e)}));return()=>{n=!0,r?.()}},O=e=>t=>t(e),z=(e,t)=>e(t),j=()=>()=>{},S=(t,n)=>r=>{t((t=>{const o=[];t.forEach((e=>{let t=e;"function"!=typeof t&&(t=O(t));const r=n(t);o.push(r)}));e(...o)(r)}))},P=(e,t=null)=>(e((e=>{t=e})),{[Symbol.toPrimitive]:()=>t,primitive:()=>t,primitiveWithException(){if(null===t)throw new Error("Primitive value is null");return t}}),x=e=>t=>{const n=[];e((e=>{n.push(e),t(n)}))},k=e=>t=>{e((e=>{e.forEach((e=>{t(e)}))}))};export{h as OwnerPool,j as _void,e as all,t as any,n as applied,r as chain,E as destructor,o as executorApplied,s as filtered,i as fromEvent,u as fromPromise,l as isFilled,v as late,p as lateShared,y as lazyApplied,g as lazyArgs,m as lazyDestroyable,b as local,S as map,O as of,z as on,w as once,P as primitive,x as sequence,d as shared,f as sharedSource,k as stream};
//# sourceMappingURL=silentium.min.mjs.map
