const e=e=>null!=e;var t=Object.defineProperty,r=(e,r,n)=>((e,r,n)=>r in e?t(e,r,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[r]=n)(e,"symbol"!=typeof r?r+"":r,n);class n{constructor(){r(this,"owners"),r(this,"innerOwner"),this.owners=new Set,this.innerOwner=e=>{this.owners.forEach((t=>{t(e)}))}}owner(){return this.innerOwner}size(){return this.owners.size}has(e){return this.owners.has(e)}add(e){return this.owners.add(e),this}remove(e){return this.owners.delete(e),this}destroy(){return this.owners.forEach((e=>{this.remove(e)})),this}}const s=e=>{let t=!1;return(...r)=>{t||e(...r),t=!0}},o=e=>{e.forEach((e=>{"function"==typeof e&&e()}))},c=(...e)=>t=>{const r=new Set(Object.keys(e)),n=new Set,s={},c=[];return Object.entries(e).forEach((([e,o])=>{r.add(e),c.push(o((o=>{if(n.add(e),s[e]=o,n.size>0&&n.size===r.size)return t(Object.values(s))})))})),()=>{r.clear(),n.clear(),o(c)}},i=(...e)=>t=>{const r=[];return e.forEach((e=>{r.push(e(t))})),()=>{o(r)}},h=(e,t)=>r=>e((e=>r(t(e)))),u=(...e)=>{let t,r;const n=new WeakMap,c=[],i=s=>{const o=e[s],h=e[s+1];o((e=>{h||(r=e,c.push(t?.(e))),h&&void 0!==r&&void 0!==t&&c.push(t?.(r)),h&&!n.has(o)&&i(s+1),n.set(o,1)}))},h=s((e=>{t=e,i(0)}));return e=>(h(e),t=e,()=>{o(c)})},a=(e,t)=>r=>e(t(r)),d=(e,t,r)=>n=>e((e=>t(e)?n(e):void 0!==r?n(r):void 0)),w=(e,...t)=>r=>{e((e=>{r(e)}),...t)},l=(e,t,r,n)=>s=>{const o=(...e)=>{s(e)};return e[r](t,o),()=>{void 0!==n&&e[n](t,o)}},f=t=>{let r;const n=()=>{if(void 0!==r&&e(t))return r(t)};return[e=>(r=e,n()),e=>(t=e,n())]},v=e=>{const[t,r]=f();return[t=>{e.then((e=>{t(e)})).catch((e=>{r(e)}))},t]},p=e=>t=>t(e),y=(e,t)=>(...r)=>{const n=e(...r);return u(t,n)},b=e=>(...t)=>{const r=new e(...t);return e=>{r.value(e)}},E=(e,t)=>r=>{e((e=>{const n=[];e.forEach((e=>{let r=e;"function"!=typeof r&&(r=p(r));const s=t(r);n.push(s)}));c(...n)(r)}))},O=e=>t=>{let r=!1;e((e=>{r||(r=!0,t(e))}))},m=e=>t=>{const r=[];e((e=>{r.push(e),t(r)}))},z=t=>{const r=new n;let o,c;const i=s((()=>{const e=r.owner();c=t((t=>{e(t),o=t}))}));return[t=>{let n;return i(),e(o)&&!r.has(t)&&(n=t(o)),r.add(t),()=>{r.remove(t),n?.()}},()=>{r.destroy(),c?.()},r]},j=e=>{const t=new n;let r;const o=s((n=>{t.add(n),r=e(t.owner())}));return[e=>(o(e),t.has(e)||t.add(e),()=>{t.remove(e)}),()=>{t.destroy(),r?.()},t]},S=e=>t=>{e((e=>{e.forEach((e=>{t(e)}))}))};export{n as OwnerPool,c as all,i as any,h as applied,u as chain,o as destroyArr,a as executorApplied,d as filtered,w as fromCallback,l as fromEvent,v as fromPromise,p as i,e as isFilled,y as lazyChain,b as lazyClass,E as map,f as of,s as onExecuted,O as once,m as sequence,z as shared,j as sharedStateless,S as stream};
//# sourceMappingURL=silentium.min.mjs.map
