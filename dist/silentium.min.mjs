const e=(e,t)=>{if(null==e)throw new Error("value didn't receive source argument");if(void 0===t||null===e)throw new Error("value didn't receive guest argument");return"function"==typeof e?e(t):"object"==typeof e&&"value"in e&&"function"==typeof e.value?e.value(t):o(e,t),e},t=e=>null!==e&&"object"==typeof e&&"value"in e&&"function"==typeof e.value||null!=e,r=t=>{if(void 0===t)throw new Error("Source constructor didn't receive executor function");return r=>{e(t,r)}},o=(e,t)=>{if(void 0===e)throw new Error("give didn't receive data argument");return void 0===t?r(e):("function"==typeof t?t(e):t.give(e),t)},n=e=>{if(void 0===e)throw new Error("isGuest didnt receive mbGuest argument");return"function"==typeof e||"function"==typeof e?.give},i=e=>{if(!e)throw new Error("receiver function was not passed to Guest constructor");const t={give:r=>(e(r),t)};return t},s=(e,t)=>{if(void 0===e)throw new Error("GuestCast didn't receive sourceGuest argument");if(void 0===t)throw new Error("GuestCast didn't receive targetGuest argument");const r={disposed(t){const r=e;return!!r.disposed&&r.disposed(t)},give:e=>(o(e,t),r),introduction:()=>"function"==typeof e?"guest":e.introduction?e.introduction():"guest"};return r},u=e=>{const t={give:r=>(e=r,t),value(){if(void 0===e)throw new Error("no value in GuestSync!");return e}};return t},d=(e,t)=>{if(void 0===e)throw new Error("GuestDisposable didn't receive guest argument");if(void 0===t)throw new Error("GuestDisposable didn't receive disposeCheck argument");const r={disposed:e=>t(e),give:t=>(o(t,e),r)};return r},c=(e,t)=>{const r={give:n=>(o(t(n),e),r)};return r},a=(e,t)=>({give:t((t=>o(t,e)))}),v=e=>"object"==typeof e&&null!==e&&"patron"===e?.introduction?.(),h=()=>"patron",f=e=>{if(void 0===e)throw new Error("Patron didn't receive willBePatron argument");const t={give:r=>(o(r,e),t),disposed(t){const r=e;return r?.disposed?.(t)||!1},introduction:h};return t},g=e=>{if(void 0===e)throw new Error("PatronOnce didn't receive baseGuest argument");let t=!1;const r={give:n=>(t||(t=!0,o(n,e)),r),disposed(r){if(t)return!0;const o=e;return!!o.disposed&&o.disposed(r)},introduction:h};return r};var l=Object.defineProperty,w=(e,t,r)=>((e,t,r)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);const p=new Map,E=new Map,m=new Map,y=[],b=()=>{y.forEach((e=>e()))},S={poolsCount:0,patronsCount:0},G=r((e=>{o(S,e),y.push((()=>{let t=0;p.forEach((e=>{t+=e.size})),S.poolsCount=p.size,S.patronsCount=t,o(S,e)}))})),P=(e,t)=>{m.has(e)||m.set(e,[]),m.get(e)?.push(t)},C=e=>{e.forEach((e=>{const t=E.get(e);t?.destroy();const r=m.get(e);r&&C(r)}))},j=e=>{const t=[];return p.forEach(((r,o)=>{r.has(e)&&t.push(o)})),t},z=e=>{if(void 0===e)throw new Error("removePatronFromPools didn't receive patron argument");p.forEach((t=>{t.delete(e)}))},D=e=>{if(void 0===e)throw new Error("isPatronInPools didn't receive patron argument");let t=!1;return p.forEach((r=>{t||(t=r.has(e))})),t};class M{constructor(e){this.initiator=e,w(this,"patrons"),w(this,"give"),this.patrons=new Set,p.set(this,this.patrons),E.set(this.initiator,this);const t=e=>{this.patrons.forEach((t=>{this.sendValueToGuest(e,t)}))};this.give=e=>(t(e),this),b()}size(){return this.patrons.size}add(e){if(!e)throw new Error("PatronPool add method received nothing!");return"function"!=typeof e&&e.introduction&&"patron"===e.introduction()&&this.patrons.add(e),b(),this}remove(e){return this.patrons.delete(e),b(),this}distribute(e,t){return this.add(t),this.sendValueToGuest(e,t),this}destroy(){return this.patrons.forEach((e=>{this.remove(e)})),p.delete(this),E.delete(this.initiator),b(),this}sendValueToGuest(e,t){return this.guestDisposed(e,t)||o(e,t),this}guestDisposed(e,t){return!!t.disposed?.(e)&&(this.remove(t),!0)}}const O=(e,t)=>{const r=c(e,t),o={give:e=>(r.give(e),o),introduction:h};return o},V=(e,t)=>{const r=a(e,t),o={give:e=>(r.give(e),o),introduction:h};return o},F=r=>{const o={},n=new M(o);let s=void 0===r;return void 0!==r&&t(r)?e(r,g((e=>{s=void 0===e,r=e}))):s=void 0===r,o.value=e=>s?(v(e)&&n.add(e),o):("function"==typeof e?n.distribute(r,i(e)):n.distribute(r,e),o),o.give=e=>(s=!1,r=e,n.give(r),o),o},T=t=>{const r=new Set(Object.keys(t)),n=new Set,u=Array.isArray(t),d=F({});return Object.entries(t).forEach((([t,o])=>{r.add(t),e(o,f((e=>{d.value(i((r=>{n.add(t);const o={...r,[t]:e};d.give(o)})))})))})),t=>{e((e=>{d.value(s(e,(t=>{n.size>0&&n.size===r.size&&o(u?Object.values(t):t,e)})))}),t)}},k=(r,n)=>{if(void 0===r)throw new Error("SourceSequence didn't receive baseSource argument");if(void 0===n)throw new Error("SourceSequence didn't receive targetSource argument");return i=>{const u=F(),d=n.get(u);e(r,s(i,(r=>{let n=0;const s=[];r.forEach((()=>{s.push(F())}));const c=()=>{void 0!==r[n+1]&&(n+=1,a())};function a(){const o=s[n],i=r[n];t(i)?e(i,g((t=>{u.give(t),e(d,o),c()}))):(u.give(i),e(d,o),c())}void 0!==r[n]?(a(),e(T(s),i)):o([],i)})))}},q=(t,r)=>{if(void 0===t)throw new Error("SourceMap didn't receive baseSource argument");if(void 0===r)throw new Error("SourceMap didn't receive targetSource argument");return o=>{e(t,s(o,(t=>{const n=[];t.forEach((e=>{const t=r.get(e);n.push(t)})),e(T(n),o)})))}},x=t=>{if(void 0===t)throw new Error("SourceRace didnt receive sources argument");return r=>{let n=null;t.forEach((t=>{e(t,s(r,(e=>{n&&n!==t||(o(e,r),n=t)})))}))}},A=(t,r)=>{if(void 0===t)throw new Error("SourceDynamic didn't receive baseGuest argument");if(void 0===r)throw new Error("SourceDynamic didn't receive baseSource argument");const n={value:t=>(e(r,t),n),give(e){return o(e,t),this}};return n},B=(t,r)=>n=>{e(t,s(n,(e=>{o(r(e),n)})))},I=(t,r)=>r((r=>{e(t,r)})),N=(t,r)=>n=>{e(t,s(n,(e=>{!0===r(e)&&o(e,n)})))},R=t=>{let r=void 0!==t;const o=F(t);return{value(t){return e(o,t),this},give(e){return r||(o.give(e),r=!0),this}}},H=t=>{const r=u();return e(t,f(r)),{value(r){return e(t,r),this},syncValue(){try{return r.value()}catch{throw new Error("No value in SourceSync")}}}},J=(e,t={})=>{if(void 0===e)throw new Error("PrivateClass didn't receive constructorFn argument");return{get:(...r)=>new e(...r,t)}},K=e=>{if(void 0===e)throw new Error("personal didn't receive buildingFn argument");return{get:(...t)=>e(...t)}};export{M as PatronPool,C as destroy,o as give,i as guest,c as guestApplied,s as guestCast,d as guestDisposable,a as guestExecutorApplied,u as guestSync,h as introduction,n as isGuest,v as isPatron,D as isPatronInPools,t as isSource,f as patron,O as patronApplied,V as patronExecutorApplied,g as patronOnce,j as patronPools,G as patronPoolsStatistic,K as personal,J as personalClass,z as removePatronFromPools,r as source,T as sourceAll,B as sourceApplied,F as sourceChangeable,A as sourceDynamic,I as sourceExecutorApplied,N as sourceFiltered,q as sourceMap,R as sourceOnce,x as sourceRace,k as sourceSequence,H as sourceSync,P as subSource,e as value};
//# sourceMappingURL=silentium.min.mjs.map
