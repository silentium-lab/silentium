const e=(e,t)=>{if(null==e)throw new Error("value didn't receive source argument");if(void 0===t||null===e)throw new Error("value didn't receive guest argument");return"function"==typeof e?e(t):"object"==typeof e&&"value"in e&&"function"==typeof e.value?e.value(t):n(e,t),e},t=e=>null!==e&&"object"==typeof e&&"value"in e&&"function"==typeof e.value||null!=e,r=t=>{if(void 0===t)throw new Error("Source constructor didn't receive executor function");return r=>{e(t,r)}},n=(e,t)=>{if(void 0===e)throw new Error("give didn't receive data argument");return void 0===t?r(e):("function"==typeof t?t(e):t.give(e),t)},o=e=>{if(void 0===e)throw new Error("isGuest didnt receive mbGuest argument");return"function"==typeof e||"function"==typeof e?.give},i=e=>{if(!e)throw new Error("receiver function was not passed to Guest constructor");const t={give:r=>(e(r),t)};return t},u=e=>{let t=!1;return()=>{t||e(),t=!0}},s=(e,t)=>{if(void 0===e)throw new Error("GuestCast didn't receive sourceGuest argument");if(void 0===t)throw new Error("GuestCast didn't receive targetGuest argument");const r={disposed(t){const r=e;return!!r.disposed&&r.disposed(t)},give:e=>(n(e,t),r),introduction:()=>"function"==typeof e?"guest":e.introduction?e.introduction():"guest"};return r},c=e=>{const t={give:r=>(e=r,t),value(){if(void 0===e)throw new Error("no value in GuestSync!");return e}};return t},d=(e,t)=>{if(void 0===e)throw new Error("GuestDisposable didn't receive guest argument");if(void 0===t)throw new Error("GuestDisposable didn't receive disposeCheck argument");const r={disposed:e=>t(e),give:t=>(n(t,e),r)};return r},a=(e,t)=>{const r={give:o=>(n(t(o),e),r)};return r},v=(e,t)=>({give:t((t=>n(t,e)))}),l=e=>"object"==typeof e&&null!==e&&"patron"===e?.introduction?.(),h=()=>"patron",f=e=>{if(void 0===e)throw new Error("Patron didn't receive willBePatron argument");const t={give:r=>(n(r,e),t),disposed(t){const r=e;return r?.disposed?.(t)||!1},introduction:h};return t},g=e=>{if(void 0===e)throw new Error("PatronOnce didn't receive baseGuest argument");let t=!1;const r={give:o=>(t||(t=!0,n(o,e)),r),disposed(r){if(t)return!0;const n=e;return!!n.disposed&&n.disposed(r)},introduction:h};return r};var p=Object.defineProperty,w=(e,t,r)=>((e,t,r)=>t in e?p(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);const E=new Map,y=new Map,m=new Map,b=[],S=()=>{b.forEach((e=>e()))},G={poolsCount:0,patronsCount:0},P=r((e=>{n(G,e),b.push((()=>{let t=0;E.forEach((e=>{t+=e.size})),G.poolsCount=E.size,G.patronsCount=t,n(G,e)}))})),j=(e,t)=>(m.has(t)||m.set(t,[]),m.get(t)?.push(e),e),z=(e,t)=>(t.forEach((t=>{j(e,t)})),e),C=e=>"object"==typeof e&&null!==e&&"destroy"in e&&"function"==typeof e.destroy,D=(...e)=>{e.forEach((e=>{C(e)&&e.destroy();const t=y.get(e);t?.destroy();const r=m.get(e);m.delete(e),r&&D(...r)}))},O=e=>{const t=[];return E.forEach(((r,n)=>{r.has(e)&&t.push(n)})),t},M=e=>{if(void 0===e)throw new Error("removePatronFromPools didn't receive patron argument");E.forEach((t=>{t.delete(e)})),S()},V=e=>{if(void 0===e)throw new Error("isPatronInPools didn't receive patron argument");let t=!1;return E.forEach((r=>{t||(t=r.has(e))})),t};class k{constructor(e){this.initiator=e,w(this,"patrons"),w(this,"give"),this.patrons=new Set,E.set(this,this.patrons),y.set(this.initiator,this);const t=e=>{this.patrons.forEach((t=>{this.sendValueToGuest(e,t)}))};this.give=e=>(t(e),this),S()}size(){return this.patrons.size}add(e){if(!e)throw new Error("PatronPool add method received nothing!");return"function"!=typeof e&&e.introduction&&"patron"===e.introduction()&&this.patrons.add(e),S(),this}remove(e){return this.patrons.delete(e),S(),this}distribute(e,t){return this.add(t),this.sendValueToGuest(e,t),this}destroy(){return this.patrons.forEach((e=>{this.remove(e)})),E.delete(this),y.delete(this.initiator),S(),this}sendValueToGuest(e,t){return this.guestDisposed(e,t)||n(e,t),this}guestDisposed(e,t){return!!t.disposed?.(e)&&(this.remove(t),!0)}}const F=(e,t)=>{const r=a(e,t),n={give:e=>(r.give(e),n),introduction:h};return n},T=(e,t)=>{const r=v(e,t),n={give:e=>(r.give(e),n),introduction:h};return n},q=(t,r)=>{const n=c(r);e(t,f(n));const o={value(r){return e(t,r),this},syncValue(){try{return n.value()}catch{throw new Error("No value in SourceSync")}}};return j(o,t),o},x=e=>null==e,B=r=>{const n={},o=new k(n);let u=x(r);return!u&&t(r)&&e(r,g((e=>{u=x(e),r=e}))),n.value=e=>u?(l(e)&&o.add(e),n):("function"==typeof e?o.distribute(r,i(e)):o.distribute(r,e),n),n.give=e=>(u=x(e),r=e,u||o.give(r),n),n},I=e=>{const t=B(e),r=q(t,null),o={value:t.value,give:e=>(r.syncValue()!==e&&n(e,t.give),o)};return o},N=t=>{const r=new Set(Object.keys(t)),o=new Set,c=B({}),d=[],a=u((()=>{Object.entries(t).forEach((([t,n])=>{j(c,n),r.add(t);const u=f((e=>{c.value(i((r=>{o.add(t);const n={...r,[t]:e};c.give(n)})))}));d.push(u),e(n,u)}))}));return{value(e){a();const t=s(e,(t=>{o.size>0&&o.size===r.size&&n(Object.values(t),e)}));d.push(t),c.value(t)},destroy(){d.forEach((e=>{M(e)}))}}},R=(r,o)=>{if(void 0===r)throw new Error("SourceSequence didn't receive baseSource argument");if(void 0===o)throw new Error("SourceSequence didn't receive targetSource argument");return i=>{const u=B(),c=o.get(u);e(r,s(i,(r=>{let o=0;const s=[];r.forEach((()=>{s.push(B())}));const d=()=>{void 0!==r[o+1]&&(o+=1,a())};function a(){const n=s[o],i=r[o];t(i)?e(i,g((t=>{u.give(t),e(c,n),d()}))):(u.give(i),e(c,n),d())}void 0!==r[o]?(a(),e(N(s),i)):n([],i)})))}},A=(t,r)=>{if(void 0===t)throw new Error("SourceMap didn't receive baseSource argument");if(void 0===r)throw new Error("SourceMap didn't receive targetSource argument");const o=B(),i=u((()=>{e(t,f((i=>{const u=[];i.forEach((e=>{const n=r.get(e);j(n,t),u.push(n)})),e(N(u),g((e=>{D(...u),n(e,o)})))})))}));return e=>{i(),o.value(e)}},H=t=>{if(void 0===t)throw new Error("SourceRace didnt receive sources argument");return r=>{let o=null;t.forEach((t=>{e(t,s(r,(e=>{o&&o!==t||(n(e,r),o=t)})))}))}},J=(...t)=>{const r=B(),n={},o=u((()=>{const o=t.at(-1);t.forEach(((i,u)=>{e(i,f((()=>{n[u]="1",Object.keys(n).length===t.length&&e(o,r)})))}))}));return e=>{o(),r.value(e)}},K=(t,r)=>{if(void 0===t)throw new Error("SourceDynamic didn't receive baseGuest argument");if(void 0===r)throw new Error("SourceDynamic didn't receive baseSource argument");const o={value:t=>(e(r,t),o),give(e){return n(e,t),this}};return o},L=(t,r)=>o=>{e(t,s(o,(e=>{n(r(e),o)})))},Q=(t,r)=>r((r=>{e(t,r)})),U=(t,r,o)=>i=>{e(t,s(i,(e=>{!0===r(e)?n(e,i):void 0!==o&&n(o,i)})))},W=t=>{let r=void 0!==t;const n=B(t);return{value(t){return e(n,t),this},give(e){return r||(n.give(e),r=!0),this}}},X=(...t)=>r=>{const n=B();return z(n,t),e(N(t),f((e=>{r(n.give,...e)}))),n.value},Y=(t,r)=>{const o=B(),i=u((()=>{e(r,f((()=>{n(null,o)}))),e(t,f(o)),j(o,t)}));return K(o.give,(e=>{i(),o.value(e)}))},Z=t=>{const r=B(),n=u((()=>{t.forEach((t=>{e(t,f(r))}))}));return e=>{n(),r.value(e)}},$=(t,r,n)=>{let o=null;const i=B(),u=Y(i,n??B());let s=!1;return n&&e(n,f((()=>{D(o),o=null}))),n=>{s||(s=!0,e(N(r),f((()=>{o||(o=t.get(...r),e(o,f(i)))})))),e(u,n)}},_=e=>{let t=null;return{value(r){return t=e(r),this},destroy(){return null!==t&&"function"==typeof t&&t(),this}}},ee=(e,t={})=>{if(void 0===e)throw new Error("PrivateClass didn't receive constructorFn argument");return{get:(...r)=>new e(...r,t)}},te=e=>{if(void 0===e)throw new Error("lazy didn't receive buildingFn argument");return{get:(...t)=>e(...t)}};export{k as PatronPool,D as destroy,u as firstVisit,n as give,i as guest,a as guestApplied,s as guestCast,d as guestDisposable,v as guestExecutorApplied,c as guestSync,h as introduction,C as isDestroyable,o as isGuest,l as isPatron,V as isPatronInPools,t as isSource,te as lazy,ee as lazyClass,f as patron,F as patronApplied,T as patronExecutorApplied,g as patronOnce,O as patronPools,P as patronPoolsStatistic,M as removePatronFromPools,r as source,N as sourceAll,Z as sourceAny,L as sourceApplied,J as sourceChain,X as sourceCombined,_ as sourceDestroyable,K as sourceDynamic,Q as sourceExecutorApplied,U as sourceFiltered,$ as sourceLazy,A as sourceMap,I as sourceMemoOf,B as sourceOf,W as sourceOnce,H as sourceRace,Y as sourceResettable,R as sourceSequence,q as sourceSync,j as subSource,z as subSourceMany,e as value};
//# sourceMappingURL=silentium.min.mjs.map
