const e=(...e)=>{const t=new Set(Object.keys(e)),r=new Set;return n=>{const o={};Object.entries(e).forEach((([e,s])=>{t.add(e),s((s=>{r.add(e),o[e]=s,((e,t)=>e.size>0&&e.size===t.size)(r,t)&&n(Object.values(o))}))}))}},t=(...e)=>t=>{e.forEach((e=>{e(t)}))},r=(e,t)=>r=>{e((e=>{r(t(e))}))},n=(...e)=>t=>{let r;const n=o=>{const s=e[o],i=e[o+1];s((e=>{i||(r=e),r&&t(r),i&&!r&&n(o+1)}))};n(0)},o=(e,t)=>r=>{e(t((e=>{r(e)})))},s=(e,t,r)=>n=>{e((e=>{t(e)?n(e):void 0!==r&&n(r)}))},i=(t,r,n,o)=>{let s=null;const i=e=>{s&&s(e)};return u=>{s=u;return e(t,r,n)((([e,t,r])=>{e?.[r]&&e[r](t,i)})),()=>{if(s=null,!o)return;e(t,r,o)((([e,t,r])=>{e[r](t,i)}))}}},u=(e,t)=>r=>{e.then((e=>{r(e)})).catch((e=>{t?.(e)}))},c=e=>null!=e;var l=Object.defineProperty,a=(e,t,r)=>((e,t,r)=>t in e?l(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r)(e,"symbol"!=typeof t?t+"":t,r);class h{constructor(){a(this,"owners"),a(this,"innerOwner"),this.owners=new Set,this.innerOwner=e=>{this.owners.forEach((t=>{t(e)}))}}owner(){return this.innerOwner}size(){return this.owners.size}has(e){return this.owners.has(e)}add(e){return this.owners.add(e),this}remove(e){return this.owners.delete(e),this}destroy(){return this.owners.forEach((e=>{this.remove(e)})),this}}const v=e=>{let t=null;const r=e=>{c(e)&&t&&t(e)};return{value:n=>{if(t)throw new Error("Late component gets new user, when another was already connected!");t=n,r(e)},give:e=>{r(e)}}},w=e=>t=>{let r=!1;e((e=>{r||(r=!0,t(e))}))},d=(e,t=!1)=>{const r=new h;let n;const o=v();return w(o.value)((()=>{e((e=>{r.owner()(e),n=e}))})),{value:e=>(o.give(1),t||!c(n)||r.has(e)||e(n),r.add(e),()=>{r.remove(e)}),give:e=>{n=e,r.owner()(e)},pool:()=>r,destroy(){r.destroy()}}},f=(e,t=!1)=>{const r=d(e.value,t);return{value:e=>{r.value(e)},give:t=>{e.give(t)}}},p=e=>{const t=f(v(e));return{value:t.value,give:t.give}},y=(e,t)=>(...r)=>t(e(...r)),g=(e,t,r=0)=>(...n)=>e(...function(e,t,r){const n=e.slice(0,r);for(;n.length<r;)n.push(void 0);return n.concat(t)}(n,t,r));const m=e=>{const t=[];return{get:(...r)=>{const n=e(...r);return t.push(n),n},destroy:()=>{t.forEach((e=>e.destroy()))}}},E=e=>t=>t(e),b=(e,t)=>e(t),O=()=>()=>{},z=(e,t)=>r=>{const n=e(r);return n&&t&&t(n),()=>{n?.()}},j=(t,r)=>n=>{t((t=>{const o=[];t.forEach((e=>{let t=e;"function"!=typeof t&&(t=E(t));const n=r(t);o.push(n)}));e(...o)(n)}))},S=(e,t=null)=>(e((e=>{t=e})),{[Symbol.toPrimitive]:()=>t,primitive:()=>t,primitiveWithException(){if(null===t)throw new Error("Primitive value is null");return t}}),P=e=>t=>{const r=[];e((e=>{r.push(e),t(r)}))},x=e=>t=>{e((e=>{e.forEach((e=>{t(e)}))}))};export{h as OwnerPool,O as _void,e as all,t as any,r as applied,n as chain,z as destructor,o as executorApplied,s as filtered,i as fromEvent,u as fromPromise,c as isFilled,v as late,p as lateShared,y as lazyApplied,g as lazyArgs,m as lazyDestroyable,j as map,E as of,b as on,w as once,S as primitive,P as sequence,d as shared,f as sharedSource,x as stream};
//# sourceMappingURL=silentium.min.mjs.map
