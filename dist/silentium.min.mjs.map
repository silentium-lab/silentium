{"version":3,"file":"silentium.min.mjs","sources":["../src/helpers/isFilled.ts","../src/helpers/OwnerPool.ts","../src/helpers/onExecuted.ts","../src/helpers/destroyArr.ts","../src/components/All.ts","../src/components/Any.ts","../src/components/Applied.ts","../src/components/Chain.ts","../src/components/ExecutorApplied.ts","../src/components/Filtered.ts","../src/components/FromCallback.ts","../src/components/FromEvent.ts","../src/components/Of.ts","../src/components/FromPromise.ts","../src/components/Information.ts","../src/components/LazyChain.ts","../src/components/LazyClass.ts","../src/components/Map.ts","../src/components/Once.ts","../src/components/Sequence.ts","../src/components/Shared.ts","../src/components/Stream.ts"],"sourcesContent":["export const isFilled = <T>(value?: T): value is T => {\n  return value !== undefined && value !== null;\n};\n","import { OwnerType } from \"../types\";\n\n/**\n * Helps maintain an owner list allowing different\n * owners to get information from a common source\n * https://silentium-lab.github.io/silentium/#/en/utils/owner-pool\n */\nexport class OwnerPool<T> {\n  private owners: Set<OwnerType<T>>;\n  private innerOwner: OwnerType<T>;\n\n  public constructor() {\n    this.owners = new Set<OwnerType<T>>();\n    this.innerOwner = (v) => {\n      this.owners.forEach((g) => {\n        g(v);\n      });\n    };\n  }\n\n  public owner() {\n    return this.innerOwner;\n  }\n\n  public size(): number {\n    return this.owners.size;\n  }\n\n  public has(owner: OwnerType<T>): boolean {\n    return this.owners.has(owner);\n  }\n\n  public add(shouldBePatron: OwnerType<T>) {\n    this.owners.add(shouldBePatron);\n    return this;\n  }\n\n  public remove(g: OwnerType<T>) {\n    this.owners.delete(g);\n    return this;\n  }\n\n  public destroy() {\n    this.owners.forEach((g) => {\n      this.remove(g);\n    });\n    return this;\n  }\n}\n","/**\n * Helps to run callback only once\n * when information was executed at first time\n */\nexport const onExecuted = (fn: (...args: any[]) => void) => {\n  let executed = false;\n  return (...args: unknown[]) => {\n    if (!executed) {\n      fn(...args);\n    }\n    executed = true;\n  };\n};\n","export const destroyArr = (arr: unknown[]) => {\n  arr.forEach((item) => {\n    if (typeof item === \"function\") {\n      item();\n    }\n  });\n};\n","import { destroyArr } from \"../helpers\";\nimport { InformationType } from \"../types\";\n\ntype ExtractTypeS<T> = T extends InformationType<infer U> ? U : never;\n\nexport type ExtractTypesFromArrayS<T extends InformationType<any>[]> = {\n  [K in keyof T]: ExtractTypeS<T[K]>;\n};\n\n/**\n * Combines multiple information sources into a single unified source\n * represented as an array containing values from all sources\n * https://silentium-lab.github.io/silentium/#/en/information/all\n */\nexport const all = <const T extends InformationType[]>(\n  ...infos: T\n): InformationType<ExtractTypesFromArrayS<T>> => {\n  return (g) => {\n    const keysKnown = new Set<string>(Object.keys(infos));\n    const keysFilled = new Set();\n    const isAllFilled = () => {\n      return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n    };\n    const result: Record<string, unknown> = {};\n    const destructors: unknown[] = [];\n\n    Object.entries(infos).forEach(([key, info]) => {\n      keysKnown.add(key);\n      destructors.push(\n        info((v) => {\n          keysFilled.add(key);\n          result[key] = v;\n          if (isAllFilled()) {\n            return g(Object.values(result) as ExtractTypesFromArrayS<T>);\n          }\n        }),\n      );\n    });\n\n    return () => {\n      keysKnown.clear();\n      keysFilled.clear();\n      destroyArr(destructors);\n    };\n  };\n};\n","import { destroyArr } from \"../helpers\";\nimport { InformationType } from \"../types\";\n\n/**\n * From a set of information sources we get\n * a common response from any source for a single owner\n * https://silentium-lab.github.io/silentium/#/en/information/any\n */\nexport const any = <T>(...infos: InformationType<T>[]): InformationType<T> => {\n  return (o) => {\n    const destructors: unknown[] = [];\n    infos.forEach((info) => {\n      destructors.push(info(o));\n    });\n\n    return () => {\n      destroyArr(destructors);\n    };\n  };\n};\n","import { InformationType, OwnerType } from \"../types\";\n\n/**\n * Information to which the function was applied to change the value\n * https://silentium-lab.github.io/silentium/#/en/information/applied\n */\nexport const applied = <T, R>(\n  base: InformationType<T>,\n  applier: (v: T) => R,\n): InformationType<R> => {\n  return (g: OwnerType<R>) => {\n    return base((v) => {\n      return g(applier(v));\n    });\n  };\n};\n","import { destroyArr, onExecuted } from \"../helpers\";\nimport { InformationType, OwnerType } from \"../types\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends any[]> = T extends [...infer U, infer L] ? L : never;\n\n/**\n * The set of information sources forms a sequential chain where each source provides\n * an answer. The final answer will be the output result. If any source in the chain\n * provides a new answer, the component's overall response will be repeated.\n * https://silentium-lab.github.io/silentium/#/en/information/applied\n */\nexport const chain = <T extends InformationType[]>(...infos: T): Last<T> => {\n  let theOwner: OwnerType<Last<T>> | undefined;\n  let lastValue: Last<T> | undefined;\n  const respondedI = new WeakMap();\n  const destructors: unknown[] = [];\n\n  const handleI = (index: number) => {\n    const info = infos[index] as InformationType<Last<T>>;\n    const nextI = infos[index + 1] as InformationType<Last<T>> | undefined;\n\n    info((v) => {\n      if (!nextI) {\n        lastValue = v;\n        destructors.push(theOwner?.(v));\n      }\n\n      if (nextI && lastValue !== undefined && theOwner !== undefined) {\n        destructors.push(theOwner?.(lastValue));\n      }\n\n      if (nextI && !respondedI.has(info)) {\n        handleI(index + 1);\n      }\n\n      respondedI.set(info, 1);\n    });\n  };\n\n  const executed = onExecuted((g) => {\n    theOwner = g;\n    handleI(0);\n  });\n\n  const info = <Last<T>>((g) => {\n    executed(g);\n    theOwner = g;\n    return () => {\n      destroyArr(destructors);\n    };\n  });\n\n  return info;\n};\n","import { InformationType, OwnerType } from \"../types\";\n\n/**\n * Information to which a function is applied in order\n * to control the value passing process\n * https://silentium-lab.github.io/silentium/#/en/information/applied\n */\nexport const executorApplied = <T>(\n  base: InformationType<T>,\n  applier: (executor: OwnerType<T>) => OwnerType<T>,\n): InformationType<T> => {\n  return (owner) => {\n    return base(applier(owner));\n  };\n};\n","import { InformationType } from \"../types\";\n\n/**\n * Information whose value is being validated\n * via a predicate; if the predicate returns true, the value\n * can be passed to the output\n * https://silentium-lab.github.io/silentium/#/en/information/filtered\n */\nexport const filtered = <T>(\n  base: InformationType<T>,\n  predicate: (v: T) => boolean,\n  defaultValue?: T,\n): InformationType<T> => {\n  return (owner) => {\n    return base((v) => {\n      if (predicate(v)) {\n        return owner(v);\n      } else if (defaultValue !== undefined) {\n        return owner(defaultValue);\n      }\n    });\n  };\n};\n","import { InformationType } from \"../types\";\n\n/**\n * When receiving a reference to a function expecting a callback, the component\n * creates its own callback, and the data received in this callback\n * will become the value of the information object\n * https://silentium-lab.github.io/silentium/#/en/information/from-callback\n */\nexport const fromCallback = <T>(\n  waitForCb: (cb: (v: T) => any, ...args: unknown[]) => unknown,\n  ...args: unknown[]\n): InformationType<T> => {\n  return (o) => {\n    waitForCb(\n      (v) => {\n        o(v);\n      },\n      ...args,\n    );\n  };\n};\n","import { InformationType } from \"../types\";\n\n/**\n * A component that receives data from an event and\n * presents it as an information object\n * https://silentium-lab.github.io/silentium/#/en/information/from-event\n */\nexport const fromEvent = (\n  emitter: any,\n  eventName: string,\n  subscribeMethod: string,\n  unsubscribeMethod?: string,\n): InformationType => {\n  return (o) => {\n    const handler = (...args: any[]) => {\n      o(args);\n    };\n    emitter[subscribeMethod](eventName, handler);\n    return () => {\n      if (unsubscribeMethod !== undefined) {\n        emitter[unsubscribeMethod](eventName, handler);\n      }\n    };\n  };\n};\n","import { isFilled } from \"../helpers\";\nimport { InformationType, OwnerType } from \"../types\";\n\n/**\n * A component that allows creating linked objects of information and its owner\n * in such a way that if a new value is assigned to the owner, this value\n * will become the value of the linked information source\n * https://silentium-lab.github.io/silentium/#/en/information/of\n */\nexport const of = <T>(sharedValue?: T) => {\n  let relatedO: OwnerType<T> | undefined;\n\n  const notifyO = () => {\n    if (relatedO !== undefined && isFilled(sharedValue)) {\n      return relatedO(sharedValue);\n    }\n  };\n\n  const info = <InformationType<T>>((o) => {\n    relatedO = o;\n    return notifyO();\n  });\n\n  return [\n    info,\n    (v: T) => {\n      sharedValue = v;\n      return notifyO();\n    },\n  ] as const;\n};\n","import { InformationType } from \"../types\";\nimport { of } from \"./Of\";\n\n/**\n * Component that gets a value from a promise and\n * presents it as information\n * https://silentium-lab.github.io/silentium/#/en/information/from-promise\n */\nexport const fromPromise = <T>(\n  p: Promise<T>,\n): [InformationType<T>, InformationType] => {\n  const [errorInf, errorOwn] = of();\n\n  return [\n    (own) => {\n      p.then((v) => {\n        own(v);\n      }).catch((e) => {\n        errorOwn(e);\n      });\n    },\n    errorInf,\n  ];\n};\n","import { InformationType } from \"../types\";\n\nexport const i =\n  <T>(v: T): InformationType<T> =>\n  (o) => {\n    return o(v);\n  };\n","import { InformationType, LazyType } from \"../types\";\nimport { chain } from \"./Chain\";\n\n/**\n * Helps to chain lazy info after\n * another lazy info\n */\nexport const lazyChain = <T>(\n  lazy: LazyType<T>,\n  chainSrc: InformationType<T>,\n): LazyType<T> => {\n  return (...args) => {\n    const baseSrc = lazy(...args);\n    return chain(chainSrc, baseSrc);\n  };\n};\n","import { OwnerType } from \"../types\";\n\nexport const lazyClass =\n  (constrFn: any) =>\n  (...args: any[]) => {\n    const inst = new constrFn(...args);\n    return (o: OwnerType<any>) => {\n      inst.value(o);\n    };\n  };\n","import { InformationType, LazyType } from \"../types\";\nimport { all } from \"./All\";\nimport { i } from \"./Information\";\n\n/**\n * Component that applies an info object constructor to each data item,\n * producing an information source with new values\n * https://silentium-lab.github.io/silentium/#/en/information/map\n */\nexport const map = <T, TG>(\n  base: InformationType<T[]>,\n  targetI: LazyType<TG>,\n): InformationType<TG[]> => {\n  return (g) => {\n    base((v) => {\n      const infos: InformationType<TG>[] = [];\n      v.forEach((val) => {\n        let valInfo: InformationType<T> | T = val;\n        if (typeof valInfo !== \"function\") {\n          valInfo = i(valInfo);\n        }\n        const info = targetI(valInfo);\n        infos.push(info);\n      });\n      const allI = all(...infos);\n      allI(g);\n    });\n  };\n};\n","import { InformationType } from \"../types\";\n\n/**\n * Limits the number of values from the information source\n * to a single value - once the first value is emitted, no more\n * values are delivered from the source\n * https://silentium-lab.github.io/silentium/#/en/information/once\n */\nexport const once = <T>(base: InformationType<T>): InformationType<T> => {\n  return (owner) => {\n    let isFilled = false;\n    base((v) => {\n      if (!isFilled) {\n        isFilled = true;\n        owner(v);\n      }\n    });\n  };\n};\n","import { InformationType } from \"../types\";\n\n/**\n * A component that takes one value at a time and returns\n * an array of all previous values\n * https://silentium-lab.github.io/silentium/#/en/information/sequence\n */\nexport const sequence = <T>(base: InformationType<T>): InformationType<T[]> => {\n  return (o) => {\n    const result: T[] = [];\n\n    base((v) => {\n      result.push(v);\n      o(result);\n    });\n  };\n};\n","import { DestructorType } from \"../types/DestructorType\";\nimport { isFilled, onExecuted, OwnerPool } from \"../helpers\";\nimport { InformationType, OwnerType } from \"../types\";\n\n/**\n * An information object that helps multiple owners access\n * a single another information object\n * https://silentium-lab.github.io/silentium/#/en/information/pool\n */\nexport const shared = <T>(base: InformationType<T>) => {\n  const ownersPool = new OwnerPool<T>();\n  let lastValue: T | undefined;\n  let baseDestructor: DestructorType | void;\n\n  const executed = onExecuted(() => {\n    const gp = ownersPool.owner();\n    baseDestructor = base((v) => {\n      gp(v);\n      lastValue = v;\n    });\n  });\n\n  const i = (g: OwnerType<T>) => {\n    executed();\n    let od: DestructorType | void;\n    if (isFilled(lastValue) && !ownersPool.has(g)) {\n      od = g(lastValue);\n    }\n    ownersPool.add(g);\n    return () => {\n      ownersPool.remove(g);\n      od?.();\n    };\n  };\n\n  return [\n    i,\n    () => {\n      ownersPool.destroy();\n      baseDestructor?.();\n    },\n    ownersPool,\n  ] as const;\n};\n\nexport const sharedStateless = <T>(base: InformationType<T>) => {\n  const ownersPool = new OwnerPool<T>();\n  let baseDestructor: DestructorType | void;\n\n  const executed = onExecuted((g: OwnerType<T>) => {\n    ownersPool.add(g);\n    baseDestructor = base(ownersPool.owner());\n  });\n\n  const i = (g: OwnerType<T>) => {\n    executed(g);\n    if (!ownersPool.has(g)) {\n      ownersPool.add(g);\n    }\n    return () => {\n      ownersPool.remove(g);\n    };\n  };\n\n  return [\n    i,\n    () => {\n      ownersPool.destroy();\n      baseDestructor?.();\n    },\n    ownersPool,\n  ] as const;\n};\n","import { InformationType } from \"../types\";\n\n/**\n * Component that receives a data array and yields values one by one\n * https://silentium-lab.github.io/silentium/#/en/information/stream\n */\nexport const stream = <T>(base: InformationType<T[]>): InformationType<T> => {\n  return (o) => {\n    base((v) => {\n      v.forEach((cv) => {\n        o(cv);\n      });\n    });\n  };\n};\n"],"names":["isFilled","value","OwnerPool","constructor","__publicField","this","owners","Set","innerOwner","v","forEach","g","owner","size","has","add","shouldBePatron","remove","delete","destroy","onExecuted","fn","executed","args","destroyArr","arr","item","all","infos","keysKnown","Object","keys","keysFilled","result","destructors","entries","key","info","push","values","clear","any","o","applied","base","applier","chain","theOwner","lastValue","respondedI","WeakMap","handleI","index","nextI","set","executorApplied","filtered","predicate","defaultValue","fromCallback","waitForCb","fromEvent","emitter","eventName","subscribeMethod","unsubscribeMethod","handler","of","sharedValue","relatedO","notifyO","fromPromise","p","errorInf","errorOwn","own","then","catch","e","i","lazyChain","lazy","chainSrc","baseSrc","lazyClass","constrFn","inst","map","targetI","val","valInfo","allI","once","sequence","shared","ownersPool","baseDestructor","gp","od","sharedStateless","stream","cv"],"mappings":"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"}