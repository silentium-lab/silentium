{"version":3,"file":"silentium.min.mjs","sources":["../src/helpers/guards.ts","../src/base/Destroyable.ts","../src/base/DestroyContainer.ts","../src/helpers/ensures.ts","../src/base/Message.ts","../src/base/Transport.ts","../src/base/Local.ts","../src/base/New.ts","../src/base/Of.ts","../src/base/TransportOptional.ts","../src/base/Void.ts","../src/components/All.ts","../src/components/Any.ts","../src/components/Applied.ts","../src/components/AppliedDestructured.ts","../src/components/Catch.ts","../src/components/Chain.ts","../src/components/ExecutorApplied.ts","../src/components/Filtered.ts","../src/components/FromEvent.ts","../src/components/FromPromise.ts","../src/components/Late.ts","../src/components/Once.ts","../src/helpers/TransportPool.ts","../src/components/Shared.ts","../src/components/SharedSource.ts","../src/components/Primitive.ts","../src/components/LateShared.ts","../src/components/Map.ts","../src/components/RPC.ts","../src/components/RPCChain.ts","../src/components/RPCOf.ts","../src/components/Sequence.ts","../src/components/Stream.ts","../src/components/TransportApplied.ts","../src/components/TransportArgs.ts","../src/components/TransportDestroyable.ts"],"sourcesContent":["import { DestroyableType, DestroyedType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Checks that the value is neither undefined nor null\n */\nexport const isFilled = <T>(\n  value?: T,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\n/**\n * Checks that the object is an message\n */\nexport function isMessage<T>(o: T): o is T & MessageType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"to\" in o &&\n    typeof (o as any).to === \"function\"\n  );\n}\n\n/**\n * Checks that the object is destroyable\n */\nexport function isDestroyable<T>(o: T): o is T & DestroyableType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroy\" in o &&\n    typeof (o as any).destroy === \"function\"\n  );\n}\n\n/**\n * Checks that the object can indicate whether it has been destroyed or not\n */\nexport function isDestroyed<T>(o: T): o is T & DestroyedType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroyed\" in o &&\n    typeof (o as any).destroy === \"function\"\n  );\n}\n\n/**\n * Checks that the object is a transport\n */\nexport function isTransport<T>(o: T): o is T & TransportType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"use\" in o &&\n    typeof (o as any).use === \"function\"\n  );\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * Allows creating an object that definitely has a destructor,\n * useful to avoid creating unnecessary conditions\n */\nexport function Destroyable<T>(base: T) {\n  return new DestroyableImpl(base);\n}\n\nexport class DestroyableImpl<T> implements DestroyableType {\n  public constructor(private base: T) {}\n\n  public destroy(): this {\n    if (isDestroyable(this.base)) {\n      this.base.destroy();\n    }\n    return this;\n  }\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * An object that allows collecting all disposable objects and\n * disposing them later all together\n */\nexport function DestroyContainer() {\n  return new DestroyContainerImpl();\n}\n\nexport class DestroyContainerImpl implements DestroyableType {\n  private destructors: DestroyableType[] = [];\n\n  public add<R>(e: R): R {\n    if (isDestroyable(e)) {\n      this.destructors.push(e);\n    }\n    return e;\n  }\n\n  public destroy() {\n    this.destructors.forEach((d) => d.destroy());\n    this.destructors.length = 0;\n    return this;\n  }\n}\n","import { isMessage, isTransport } from \"helpers/guards\";\n\nexport function ensureFunction(v: unknown, label: string) {\n  if (typeof v !== \"function\") {\n    throw new Error(`${label}: is not function`);\n  }\n}\n\nexport function ensureMessage(v: unknown, label: string) {\n  if (!isMessage(v)) {\n    throw new Error(`${label}: is not message`);\n  }\n}\n\nexport function ensureTransport(v: unknown, label: string) {\n  if (!isTransport(v)) {\n    throw new Error(`${label}: is not transport`);\n  }\n}\n","import { ensureFunction } from \"helpers/ensures\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\ntype MessageExecutorType<T> = (\n  transport: TransportType<T>,\n) => void | (() => void);\n\n/**\n * A message created from an executor function.\n * The executor function can return a message destruction function.\n */\nexport function Message<T>(executor: MessageExecutorType<T>) {\n  return new MessageImpl<T>(executor);\n}\n\nexport class MessageImpl<T> implements MessageType<T>, DestroyableType {\n  private mbDestructor: unknown;\n\n  public constructor(private executor: MessageExecutorType<T>) {\n    ensureFunction(executor, \"Message: executor\");\n  }\n\n  public to(transport: TransportType<T>) {\n    this.mbDestructor = this.executor(transport);\n    return this;\n  }\n\n  public destroy() {\n    if (typeof this.mbDestructor === \"function\") {\n      this.mbDestructor?.();\n    }\n    return this;\n  }\n}\n","import { ensureFunction } from \"helpers/ensures\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Type of value transfer logic executor\n */\nexport type TransportExecutor<T> = (v: T) => void;\n\n/**\n * Base transport that accepts the passed value,\n * acts as a conductor to deliver the value from a message to somewhere\n */\nexport function Transport<T>(transportExecutor: TransportExecutor<T>) {\n  return new TransportImpl<T>(transportExecutor);\n}\n\nexport class TransportImpl<T> implements TransportType<T> {\n  public constructor(private executor: TransportExecutor<T>) {\n    ensureFunction(executor, \"Transport: transport executor\");\n  }\n\n  public use(value: T) {\n    this.executor(value);\n    return this;\n  }\n}\n\n/**\n * Type of executor for value passing logic and message returning\n */\nexport type TransportMessageExecutor<T, ET = T> = (v: T) => MessageType<ET>;\n\n/**\n * A transport that delivers a value from one message\n * and returns another message based on the value\n */\nexport function TransportMessage<T, ET = any>(\n  executor: TransportMessageExecutor<T, ET>,\n) {\n  return new TransportMessageImpl<T, ET>(executor);\n}\n\nexport class TransportMessageImpl<T, ET = T>\n  implements TransportType<T, MessageType<ET>>\n{\n  public constructor(private executor: TransportMessageExecutor<T, ET>) {\n    ensureFunction(executor, \"TransportMessage: transport executor\");\n  }\n\n  public use(value: T) {\n    return this.executor(value);\n  }\n}\n\n/**\n * A transport that accepts a child transport\n * to perform some transformation on the value\n * during its transmission\n */\nexport function TransportParent<T>(\n  executor: (this: TransportType, v: T, ...context: any[]) => void,\n  ...args: any[]\n) {\n  return new TransportParentImpl<T>(executor, args);\n}\n\nexport class TransportParentImpl<T> implements TransportType<T> {\n  public constructor(\n    private executor: (this: TransportType, v: T, ...context: any[]) => void,\n    private args: any[] = [],\n    private _child?: TransportType<T>,\n  ) {\n    ensureFunction(executor, \"TransportParent: executor\");\n  }\n\n  public use(value: T): this {\n    if (this._child === undefined) {\n      throw new Error(\"no base transport\");\n    }\n    this.executor.call(this._child, value, ...this.args);\n    return this;\n  }\n\n  public child(transport: TransportType, ...args: any[]) {\n    return new TransportParentImpl(\n      this.executor,\n      [...this.args, ...args],\n      transport,\n    );\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TransportParent } from \"base/Transport\";\nimport { ensureMessage } from \"helpers/ensures\";\nimport { TransportType } from \"types/TransportType\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * Create local copy of source what can be destroyed\n */\nexport function Local<T>($base: MessageType<T>) {\n  return new LocalImpl<T>($base);\n}\n\nexport class LocalImpl<T> implements MessageType<T>, DestroyableType {\n  private destroyed = false;\n\n  public constructor(private $base: MessageType<T>) {\n    ensureMessage($base, \"Local: $base\");\n  }\n\n  public to(transport: TransportType<T>): this {\n    this.$base.to(this.transport.child(transport));\n    return this;\n  }\n\n  private transport = TransportParent(function (v: T, child: LocalImpl<T>) {\n    if (!child.destroyed) {\n      this.use(v);\n    }\n  }, this);\n\n  public destroy(): this {\n    this.destroyed = true;\n    return this;\n  }\n}\n","import { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * A component that, on each access, returns a new instance\n * of a reference type based on the constructor function\n */\nexport function New<T>(construct: ConstructorType<[], T>) {\n  return Message<T>((transport) => {\n    transport.use(construct());\n  });\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Helps convert a value into a message\n */\nexport function Of<T>(value: T) {\n  return new OfImpl<T>(value);\n}\n\nexport class OfImpl<T> implements MessageType<T> {\n  public constructor(private value: T) {}\n\n  public to(transport: TransportType<T>): this {\n    transport.use(this.value);\n    return this;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Allows subscribing a transport to a message\n * even if the transport reference does not exist,\n * helps avoid unnecessary conditions in application code\n */\nexport function TransportOptional(base?: TransportType) {\n  return new TransportOptionalImpl(base);\n}\n\nexport class TransportOptionalImpl {\n  public constructor(private base?: TransportType) {}\n\n  public wait(m: MessageType) {\n    if (this.base !== undefined) {\n      m.to(this.base);\n    }\n    return this;\n  }\n}\n","import { TransportType } from \"types/TransportType\";\n\n/**\n * Transport that does nothing with the passed value,\n * needed for silent message triggering\n */\nexport function Void() {\n  return new VoidImpl();\n}\n\nexport class VoidImpl implements TransportType {\n  public use(): this {\n    return this;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TransportParent } from \"base/Transport\";\nimport { TransportType } from \"types/TransportType\";\nimport { ensureMessage } from \"helpers/ensures\";\n\ntype ExtractTypeS<T> = T extends MessageType<infer U> ? U : never;\n\ntype ExtractTypesFromArrayS<T extends MessageType<any>[]> = {\n  [K in keyof T]: ExtractTypeS<T[K]>;\n};\n\nconst isAllFilled = (keysFilled: Set<string>, keysKnown: Set<string>) => {\n  return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n};\n\n/**\n * A message that represents values from\n * all provided messages as an array.\n * When all messages emit their values,\n * the combined value will be returned.\n * If at least one message later emits a new\n * value, the updated array with the new value\n * will be emitted by All.\n */\nexport function All<const T extends MessageType[]>(...messages: T) {\n  return new AllImpl<T>(...messages);\n}\n\nexport class AllImpl<const T extends MessageType[]>\n  implements MessageType<ExtractTypesFromArrayS<T>>\n{\n  private known: Set<string>;\n  private filled = new Set<string>();\n  private $messages: T;\n  private result: unknown[] = [];\n\n  public constructor(...messages: T) {\n    this.known = new Set<string>(Object.keys(messages));\n    this.$messages = messages;\n  }\n\n  public to(transport: TransportType<ExtractTypesFromArrayS<T>>): this {\n    Object.entries(this.$messages).forEach(([key, message]) => {\n      ensureMessage(message, \"All: item\");\n      message.to(this.transport.child(transport, key));\n    });\n    if (this.known.size === 0) {\n      transport.use([] as ExtractTypesFromArrayS<T>);\n    }\n    return this;\n  }\n\n  private transport = TransportParent(function (\n    v: unknown,\n    child: AllImpl<T>,\n    key: string,\n  ) {\n    child.filled.add(key);\n    child.result[parseInt(key)] = v;\n    if (isAllFilled(child.filled, child.known)) {\n      this.use(child.result as ExtractTypesFromArrayS<T>);\n    }\n  }, this);\n}\n","import { ensureMessage } from \"helpers/ensures\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * A message that emits values received from\n * any of its bound messages\n */\nexport function Any<const T>(...messages: MessageType<T>[]) {\n  return new AnyImpl<T>(...messages);\n}\n\nexport class AnyImpl<T> implements MessageType<T> {\n  private $messages: MessageType<T>[];\n\n  public constructor(...messages: MessageType<T>[]) {\n    this.$messages = messages;\n  }\n\n  public to(transport: TransportType<T>): this {\n    this.$messages.forEach((message) => {\n      ensureMessage(message, \"Any: item\");\n      message.to(transport);\n    });\n    return this;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TransportParent } from \"base/Transport\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { ensureMessage } from \"helpers/ensures\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * An message that applies a function\n * to the value of the base message\n */\nexport function Applied<const T, R>(\n  $base: MessageType<T>,\n  applier: ConstructorType<[T], R>,\n) {\n  return new AppliedImpl<T, R>($base, applier);\n}\n\nexport class AppliedImpl<T, R> implements MessageType<R> {\n  public constructor(\n    private $base: MessageType<T>,\n    private applier: ConstructorType<[T], R>,\n  ) {\n    ensureMessage($base, \"Applied: base\");\n  }\n\n  public to(transport: TransportType<R>) {\n    this.$base.to(this.transport.child(transport));\n    return this;\n  }\n\n  private transport = TransportParent(function (\n    v: T,\n    child: AppliedImpl<T, R>,\n  ) {\n    this.use(child.applier(v));\n  }, this);\n}\n","import { Applied } from \"components/Applied\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Allows applying variables from an message that passes an array to a function,\n * where each element of the array will be passed as a separate argument\n */\nexport function AppliedDestructured<const T extends any[], R>(\n  $base: MessageType<T>,\n  applier: ConstructorType<T[number][], R>,\n) {\n  return Applied($base, (args) => {\n    return applier(...args);\n  });\n}\n","import { ensureMessage, ensureTransport } from \"helpers/ensures\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * An message representing a base message where\n * its operation is wrapped in try-catch\n * and expects exceptions. If an exception\n * bubbles up, it's passed to the transports\n * as errorMessage and errorOriginal\n */\nexport function Catch<T>(\n  $base: MessageType<T>,\n  errorMessage: TransportType,\n  errorOriginal?: TransportType,\n) {\n  return new CatchImpl<T>($base, errorMessage, errorOriginal);\n}\n\nexport class CatchImpl<T> implements MessageType<T> {\n  public constructor(\n    private $base: MessageType<T>,\n    private errorMessage: TransportType,\n    private errorOriginal?: TransportType,\n  ) {\n    ensureMessage($base, \"Catch: base\");\n    ensureTransport(errorMessage, \"Catch: errorMessage\");\n    if (errorOriginal !== undefined) {\n      ensureTransport(errorOriginal, \"Catch: errorOriginal\");\n    }\n  }\n\n  public to(transport: TransportType<T>) {\n    try {\n      this.$base.to(transport);\n    } catch (e: unknown) {\n      if (e instanceof Error) {\n        this.errorMessage.use(e.message);\n      } else {\n        this.errorMessage.use(String(e));\n      }\n      if (this.errorOriginal) {\n        this.errorOriginal.use(e);\n      }\n    }\n    return this;\n  }\n}\n","import { TransportType } from \"types/TransportType\";\nimport { TransportParent } from \"base/Transport\";\nimport { MessageType, MessageTypeValue } from \"types/MessageType\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends readonly any[]> = T extends readonly [...infer _, infer L]\n  ? L\n  : never;\n\n/**\n * Chains messages together and triggers\n * the last message only when all previous messages\n * have emitted their values. The value of Chain will be the value\n * of the last message. If any messages\n * emit a value again after the overall Chain response was already returned,\n * then Chain emits again with the value of the last message.\n */\nexport function Chain<T extends readonly MessageType[]>(...messages: T) {\n  return new ChainImpl<T>(...messages);\n}\n\nexport class ChainImpl<T extends readonly MessageType[]>\n  implements MessageType<MessageTypeValue<Last<T>>>\n{\n  private $messages: T;\n  private $latest: MessageTypeValue<Last<T>> | undefined;\n\n  public constructor(...messages: T) {\n    this.$messages = messages;\n  }\n\n  public to(transport: TransportType<MessageTypeValue<Last<T>>>) {\n    this.handleMessage(0, transport);\n    return this;\n  }\n\n  private handleMessage = (index: number, transport: TransportType) => {\n    const message = this.$messages[index] as Last<T>;\n    const next = this.$messages[index + 1] as Last<T> | undefined;\n    message.to(this.oneMessageTransport.child(transport, next, index));\n  };\n\n  private oneMessageTransport = TransportParent(function (\n    v: MessageTypeValue<Last<T>>,\n    child: ChainImpl<T>,\n    next: Last<T> | undefined,\n    index: number,\n  ) {\n    if (!next) {\n      child.$latest = v as MessageTypeValue<Last<T>>;\n    }\n    if (child.$latest) {\n      this.use(child.$latest);\n    }\n    if (next && !child.$latest) {\n      child.handleMessage(index + 1, this);\n    }\n  }, this);\n}\n","import { Transport, TransportExecutor } from \"base/Transport\";\nimport { ensureMessage } from \"helpers/ensures\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\ntype ExecutorApplier<T> = (\n  executor: TransportExecutor<T>,\n) => TransportExecutor<T>;\n\n/**\n * Applies a value transfer function to the transport\n * and returns the same value transfer function for the transport\n * Useful for applying functions like debounced or throttle\n */\nexport function ExecutorApplied<T>(\n  $base: MessageType<T>,\n  applier: ExecutorApplier<T>,\n) {\n  return new ExecutorAppliedImpl<T>($base, applier);\n}\n\nexport class ExecutorAppliedImpl<T> implements MessageType<T> {\n  public constructor(\n    private $base: MessageType<T>,\n    private applier: ExecutorApplier<T>,\n  ) {\n    ensureMessage($base, \"ExecutorApplied: base\");\n  }\n\n  public to(transport: TransportType<T>) {\n    const ExecutorAppliedBaseTransport = this.applier(\n      transport.use.bind(transport),\n    );\n    this.$base.to(Transport(ExecutorAppliedBaseTransport));\n    return this;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TransportParent } from \"base/Transport\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Filters values from the source message based on a predicate function,\n * optionally providing a default value when the predicate fails.\n */\nexport function Filtered<T>(\n  $base: MessageType<T>,\n  predicate: ConstructorType<[T], boolean>,\n  defaultValue?: T,\n): MessageType<T> {\n  return new FilteredImpl<T>($base, predicate, defaultValue);\n}\n\nexport class FilteredImpl<T> implements MessageType<T> {\n  public constructor(\n    private $base: MessageType<T>,\n    private predicate: ConstructorType<[T], boolean>,\n    private defaultValue?: T,\n  ) {}\n\n  public to(transport: TransportType<T>) {\n    this.$base.to(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T>(function (v, child: FilteredImpl<T>) {\n    if (child.predicate(v)) {\n      this.use(v);\n    } else if (child.defaultValue !== undefined) {\n      this.use(child.defaultValue);\n    }\n  }, this);\n}\n","import { TransportType } from \"types/TransportType\";\nimport { Transport, TransportParent } from \"base/Transport\";\nimport { MessageType } from \"types/MessageType\";\nimport { All } from \"components/All\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * A message derived from event with a different\n * method call interface, based on callbacks.\n * Allows attaching a custom handler to an existing event source\n * and presenting it as a silentium message\n */\nexport function FromEvent<T>(\n  $emitter: MessageType<any>,\n  $eventName: MessageType<string>,\n  $subscribeMethod: MessageType<string>,\n  $unsubscribeMethod?: MessageType<string>,\n) {\n  return new FromEventImpl<T>(\n    $emitter,\n    $eventName,\n    $subscribeMethod,\n    $unsubscribeMethod,\n  );\n}\n\nexport class FromEventImpl<T> implements MessageType<T>, DestroyableType {\n  private lastTransport: TransportType<T> | null = null;\n  private handler = (v: T) => {\n    if (this.lastTransport) {\n      this.lastTransport.use(v);\n    }\n  };\n\n  public constructor(\n    private $emitter: MessageType<any>,\n    private $eventName: MessageType<string>,\n    private $subscribeMethod: MessageType<string>,\n    private $unsubscribeMethod?: MessageType<string>,\n  ) {}\n\n  public to(transport: TransportType<T>): this {\n    All(this.$emitter, this.$eventName, this.$subscribeMethod).to(\n      this.parent.child(transport),\n    );\n    return this;\n  }\n\n  private parent = TransportParent<[any, string, string]>(function (\n    [emitter, eventName, subscribe],\n    child,\n  ) {\n    child.lastTransport = this;\n    if (!emitter?.[subscribe]) {\n      return;\n    }\n    emitter[subscribe](eventName, child.handler);\n  }, this);\n\n  public destroy(): this {\n    this.lastTransport = null;\n    if (!this.$unsubscribeMethod) {\n      return this;\n    }\n    All(this.$emitter, this.$eventName, this.$unsubscribeMethod).to(\n      Transport(([emitter, eventName, unsubscribe]) => {\n        emitter?.[unsubscribe]?.(eventName, this.handler);\n      }),\n    );\n    return this;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates an message from a Promise, allowing the promise's resolution or rejection\n * to be handled as an message. The resolved value is emitted to the transport,\n * and if an error is provided, rejections are forwarded to it.\n */\nexport function FromPromise<T>(p: Promise<T>, error?: TransportType) {\n  return new FromPromiseImpl<T>(p, error);\n}\n\nexport class FromPromiseImpl<T> implements MessageType<T> {\n  public constructor(\n    private p: Promise<T>,\n    private error?: TransportType,\n  ) {}\n\n  public to(transport: TransportType<T>): this {\n    this.p\n      .then((v) => {\n        transport.use(v);\n      })\n      .catch((e) => {\n        this.error?.use(e);\n      });\n    return this;\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { isFilled } from \"helpers/guards\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * A component that allows creating linked objects of information and its owner\n * in such a way that if a new value is assigned to the owner, this value\n * will become the value of the linked information source\n * https://silentium-lab.github.io/silentium/#/en/information/of\n */\nexport function Late<T>(v?: T) {\n  return new LateImpl<T>(v);\n}\n\nexport class LateImpl<T> implements SourceType<T> {\n  private lateTransport: TransportType<T> | null = null;\n  private notify = (v?: T) => {\n    if (isFilled(v) && this.lateTransport) {\n      this.lateTransport.use(v);\n    }\n  };\n\n  public constructor(private v?: T) {}\n\n  public to(transport: TransportType<T>): this {\n    if (this.lateTransport) {\n      throw new Error(\n        \"Late component gets new transport, when another was already connected!\",\n      );\n    }\n    this.lateTransport = transport;\n    this.notify(this.v);\n    return this;\n  }\n\n  public use(value: T): this {\n    this.notify(value);\n    return this;\n  }\n}\n","import { TransportParent } from \"base/Transport\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Limits the number of values from the information source\n * to a single value - once the first value is emitted, no more\n * values are delivered from the source\n */\nexport function Once<T>($base: MessageType<T>) {\n  return new OnceImpl<T>($base);\n}\n\nexport class OnceImpl<T> implements MessageType<T> {\n  private isFilled = false;\n\n  public constructor(private $base: MessageType<T>) {}\n\n  public to(transport: TransportType<T>): this {\n    this.$base.to(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T>(function (v, child) {\n    if (!child.isFilled) {\n      child.isFilled = true;\n      this.use(v);\n    }\n  }, this);\n}\n","import { TransportType } from \"types/TransportType\";\nimport { Transport } from \"base/Transport\";\nimport { isDestroyed } from \"helpers/guards\";\n\n/**\n * Helps maintain an owner list allowing different\n * owners to get information from a common source\n * https://silentium-lab.github.io/silentium/#/en/utils/owner-pool\n */\nexport class TransportPool<T> {\n  private transports: Set<TransportType<T>>;\n  private innerTransport: TransportType<T>;\n\n  public constructor() {\n    this.transports = new Set<TransportType<T>>();\n    this.innerTransport = Transport((v) => {\n      this.transports.forEach((transport) => {\n        if (isDestroyed(transport) && transport.destroyed()) {\n          this.transports.delete(transport);\n          return;\n        }\n        transport.use(v);\n      });\n    });\n  }\n\n  public transport() {\n    return this.innerTransport;\n  }\n\n  public size(): number {\n    return this.transports.size;\n  }\n\n  public has(owner: TransportType<T>): boolean {\n    return this.transports.has(owner);\n  }\n\n  public add(owner: TransportType<T>) {\n    this.transports.add(owner);\n    return this;\n  }\n\n  public remove(g: TransportType<T>) {\n    this.transports.delete(g);\n    return this;\n  }\n\n  public destroy() {\n    this.transports.forEach((g) => {\n      this.remove(g);\n    });\n    return this;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { Late } from \"components/Late\";\nimport { Once } from \"components/Once\";\nimport { SourceType } from \"types/SourceType\";\nimport { TransportPool } from \"helpers/TransportPool\";\nimport { TransportType } from \"types/TransportType\";\nimport { isFilled } from \"helpers/guards\";\nimport { Transport } from \"base/Transport\";\n\n/**\n * An information object that helps multiple owners access\n * a single another information object\n */\nexport function Shared<T>($base: MessageType<T>, stateless = false) {\n  return new SharedImpl<T>($base, stateless);\n}\n\nexport class SharedImpl<T> implements SourceType<T> {\n  private transportPool = new TransportPool<T>();\n  private lastValue: T | undefined;\n  private calls = Late();\n\n  public constructor(\n    private $base: MessageType<T>,\n    private stateless = false,\n  ) {\n    Once(this.calls).to(\n      Transport(() => {\n        this.$base.to(this.firstCallTransport);\n      }),\n    );\n  }\n\n  public to(transport: TransportType<T>) {\n    this.calls.use(1);\n    if (\n      !this.stateless &&\n      isFilled(this.lastValue) &&\n      !this.transportPool.has(transport)\n    ) {\n      transport.use(this.lastValue);\n    }\n    this.transportPool.add(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.calls.use(1);\n    this.lastValue = value;\n    this.transportPool.transport().use(value);\n    return this;\n  }\n\n  private firstCallTransport = Transport<T>((v: T) => {\n    this.lastValue = v;\n    this.transportPool.transport().use(v);\n  });\n\n  public touched() {\n    this.calls.use(1);\n  }\n\n  public pool() {\n    return this.transportPool;\n  }\n\n  public destroy() {\n    return this.transportPool.destroy();\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { Shared } from \"components/Shared\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a shared source that allows multiple transports to subscribe to the same underlying source.\n * The stateless parameter controls whether the sharing maintains state or not.\n */\nexport function SharedSource<T>($base: SourceType<T>, stateless = false) {\n  return new SharedSourceImpl<T>($base, stateless);\n}\n\nexport class SharedSourceImpl<T> implements SourceType<T> {\n  private $sharedBase: SourceType<T> & { touched: () => void };\n\n  public constructor(\n    private $base: SourceType<T>,\n    stateless = false,\n  ) {\n    this.$sharedBase = Shared(this.$base, stateless);\n  }\n\n  public to(transport: TransportType<T>) {\n    this.$sharedBase.to(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.$sharedBase.touched();\n    this.$base.use(value);\n    return this;\n  }\n}\n","import { Transport } from \"base/Transport\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Helps represent an message as a primitive type, which can be useful\n * for cases when you need to always have a reference to the current value\n * without updating the shared value when the current one changes.\n * For example, this could be used when passing an authorization token.\n * It can also be useful for testing or logging purposes.\n */\nexport function Primitive<T>($base: MessageType<T>, theValue: T | null = null) {\n  return new PrimitiveImpl<T>($base, theValue);\n}\n\nexport class PrimitiveImpl<T> {\n  private touched = false;\n\n  public constructor(\n    private $base: MessageType<T>,\n    private theValue: T | null = null,\n  ) {}\n\n  private ensureTouched() {\n    if (!this.touched) {\n      this.$base.to(\n        Transport((v) => {\n          this.theValue = v;\n        }),\n      );\n    }\n    this.touched = true;\n  }\n\n  public [Symbol.toPrimitive]() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitive() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitiveWithException() {\n    this.ensureTouched();\n    if (this.theValue === null) {\n      throw new Error(\"Primitive value is null\");\n    }\n    return this.theValue;\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { Late } from \"components/Late\";\nimport { SharedSource } from \"components/SharedSource\";\nimport { TransportType } from \"types/TransportType\";\nimport { Primitive, PrimitiveImpl } from \"components/Primitive\";\n\n/**\n * An message with a value that will be set later,\n * capable of responding to different transports\n */\nexport function LateShared<T>(value?: T) {\n  return new LateSharedImpl<T>(value);\n}\n\nexport class LateSharedImpl<T> implements SourceType<T> {\n  private $msg: SourceType<T>;\n  private primitive: PrimitiveImpl<T>;\n\n  public constructor(value?: T) {\n    this.$msg = SharedSource(Late(value));\n    this.primitive = Primitive(this, value);\n  }\n\n  public to(transport: TransportType<T>) {\n    this.$msg.to(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.$msg.use(value);\n    return this;\n  }\n\n  public value() {\n    return this.primitive;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { All } from \"components/All\";\nimport { TransportType } from \"types/TransportType\";\nimport { isMessage } from \"helpers/guards\";\nimport { TransportParent } from \"base/Transport\";\nimport { Of } from \"base/Of\";\n\n/**\n * Component that applies an info object constructor to each data item,\n * producing an information source with new values\n */\nexport function Map<T, TG>(\n  $base: MessageType<T[]>,\n  $target: TransportType<any, MessageType<TG>>,\n) {\n  return new MapImpl<T, TG>($base, $target);\n}\n\nexport class MapImpl<T, TG> implements MessageType<TG[]> {\n  public constructor(\n    private $base: MessageType<T[]>,\n    private $target: TransportType<any, MessageType<TG>>,\n  ) {}\n\n  public to(transport: TransportType<TG[]>): this {\n    this.$base.to(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T[]>(function (v, child) {\n    const infos: MessageType<TG>[] = [];\n    v.forEach((val) => {\n      let $val: MessageType<T> | T = val;\n      if (!isMessage($val as object)) {\n        $val = Of($val);\n      }\n      const info = child.$target.use($val);\n      infos.push(info);\n    });\n    All(...infos).to(this);\n  }, this);\n}\n","import { Transport } from \"base/Transport\";\nimport { LateShared } from \"components/LateShared\";\nimport { MessageType } from \"types/MessageType\";\nimport { RPCType } from \"types/RPCType\";\nimport { TransportType } from \"types/TransportType\";\n\ninterface RPCImplType<T> {\n  result(): MessageType<T>;\n  error(): MessageType<Error | string>;\n}\n\n/**\n * The ability to call an external system through\n * sending a message in a standardized format\n * RPCType, the list of transports should be defined via\n * the RPC.transport object\n */\nexport function RPC<T>($rpc: MessageType<RPCType>): RPCImplType<T> {\n  return new RPCImpl($rpc);\n}\n\nRPC.transport = {} as { default: TransportType<RPCType> } & Record<\n  string,\n  TransportType<RPCType>\n>;\n\nexport class RPCImpl {\n  private $result = LateShared();\n  private $error = LateShared();\n\n  public constructor(private $rpc: MessageType<RPCType>) {}\n\n  public result() {\n    this.$rpc.to(\n      Transport((rpc) => {\n        const transport =\n          rpc.transport === undefined\n            ? RPC.transport.default\n            : RPC.transport[rpc.transport] || RPC.transport.default;\n        if (!transport) {\n          throw new Error(`RPCImpl: Transport not found ${rpc.transport}`);\n        }\n        if (!rpc.result) {\n          rpc.result = this.$result;\n        }\n        if (!rpc.error) {\n          rpc.error = this.$error;\n        }\n        transport.use(rpc);\n      }),\n    );\n    return this.$result;\n  }\n\n  public error() {\n    return this.$error;\n  }\n}\n","import { Transport } from \"base/Transport\";\nimport { MessageType } from \"types/MessageType\";\nimport { RPCType } from \"types/RPCType\";\n\n/**\n * Connects an external message to an RPC message chain\n */\nexport function RPCChain($base: MessageType) {\n  return Transport<RPCType>((rpc) => {\n    if (!rpc.result) {\n      throw new Error(\"RPCChain did not find result in rpc message\");\n    }\n    $base.to(rpc.result);\n  });\n}\n","import { Message } from \"base/Message\";\nimport { LateShared } from \"components/LateShared\";\nimport { RPC } from \"components/RPC\";\nimport { RPCType } from \"types/RPCType\";\n\n/**\n * Message for the arrival of a specific RPC message\n * for specific transport\n */\nexport function RPCOf(transport: string) {\n  const $transport = LateShared<RPCType>();\n  RPC.transport[transport] = $transport;\n  return Message<RPCType>((transport) => {\n    $transport.to(transport);\n  });\n}\n","import { TransportParent } from \"base/Transport\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a sequence that accumulates all values from the source into an array,\n * emitting the growing array with each new value.\n */\nexport function Sequence<T>($base: MessageType<T>) {\n  return new SequenceImpl<T>($base);\n}\n\nexport class SequenceImpl<T> implements MessageType<T[]> {\n  private result: T[] = [];\n\n  public constructor(private $base: MessageType<T>) {}\n\n  public to(transport: TransportType<T[]>): this {\n    this.$base.to(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T>(function (v, child) {\n    child.result.push(v);\n    this.use(child.result);\n  }, this);\n}\n","import { TransportParent } from \"base/Transport\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Component that receives a data array and yields values one by one\n */\nexport function Stream<T>($base: MessageType<T[]>) {\n  return new StreamImpl<T>($base);\n}\n\nexport class StreamImpl<T> implements MessageType<T> {\n  public constructor(private $base: MessageType<T[]>) {}\n\n  public to(transport: TransportType<T>): this {\n    this.$base.to(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T[]>(function (v) {\n    v.forEach((cv) => {\n      this.use(cv);\n    });\n  });\n}\n","import { ConstructorType } from \"types/ConstructorType\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a transport that applies a constructor to the result of another transport.\n */\nexport function TransportApplied<T>(\n  baseTransport: TransportType<any, MessageType<T>>,\n  applier: ConstructorType<[MessageType], MessageType<T>>,\n) {\n  return new TransportAppliedImpl(baseTransport, applier);\n}\n\nexport class TransportAppliedImpl<T>\n  implements TransportType<unknown, MessageType<T>>\n{\n  public constructor(\n    private baseTransport: TransportType<any, MessageType<T>>,\n    private applier: ConstructorType<[MessageType], MessageType<T>>,\n  ) {}\n\n  public use(args: unknown) {\n    return this.applier(this.baseTransport.use(args));\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a transport that merges additional arguments into the base transport's arguments\n * at a specified index position, allowing for flexible argument composition\n */\nexport function TransportArgs(\n  baseTransport: TransportType<any[], MessageType>,\n  args: unknown[],\n  startFromArgIndex: number = 0,\n) {\n  return new TransportArgsImpl(baseTransport, args, startFromArgIndex);\n}\n\nexport class TransportArgsImpl\n  implements TransportType<unknown[], MessageType<unknown>>\n{\n  public constructor(\n    private baseTransport: TransportType<any[], MessageType>,\n    private args: unknown[],\n    private startFromArgIndex: number = 0,\n  ) {}\n\n  public use(runArgs: unknown[]): MessageType<unknown> {\n    return this.baseTransport.use(\n      mergeAtIndex(runArgs, this.args, this.startFromArgIndex),\n    );\n  }\n}\n\nfunction mergeAtIndex(arr1: unknown[], arr2: unknown[], index: number) {\n  const result = arr1.slice(0, index);\n  while (result.length < index) result.push(undefined);\n  return result.concat(arr2);\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a transport wrapper that automatically manages destruction of created instances\n */\nexport function TransportDestroyable<T>(\n  baseTransport: TransportType<any[], MessageType<T>>,\n) {\n  return new TransportDestroyableImpl<T>(baseTransport);\n}\n\nexport class TransportDestroyableImpl<T>\n  implements TransportType<unknown, MessageType<T>>, DestroyableType\n{\n  private destructors: DestroyableType[] = [];\n\n  public constructor(\n    private baseTransport: TransportType<any[], MessageType<T>>,\n  ) {}\n\n  public use(args: any[]) {\n    const inst = this.baseTransport.use(args);\n    if (isDestroyable(inst)) {\n      this.destructors.push(inst);\n    }\n    return inst;\n  }\n\n  public destroy(): this {\n    this.destructors.forEach((i) => i.destroy());\n    return this;\n  }\n}\n"],"names":["isFilled","value","isMessage","o","to","isDestroyable","destroy","isDestroyed","isTransport","use","Destroyable","base","DestroyableImpl","constructor","this","DestroyContainer","DestroyContainerImpl","__publicField","add","e","destructors","push","forEach","d","length","ensureFunction","v","label","Error","ensureMessage","ensureTransport","Message","executor","MessageImpl","transport","mbDestructor","Transport","transportExecutor","TransportImpl","TransportMessage","TransportMessageImpl","TransportParent","args","TransportParentImpl","_child","call","child","Local","$base","LocalImpl","destroyed","New","construct","Of","OfImpl","TransportOptional","TransportOptionalImpl","wait","m","Void","VoidImpl","All","messages","AllImpl","Set","key","keysFilled","keysKnown","filled","result","parseInt","known","size","Object","keys","$messages","entries","message","Any","AnyImpl","Applied","applier","AppliedImpl","AppliedDestructured","Catch","errorMessage","errorOriginal","CatchImpl","String","Chain","ChainImpl","index","next","oneMessageTransport","$latest","handleMessage","ExecutorApplied","ExecutorAppliedImpl","ExecutorAppliedBaseTransport","bind","Filtered","predicate","defaultValue","FilteredImpl","parent","FromEvent","$emitter","$eventName","$subscribeMethod","$unsubscribeMethod","FromEventImpl","lastTransport","emitter","eventName","subscribe","handler","unsubscribe","FromPromise","p","error","FromPromiseImpl","then","catch","Late","LateImpl","lateTransport","notify","Once","OnceImpl","TransportPool","transports","innerTransport","delete","has","owner","remove","g","Shared","stateless","SharedImpl","lastValue","transportPool","calls","firstCallTransport","touched","pool","SharedSource","SharedSourceImpl","$sharedBase","Primitive","theValue","PrimitiveImpl","ensureTouched","Symbol","toPrimitive","primitive","primitiveWithException","LateShared","LateSharedImpl","$msg","Map","$target","MapImpl","infos","val","$val","info","RPC","$rpc","RPCImpl","rpc","default","$result","$error","RPCChain","RPCOf","$transport","Sequence","SequenceImpl","Stream","StreamImpl","cv","TransportApplied","baseTransport","TransportAppliedImpl","TransportArgs","startFromArgIndex","TransportArgsImpl","runArgs","arr1","arr2","slice","concat","mergeAtIndex","TransportDestroyable","TransportDestroyableImpl","inst","i"],"mappings":"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"}