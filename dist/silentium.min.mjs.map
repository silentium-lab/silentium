{"version":3,"file":"silentium.min.mjs","sources":["../src/helpers/guards.ts","../src/helpers/ensures.ts","../src/base/Component.ts","../src/base/DestroyContainer.ts","../src/base/Event.ts","../src/base/Local.ts","../src/base/Of.ts","../src/base/Void.ts","../src/helpers/OwnerPool.ts","../src/base/Transport.ts","../src/components/All.ts","../src/components/Any.ts","../src/components/Applied.ts","../src/components/Catch.ts","../src/components/Chain.ts","../src/components/ExecutorApplied.ts","../src/components/Filtered.ts","../src/components/FromEvent.ts","../src/components/FromPromise.ts","../src/components/Late.ts","../src/components/Once.ts","../src/components/Shared.ts","../src/components/SharedSource.ts","../src/components/LateShared.ts","../src/components/Map.ts","../src/components/Primitive.ts","../src/components/Sequence.ts","../src/components/Stream.ts","../src/components/TransportApplied.ts","../src/components/TransportArgs.ts","../src/components/TransportDestroyable.ts"],"sourcesContent":["import { DestroyableType, EventType, TransportType } from \"../types\";\n\nexport const isFilled = <T>(\n  value?: T,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\nexport function isEvent<T>(o: T): o is T & EventType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"event\" in o &&\n    typeof (o as any).event === \"function\"\n  );\n}\n\nexport function isDestroyable<T>(o: T): o is T & DestroyableType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroy\" in o &&\n    typeof (o as any).destroy === \"function\"\n  );\n}\n\nexport function isTransport<T>(o: T): o is T & TransportType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"use\" in o &&\n    typeof (o as any).use === \"function\"\n  );\n}\n","import { isEvent, isTransport } from \"../helpers/guards\";\n\nexport function ensureFunction(v: unknown, label: string) {\n  if (typeof v !== \"function\") {\n    throw new Error(`${label}: is not function`);\n  }\n}\n\nexport function ensureEvent(v: unknown, label: string) {\n  if (!isEvent(v)) {\n    throw new Error(`${label}: is not event`);\n  }\n}\n\nexport function ensureTransport(v: unknown, label: string) {\n  if (!isTransport(v)) {\n    throw new Error(`${label}: is not transport`);\n  }\n}\n","import { DestroyableType, EventType, TransportType } from \"../types\";\n\n/**\n * Create a function component that\n * will emit an event with specified arguments\n * and specified type\n */\nexport function Component<T, P extends Array<any>>(\n  executor: (this: TransportType<T>, ...args: P) => void | (() => void),\n): (...args: P) => EventType<T> & DestroyableType {\n  return (...args) => {\n    let destructor: void | (() => void);\n    return {\n      event(transport) {\n        destructor = executor.call(transport, ...args);\n        return this;\n      },\n      destroy() {\n        if (destructor !== undefined) {\n          destructor();\n        }\n        return this;\n      },\n    };\n  };\n}\n","import { DestroyableType } from \"../types\";\n\n/**\n * An object that allows collecting all disposable objects and\n * disposing them later all together\n */\nexport function DestroyContainer() {\n  return new TheDestroyContainer();\n}\n\nclass TheDestroyContainer implements DestroyableType {\n  private destructors: DestroyableType[] = [];\n\n  public add(e: DestroyableType) {\n    this.destructors.push(e);\n    return this;\n  }\n\n  public destroy() {\n    this.destructors.forEach((d) => d.destroy());\n    return this;\n  }\n}\n","import { ensureFunction } from \"../helpers\";\nimport { DestroyableType, EventType, TransportType } from \"../types\";\n\ntype EventExecutor<T> = (transport: TransportType<T>) => void | (() => void);\n\n/**\n * An event created from an executor function.\n * The executor function can return an event destruction function.\n */\nexport function Event<T>(eventExecutor: EventExecutor<T>) {\n  return new TheEvent<T>(eventExecutor);\n}\n\nclass TheEvent<T> implements EventType<T>, DestroyableType {\n  private mbDestructor: unknown;\n\n  public constructor(private eventExecutor: EventExecutor<T>) {\n    ensureFunction(eventExecutor, \"Event: eventExecutor\");\n  }\n\n  public event(transport: TransportType<T>) {\n    this.mbDestructor = this.eventExecutor(transport);\n    return this;\n  }\n\n  public destroy() {\n    if (typeof this.mbDestructor === \"function\") {\n      this.mbDestructor?.();\n    }\n    return this;\n  }\n}\n","import { ensureEvent } from \"../helpers\";\nimport { ParentTransport } from \"./Transport\";\nimport { DestroyableType, EventType, TransportType } from \"../types\";\n\n/**\n * Create local copy of source what can be destroyed\n */\nexport function Local<T>($base: EventType<T>) {\n  return new TheLocal<T>($base);\n}\n\nclass TheLocal<T> implements EventType<T>, DestroyableType {\n  private destroyed = false;\n\n  public constructor(private $base: EventType<T>) {\n    ensureEvent($base, \"Local: $base\");\n  }\n\n  public event(transport: TransportType<T>): this {\n    this.$base.event(this.transport.child(transport));\n    return this;\n  }\n\n  private transport = new ParentTransport((v: T, child: TransportType<T>) => {\n    if (!this.destroyed) {\n      child.use(v);\n    }\n  });\n\n  public destroy(): this {\n    return this;\n  }\n}\n","import { EventType, TransportType } from \"../types\";\n\n/**\n * Helps convert a value into an event\n */\nexport function Of<T>(value: T) {\n  return new TheOf<T>(value);\n}\n\nclass TheOf<T> implements EventType<T> {\n  public constructor(private value: T) {}\n\n  public event(transport: TransportType<T>): this {\n    transport.use(this.value);\n    return this;\n  }\n}\n","import { TransportType } from \"../types\";\n\n/**\n * Transport that does nothing with the passed value,\n * needed for silent event triggering\n */\nexport function Void() {\n  return new TheVoid();\n}\n\nclass TheVoid implements TransportType {\n  public use(): this {\n    return this;\n  }\n}\n","import { Transport } from \"../base\";\nimport { TransportType } from \"../types\";\n\n/**\n * Helps maintain an owner list allowing different\n * owners to get information from a common source\n * https://silentium-lab.github.io/silentium/#/en/utils/owner-pool\n */\nexport class OwnerPool<T> {\n  private owners: Set<TransportType<T>>;\n  private innerOwner: TransportType<T>;\n\n  public constructor() {\n    this.owners = new Set<TransportType<T>>();\n    this.innerOwner = Transport((v) => {\n      this.owners.forEach((g) => {\n        g.use(v);\n      });\n    });\n  }\n\n  public owner() {\n    return this.innerOwner;\n  }\n\n  public size(): number {\n    return this.owners.size;\n  }\n\n  public has(owner: TransportType<T>): boolean {\n    return this.owners.has(owner);\n  }\n\n  public add(owner: TransportType<T>) {\n    this.owners.add(owner);\n    return this;\n  }\n\n  public remove(g: TransportType<T>) {\n    this.owners.delete(g);\n    return this;\n  }\n\n  public destroy() {\n    this.owners.forEach((g) => {\n      this.remove(g);\n    });\n    return this;\n  }\n}\n","import { ensureFunction } from \"../helpers\";\nimport { EventType, TransportType } from \"../types\";\n\n/**\n * Type of value transfer logic executor\n */\nexport type TransportExecutor<T> = (v: T) => void;\n\n/**\n * Base transport that accepts the passed value,\n * acts as a conductor to deliver the value from an event to somewhere\n */\nexport function Transport<T>(transportExecutor: TransportExecutor<T>) {\n  return new TheTransport<T>(transportExecutor);\n}\n\nclass TheTransport<T> implements TransportType<T> {\n  public constructor(private transportExecutor: TransportExecutor<T>) {\n    ensureFunction(transportExecutor, \"Transport: transport executor\");\n  }\n\n  public use(value: T) {\n    this.transportExecutor(value);\n    return this;\n  }\n}\n\n/**\n * Type of executor for value passing logic and event returning\n */\nexport type TransportEventExecutor<T, ET = T> = (v: T) => EventType<ET>;\n\n/**\n * A transport that delivers a value from one event\n * and returns another event based on the value\n */\nexport function TransportEvent<T, ET = any>(\n  transportExecutor: TransportEventExecutor<T, ET>,\n) {\n  return new TheTransportEvent<T, ET>(transportExecutor);\n}\n\nclass TheTransportEvent<T, ET = T> implements TransportType<T, EventType<ET>> {\n  public constructor(private executor: TransportEventExecutor<T, ET>) {\n    ensureFunction(executor, \"TheTransportEvent: transport executor\");\n  }\n\n  public use(value: T) {\n    return this.executor(value);\n  }\n}\n\n/**\n * A transport that accepts a child transport\n * to perform some transformation on the value\n * during its transmission\n */\nexport class ParentTransport<T> implements TransportType<T> {\n  public constructor(\n    private executor: (v: T, transport: TransportType, ...args: any[]) => void,\n    private args: any[] = [],\n    private _child?: TransportType<T>,\n  ) {\n    ensureFunction(executor, \"ParentTransport: executor\");\n  }\n\n  public use(value: T): this {\n    if (this._child === undefined) {\n      throw new Error(\"no base transport\");\n    }\n    this.executor(value, this._child, ...this.args);\n    return this;\n  }\n\n  public child(transport: TransportType, ...args: any[]) {\n    return new ParentTransport(\n      this.executor,\n      [...this.args, ...args],\n      transport,\n    );\n  }\n}\n","import { ParentTransport } from \"../base/Transport\";\nimport { ensureEvent } from \"../helpers\";\nimport { EventType, TransportType } from \"../types\";\n\ntype ExtractTypeS<T> = T extends EventType<infer U> ? U : never;\n\ntype ExtractTypesFromArrayS<T extends EventType<any>[]> = {\n  [K in keyof T]: ExtractTypeS<T[K]>;\n};\n\nconst isAllFilled = (keysFilled: Set<string>, keysKnown: Set<string>) => {\n  return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n};\n\n/**\n * An event that represents values from\n * all provided events as an array.\n * When all events emit their values,\n * the combined value will be returned.\n * If at least one event later emits a new\n * value, the updated array with the new value\n * will be emitted by All.\n */\nexport function All<const T extends EventType[]>(...events: T) {\n  return new TheAll<T>(...events);\n}\n\nclass TheAll<const T extends EventType[]>\n  implements EventType<ExtractTypesFromArrayS<T>>\n{\n  private keysKnown: Set<string>;\n  private keysFilled = new Set<string>();\n  private $events: T;\n  private result: Record<string, unknown> = {};\n\n  public constructor(...events: T) {\n    this.keysKnown = new Set<string>(Object.keys(events));\n    this.$events = events;\n  }\n\n  public event(transport: TransportType<ExtractTypesFromArrayS<T>>): this {\n    Object.entries(this.$events).forEach(([key, event]) => {\n      ensureEvent(event, \"All: item\");\n      this.keysKnown.add(key);\n      event.event(this.transport.child(transport, key));\n    });\n    return this;\n  }\n\n  private transport = new ParentTransport(\n    (v: T, child: TransportType, key: string) => {\n      this.keysFilled.add(key);\n      this.result[key] = v;\n      if (isAllFilled(this.keysFilled, this.keysKnown)) {\n        child.use(Object.values(this.result) as ExtractTypesFromArrayS<T>);\n      }\n    },\n  );\n}\n","import { ensureEvent } from \"../helpers\";\nimport { EventType, TransportType } from \"../types\";\n\n/**\n * An event that emits values received from\n * any of its bound events\n */\nexport function Any<T>(...events: EventType<T>[]) {\n  return new TheAny(...events);\n}\n\nclass TheAny<T> implements EventType<T> {\n  private $events: EventType[];\n\n  public constructor(...events: EventType<T>[]) {\n    this.$events = events;\n  }\n\n  public event(transport: TransportType<T>): this {\n    this.$events.forEach((event) => {\n      ensureEvent(event, \"Any: item\");\n      event.event(transport);\n    });\n    return this;\n  }\n}\n","import { ensureEvent } from \"../helpers\";\nimport { ParentTransport } from \"../base/Transport\";\nimport { ConstructorType, EventType, TransportType } from \"../types\";\n\n/**\n * An event that applies a function\n * to the value of the base event\n */\nexport function Applied<T, R>(\n  $base: EventType<T>,\n  applier: ConstructorType<[T], R>,\n) {\n  return new TheApplied<T, R>($base, applier);\n}\n\nclass TheApplied<T, R> implements EventType<R> {\n  public constructor(\n    private $base: EventType<T>,\n    private applier: ConstructorType<[T], R>,\n  ) {\n    ensureEvent($base, \"Applied: base\");\n  }\n\n  public event(transport: TransportType<R>) {\n    this.$base.event(this.transport.child(transport));\n    return this;\n  }\n\n  private transport = new ParentTransport((v: T, child) => {\n    child.use(this.applier(v));\n  });\n}\n","import { ensureEvent, ensureTransport } from \"../helpers\";\nimport { EventType, TransportType } from \"../types\";\n\n/**\n * An event representing a base event where\n * its operation is wrapped in try-catch\n * and expects exceptions. If an exception\n * bubbles up, it's passed to the transports\n * as errorMessage and errorOriginal\n */\nexport function Catch<T>(\n  $base: EventType<T>,\n  errorMessage: TransportType,\n  errorOriginal?: TransportType,\n) {\n  return new TheCatch<T>($base, errorMessage, errorOriginal);\n}\n\nclass TheCatch<T> implements EventType<T> {\n  public constructor(\n    private $base: EventType<T>,\n    private errorMessage: TransportType,\n    private errorOriginal?: TransportType,\n  ) {\n    ensureEvent($base, \"Catch: base\");\n    ensureTransport(errorMessage, \"Catch: errorMessage\");\n    if (errorOriginal !== undefined) {\n      ensureTransport(errorOriginal, \"Catch: errorOriginal\");\n    }\n  }\n\n  public event(transport: TransportType<T>) {\n    try {\n      this.$base.event(transport);\n    } catch (e: any) {\n      if (e instanceof Error) {\n        this.errorMessage.use(e.message);\n      } else {\n        this.errorMessage.use(e);\n      }\n      if (this.errorOriginal) {\n        this.errorOriginal.use(e);\n      }\n    }\n    return this;\n  }\n}\n","import { EventTypeValue } from \"../types/EventType\";\nimport { EventType, TransportType } from \"../types\";\nimport { ParentTransport } from \"../base/Transport\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;\n\n/**\n * Chains events together and triggers\n * the last event only when all previous events\n * have emitted their values. The value of Chain will be the value\n * of the last event. If any events\n * emit a value again after the overall Chain response was already returned,\n * then Chain emits again with the value of the last event.\n */\nexport function Chain<T extends EventType[]>(...events: T) {\n  return new TheChain<T>(...events);\n}\n\nexport class TheChain<T extends EventType[]>\n  implements EventType<EventTypeValue<Last<T>>>\n{\n  private $events: T;\n  private lastValue: EventTypeValue<Last<T>> | undefined;\n\n  public constructor(...events: T) {\n    this.$events = events;\n  }\n\n  public event(transport: TransportType<EventTypeValue<Last<T>>>) {\n    this.handleEvent(0, transport);\n    return this;\n  }\n\n  private handleEvent = (index: number, transport: TransportType) => {\n    const event = this.$events[index] as Last<T>;\n    const nextI = this.$events[index + 1] as Last<T> | undefined;\n    event.event(this.oneEventTransport.child(transport, nextI, index));\n  };\n\n  private oneEventTransport = new ParentTransport(\n    (\n      v: EventTypeValue<Last<T>>,\n      child,\n      nextI: Last<T> | undefined,\n      index: number,\n    ) => {\n      if (!nextI) {\n        this.lastValue = v as EventTypeValue<Last<T>>;\n      }\n\n      if (this.lastValue) {\n        child.use(this.lastValue);\n      }\n\n      if (nextI && !this.lastValue) {\n        this.handleEvent(index + 1, child);\n      }\n    },\n  );\n}\n","import { Transport, TransportExecutor } from \"../base\";\nimport { ensureEvent } from \"../helpers\";\nimport { EventType, TransportType } from \"../types\";\n\ntype ExecutorApplier<T> = (\n  executor: TransportExecutor<T>,\n) => TransportExecutor<T>;\n\n/**\n * Applies a value transfer function to the transport\n * and returns the same value transfer function for the transport\n * Useful for applying functions like debounced or throttle\n */\nexport function ExecutorApplied<T>(\n  $base: EventType<T>,\n  applier: ExecutorApplier<T>,\n) {\n  return new TheExecutorApplied($base, applier);\n}\n\nclass TheExecutorApplied<T> implements EventType<T> {\n  public constructor(\n    private $base: EventType<T>,\n    private applier: ExecutorApplier<T>,\n  ) {\n    ensureEvent($base, \"ExecutorApplied: base\");\n  }\n\n  public event(transport: TransportType<T>) {\n    const ExecutorAppliedBaseTransport = this.applier(\n      transport.use.bind(transport),\n    );\n    this.$base.event(Transport(ExecutorAppliedBaseTransport));\n    return this;\n  }\n}\n","import { ParentTransport } from \"../base/Transport\";\nimport { EventType, ConstructorType, TransportType } from \"../types\";\n\nexport function Filtered<T>(\n  $base: EventType<T>,\n  predicate: ConstructorType<[T], boolean>,\n  defaultValue?: T,\n) {\n  return new TheFiltered<T>($base, predicate, defaultValue);\n}\n\nclass TheFiltered<T> implements EventType<T> {\n  public constructor(\n    private $base: EventType<T>,\n    private predicate: ConstructorType<[T], boolean>,\n    private defaultValue?: T,\n  ) {}\n\n  public event(transport: TransportType<T>) {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = new ParentTransport<T>((v, child) => {\n    if (this.predicate(v)) {\n      child.use(v);\n    } else if (this.defaultValue !== undefined) {\n      child.use(this.defaultValue);\n    }\n  });\n}\n","import { ParentTransport, Transport } from \"../base/Transport\";\nimport { EventType, TransportType } from \"../types\";\nimport { DestroyableType } from \"../types/EventType\";\nimport { All } from \"./All\";\n\n/**\n * An event derived from another event with a different\n * method call interface, based on callbacks.\n * Allows attaching a custom handler to an existing event source\n * and presenting it as a silentium event\n */\nexport function FromEvent<T>(\n  $emitter: EventType<any>,\n  $eventName: EventType<string>,\n  $subscribeMethod: EventType<string>,\n  $unsubscribeMethod?: EventType<string>,\n) {\n  return new TheFromEvent<T>(\n    $emitter,\n    $eventName,\n    $subscribeMethod,\n    $unsubscribeMethod,\n  );\n}\n\nclass TheFromEvent<T> implements EventType<T>, DestroyableType {\n  private lastTransport: TransportType<T> | null = null;\n  private handler = (v: T) => {\n    if (this.lastTransport) {\n      this.lastTransport.use(v);\n    }\n  };\n\n  public constructor(\n    private $emitter: EventType<any>,\n    private $eventName: EventType<string>,\n    private $subscribeMethod: EventType<string>,\n    private $unsubscribeMethod?: EventType<string>,\n  ) {}\n\n  public event(transport: TransportType<T>): this {\n    const a = All(this.$emitter, this.$eventName, this.$subscribeMethod);\n    a.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = new ParentTransport<[any, string, string]>(\n    ([emitter, eventName, subscribe], parent) => {\n      this.lastTransport = parent;\n      if (!emitter?.[subscribe]) {\n        return;\n      }\n      emitter[subscribe](eventName, this.handler);\n    },\n  );\n\n  public destroy(): this {\n    this.lastTransport = null;\n    if (!this.$unsubscribeMethod) {\n      return this;\n    }\n    const a = All(this.$emitter, this.$eventName, this.$unsubscribeMethod);\n    a.event(\n      Transport(([emitter, eventName, unsubscribe]) => {\n        emitter?.[unsubscribe]?.(eventName, this.handler);\n      }),\n    );\n    return this;\n  }\n}\n","import { EventType, TransportType } from \"../types\";\n\n/**\n * Promise event\n */\nexport function FromPromise<T>(p: Promise<T>, errorOwner?: TransportType) {\n  return new TheFromPromise<T>(p, errorOwner);\n}\n\nexport class TheFromPromise<T> implements EventType<T> {\n  public constructor(\n    private p: Promise<T>,\n    private errorOwner?: TransportType,\n  ) {}\n\n  public event(transport: TransportType<T>): this {\n    this.p\n      .then(function FromPromiseThen(v) {\n        transport.use(v);\n      })\n      .catch((e) => {\n        this.errorOwner?.use(e);\n      });\n    return this;\n  }\n}\n","import { isFilled } from \"../helpers\";\nimport { TransportType, SourceType } from \"../types\";\n\n/**\n * A component that allows creating linked objects of information and its owner\n * in such a way that if a new value is assigned to the owner, this value\n * will become the value of the linked information source\n * https://silentium-lab.github.io/silentium/#/en/information/of\n */\nexport function Late<T>(v?: T) {\n  return new TheLate<T>(v);\n}\n\nclass TheLate<T> implements SourceType<T> {\n  private lateTransport: TransportType<T> | null = null;\n  private notify = (v?: T) => {\n    if (isFilled(v) && this.lateTransport) {\n      this.lateTransport.use(v);\n    }\n  };\n\n  public constructor(private v?: T) {}\n\n  public event(transport: TransportType<T>): this {\n    if (this.lateTransport) {\n      throw new Error(\n        \"Late component gets new transport, when another was already connected!\",\n      );\n    }\n    this.lateTransport = transport;\n    this.notify(this.v);\n    return this;\n  }\n\n  public use(value: T): this {\n    this.notify(value);\n    return this;\n  }\n}\n","import { ParentTransport } from \"../base\";\nimport { EventType, TransportType } from \"../types\";\n\n/**\n * Limits the number of values from the information source\n * to a single value - once the first value is emitted, no more\n * values are delivered from the source\n */\nexport function Once<T>($base: EventType<T>) {\n  return new TheOnce<T>($base);\n}\n\nclass TheOnce<T> implements EventType<T> {\n  private isFilled = false;\n\n  public constructor(private $base: EventType<T>) {}\n\n  public event(transport: TransportType<T>): this {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = new ParentTransport<T>((v, child) => {\n    if (!this.isFilled) {\n      this.isFilled = true;\n      child.use(v);\n    }\n  });\n}\n","import { Transport } from \"../base\";\nimport { Late } from \"../components/Late\";\nimport { Once } from \"../components/Once\";\nimport { isFilled, OwnerPool } from \"../helpers\";\nimport { EventType, TransportType, SourceType } from \"../types\";\n\n/**\n * An information object that helps multiple owners access\n * a single another information object\n */\nexport function Shared<T>($base: EventType<T>, stateless = false) {\n  return new TheShared<T>($base, stateless);\n}\n\nclass TheShared<T> implements SourceType<T> {\n  private ownersPool = new OwnerPool<T>();\n  private lastValue: T | undefined;\n  private calls = Late();\n\n  public constructor(\n    private $base: EventType<T>,\n    private stateless = false,\n  ) {\n    Once(this.calls).event(\n      Transport(() => {\n        this.$base.event(this.firstCallTransport);\n      }),\n    );\n  }\n\n  public event(transport: TransportType<T>) {\n    this.calls.use(1);\n    if (\n      !this.stateless &&\n      isFilled(this.lastValue) &&\n      !this.ownersPool.has(transport)\n    ) {\n      transport.use(this.lastValue);\n    }\n    this.ownersPool.add(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.calls.use(1);\n    this.lastValue = value;\n    this.ownersPool.owner().use(value);\n    return this;\n  }\n\n  private firstCallTransport = Transport<T>((v: T) => {\n    this.lastValue = v;\n    this.ownersPool.owner().use(v);\n  });\n\n  public touched() {\n    this.calls.use(1);\n  }\n\n  public pool() {\n    return this.ownersPool;\n  }\n\n  public destroy() {\n    return this.ownersPool.destroy();\n  }\n}\n","import { Shared } from \"../components/Shared\";\nimport { TransportType, SourceType } from \"../types\";\n\nexport function SharedSource<T>($base: SourceType<T>, stateless = false) {\n  return new TheSharedSource<T>($base, stateless);\n}\n\nclass TheSharedSource<T> implements SourceType<T> {\n  private $sharedBase: SourceType<T> & { touched: () => void };\n\n  public constructor(\n    private $base: SourceType<T>,\n    stateless = false,\n  ) {\n    this.$sharedBase = Shared(this.$base, stateless);\n  }\n\n  public event(transport: TransportType<T>) {\n    this.$sharedBase.event(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.$sharedBase.touched();\n    this.$base.use(value);\n    return this;\n  }\n}\n","import { Late } from \"../components/Late\";\nimport { SharedSource } from \"../components/SharedSource\";\nimport { TransportType, SourceType } from \"../types\";\n\n/**\n * An event with a value that will be set later,\n * capable of responding to different transports\n */\nexport function LateShared<T>(value?: T) {\n  return new TheLateShared<T>(value);\n}\n\nclass TheLateShared<T> implements SourceType<T> {\n  private $event: SourceType<T>;\n\n  public constructor(value?: T) {\n    this.$event = SharedSource(Late(value));\n  }\n\n  public event(transport: TransportType<T>) {\n    this.$event.event(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.$event.use(value);\n    return this;\n  }\n}\n","import { isEvent } from \"../helpers\";\nimport { Of, ParentTransport } from \"../base\";\nimport { EventType, TransportType } from \"../types\";\nimport { All } from \"./All\";\n\n/**\n * Component that applies an info object constructor to each data item,\n * producing an information source with new values\n */\nexport function Map<T, TG>(\n  $base: EventType<T[]>,\n  $target: TransportType<any, EventType<TG>>,\n) {\n  return new TheMap<T, TG>($base, $target);\n}\n\nclass TheMap<T, TG> implements EventType<TG[]> {\n  public constructor(\n    private $base: EventType<T[]>,\n    private $target: TransportType<any, EventType<TG>>,\n  ) {}\n\n  public event(transport: TransportType<TG[]>): this {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = new ParentTransport<T[]>((v, child) => {\n    const infos: EventType<TG>[] = [];\n    v.forEach((val) => {\n      let valInfo: EventType<T> | T = val;\n      if (!isEvent(valInfo as object)) {\n        valInfo = Of(valInfo);\n      }\n      const info = this.$target.use(valInfo);\n      infos.push(info);\n    });\n    const allI = All(...infos);\n    allI.event(child);\n  });\n}\n","import { Transport } from \"../base\";\nimport { EventType } from \"../types\";\n\n/**\n * Helps represent an event as a primitive type, which can be useful\n * for cases when you need to always have a reference to the current value\n * without updating the shared value when the current one changes.\n * For example, this could be used when passing an authorization token.\n * It can also be useful for testing or logging purposes.\n */\nexport function Primitive<T>($base: EventType<T>, theValue: T | null = null) {\n  return new ThePrimitive<T>($base, theValue);\n}\n\nclass ThePrimitive<T> {\n  private touched = false;\n\n  public constructor(\n    private $base: EventType<T>,\n    private theValue: T | null = null,\n  ) {}\n\n  private ensureTouched() {\n    if (!this.touched) {\n      this.$base.event(\n        Transport((v) => {\n          this.theValue = v;\n        }),\n      );\n    }\n    this.touched = true;\n  }\n\n  public [Symbol.toPrimitive]() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitive() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitiveWithException() {\n    this.ensureTouched();\n    if (this.theValue === null) {\n      throw new Error(\"Primitive value is null\");\n    }\n    return this.theValue;\n  }\n}\n","import { ParentTransport } from \"../base\";\nimport { EventType, TransportType } from \"../types\";\n\nexport function Sequence<T>($base: EventType<T>) {\n  return new TheSequence<T>($base);\n}\n\n/**\n * A component that takes one value at a time and returns\n * an array of all previous values\n */\nclass TheSequence<T> implements EventType<T[]> {\n  private result: T[] = [];\n\n  public constructor(private $base: EventType<T>) {}\n\n  public event(transport: TransportType<T[]>): this {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = new ParentTransport<T>((v, child) => {\n    this.result.push(v);\n    child.use(this.result);\n  });\n}\n","import { ParentTransport } from \"../base\";\nimport { EventType, TransportType } from \"../types\";\n\n/**\n * Component that receives a data array and yields values one by one\n */\nexport function Stream<T>($base: EventType<T[]>) {\n  return new TheStream<T>($base);\n}\n\nclass TheStream<T> implements EventType<T> {\n  public constructor(private $base: EventType<T[]>) {}\n\n  public event(transport: TransportType<T>): this {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = new ParentTransport<T[]>((v, child) => {\n    v.forEach((cv) => {\n      child.use(cv);\n    });\n  });\n}\n","import { EventType, ConstructorType, TransportType } from \"../types\";\n\nexport function TransportApplied<T>(\n  baseTransport: TransportType<any, EventType<T>>,\n  applier: ConstructorType<[EventType], EventType<T>>,\n) {\n  return new TheTransportApplied(baseTransport, applier);\n}\n\nexport class TheTransportApplied<T>\n  implements TransportType<unknown[], EventType<T>>\n{\n  public constructor(\n    private baseTransport: TransportType<any, EventType<T>>,\n    private applier: ConstructorType<[EventType], EventType<T>>,\n  ) {}\n\n  public use(args: unknown) {\n    return this.applier(this.baseTransport.use(args));\n  }\n}\n","import { EventType, TransportType } from \"../types\";\n\nexport function TransportArgs(\n  baseTransport: TransportType<any[], EventType>,\n  args: unknown[],\n  startFromArgIndex: number = 0,\n) {\n  return new TheTransportArgs(baseTransport, args, startFromArgIndex);\n}\n\nexport class TheTransportArgs\n  implements TransportType<unknown[], EventType<unknown>>\n{\n  public constructor(\n    private baseTransport: TransportType<any[], EventType>,\n    private args: unknown[],\n    private startFromArgIndex: number = 0,\n  ) {}\n\n  public use(runArgs: unknown[]): EventType<unknown> {\n    return this.baseTransport.use(\n      mergeAtIndex(runArgs, this.args, this.startFromArgIndex),\n    );\n  }\n}\n\nfunction mergeAtIndex(arr1: unknown[], arr2: unknown[], index: number) {\n  const result = arr1.slice(0, index);\n  while (result.length < index) result.push(undefined);\n  return result.concat(arr2);\n}\n","import { isDestroyable } from \"../helpers\";\nimport { DestroyableType, EventType, TransportType } from \"../types\";\n\nexport function TransportDestroyable<T>(\n  baseTransport: TransportType<any[], EventType<T>>,\n) {\n  return new TheTransportDestroyable<T>(baseTransport);\n}\n\n/**\n * Constructor what can be destroyed\n */\nclass TheTransportDestroyable<T>\n  implements TransportType<unknown[], EventType>, DestroyableType\n{\n  private destructors: DestroyableType[] = [];\n\n  public constructor(\n    private baseTransport: TransportType<any[], EventType<T>>,\n  ) {}\n\n  public use(args: unknown[]) {\n    const inst = this.baseTransport.use(args);\n    if (isDestroyable(inst)) {\n      this.destructors.push(inst);\n    }\n    return inst;\n  }\n\n  public destroy(): this {\n    this.destructors.forEach((i) => i.destroy());\n    return this;\n  }\n}\n"],"names":["isFilled","value","isEvent","o","event","isDestroyable","destroy","isTransport","use","ensureFunction","v","label","Error","ensureEvent","ensureTransport","Component","executor","args","destructor","transport","call","this","DestroyContainer","TheDestroyContainer","constructor","__publicField","add","e","destructors","push","forEach","d","Event","eventExecutor","TheEvent","mbDestructor","Local","$base","TheLocal","ParentTransport","child","destroyed","Of","TheOf","Void","TheVoid","OwnerPool","owners","Set","innerOwner","Transport","g","owner","size","has","remove","delete","transportExecutor","TheTransport","TransportEvent","TheTransportEvent","_child","All","events","TheAll","key","keysFilled","keysKnown","result","Object","values","keys","$events","entries","Any","TheAny","Applied","applier","TheApplied","Catch","errorMessage","errorOriginal","TheCatch","message","Chain","TheChain","index","nextI","oneEventTransport","lastValue","handleEvent","ExecutorApplied","TheExecutorApplied","ExecutorAppliedBaseTransport","bind","Filtered","predicate","defaultValue","TheFiltered","parent","FromEvent","$emitter","$eventName","$subscribeMethod","$unsubscribeMethod","TheFromEvent","lastTransport","emitter","eventName","subscribe","handler","unsubscribe","FromPromise","p","errorOwner","TheFromPromise","then","catch","Late","TheLate","lateTransport","notify","Once","TheOnce","Shared","stateless","TheShared","ownersPool","calls","firstCallTransport","touched","pool","SharedSource","TheSharedSource","$sharedBase","LateShared","TheLateShared","$event","Map","$target","TheMap","infos","val","valInfo","info","Primitive","theValue","ThePrimitive","ensureTouched","Symbol","toPrimitive","primitive","primitiveWithException","Sequence","TheSequence","Stream","TheStream","cv","TransportApplied","baseTransport","TheTransportApplied","TransportArgs","startFromArgIndex","TheTransportArgs","runArgs","arr1","arr2","slice","length","concat","mergeAtIndex","TransportDestroyable","TheTransportDestroyable","inst","i"],"mappings":"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"}