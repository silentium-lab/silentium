{"version":3,"file":"silentium.min.mjs","sources":["../src/base/Rejections.ts","../src/helpers/guards.ts","../src/helpers/ensures.ts","../src/base/Message.ts","../src/base/Of.ts","../src/base/ActualMessage.ts","../src/base/Destroyable.ts","../src/base/DestroyContainer.ts","../src/base/Local.ts","../src/base/New.ts","../src/base/Void.ts","../src/components/All.ts","../src/components/Any.ts","../src/components/Applied.ts","../src/components/AppliedDestructured.ts","../src/components/Late.ts","../src/components/Catch.ts","../src/components/Chain.ts","../src/components/ExecutorApplied.ts","../src/components/Filtered.ts","../src/components/FromEvent.ts","../src/components/Primitive.ts","../src/components/Shared.ts","../src/components/LateShared.ts","../src/components/Map.ts","../src/components/Once.ts","../src/components/Context.ts","../src/components/ContextChain.ts","../src/components/ContextOf.ts","../src/components/Sequence.ts","../src/components/Stream.ts"],"sourcesContent":["import { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * Handles rejections collection\n */\nexport class Rejections {\n  private catchers: ConstructorType<[unknown]>[] = [];\n  private lastRejectReason: unknown = null;\n\n  public reject = (reason: unknown) => {\n    this.lastRejectReason = reason;\n    this.catchers.forEach((catcher) => {\n      catcher(reason);\n    });\n  };\n\n  public catch(rejected: ConstructorType<[unknown]>) {\n    if (this.lastRejectReason !== null) {\n      rejected(this.lastRejectReason);\n    }\n    this.catchers.push(rejected);\n    return this;\n  }\n\n  public destroy() {\n    this.catchers.length = 0;\n    return this;\n  }\n}\n","import { DestroyableType, DestroyedType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Checks that the value is neither undefined nor null\n */\nexport const isFilled = <T>(\n  value?: T,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\n/**\n * Checks that the object is an message\n */\nexport function isMessage(o: unknown): o is MessageType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"then\" in o &&\n    typeof (o as any).then === \"function\"\n  );\n}\n\n/**\n * Checks that the object is destroyable\n */\nexport function isDestroyable(o: unknown): o is DestroyableType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroy\" in o &&\n    typeof (o as any).destroy === \"function\"\n  );\n}\n\n/**\n * Checks that the object can indicate whether it has been destroyed or not\n */\nexport function isDestroyed(o: unknown): o is DestroyedType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroyed\" in o &&\n    typeof (o as any).destroyed === \"function\"\n  );\n}\n","import { isMessage } from \"helpers/guards\";\n\nexport function ensureFunction(v: unknown, label: string) {\n  if (typeof v !== \"function\") {\n    throw new Error(`${label}: is not function`);\n  }\n}\n\nexport function ensureMessage(v: unknown, label: string) {\n  if (!isMessage(v)) {\n    throw new Error(`${label}: is not message`);\n  }\n}\n","import { Rejections } from \"base/Rejections\";\nimport { ensureFunction } from \"helpers/ensures\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\n\ntype MessageExecutorType<T> = (\n  resolve: ConstructorType<[T]>,\n  reject: ConstructorType<[unknown]>,\n) => unknown | (() => void);\n\n/**\n * A message created from an executor function.\n * The executor function can return a message destruction function.\n */\nexport function Message<T>(executor: MessageExecutorType<T>) {\n  return new MessageRx<T>(executor);\n}\n\n/**\n * Reactive message implementation\n */\nexport class MessageRx<T> implements MessageType<T>, DestroyableType {\n  private mbDestructor: unknown;\n  private rejections = new Rejections();\n\n  public constructor(private executor: MessageExecutorType<T>) {\n    ensureFunction(executor, \"Message: executor\");\n  }\n\n  public then(resolve: ConstructorType<[T]>) {\n    try {\n      this.mbDestructor = this.executor(resolve, this.rejections.reject);\n    } catch (e: any) {\n      this.rejections.reject(e);\n    }\n    return this;\n  }\n\n  public catch(rejected: ConstructorType<[unknown]>) {\n    this.rejections.catch(rejected);\n    return this;\n  }\n\n  public destroy() {\n    if (typeof this.mbDestructor === \"function\") {\n      this.mbDestructor?.();\n    }\n    this.rejections.destroy();\n    return this;\n  }\n}\n","import { Message } from \"base/Message\";\n\n/**\n * Helps convert a value into a message\n */\nexport function Of<T>(value: T) {\n  return Message<T>(function OfImpl(r) {\n    r(value);\n  });\n}\n","import { Of } from \"base/Of\";\nimport { isMessage } from \"helpers/guards\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\n\n/**\n * A function that helps to ensure that\n * the message is indeed a message object\n * and not just a value\n */\nexport function ActualMessage<T>(message: MaybeMessage<T>): MessageType<T> {\n  return isMessage(message) ? message : Of(message);\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * Allows creating an object that definitely has a destructor,\n * useful to avoid creating unnecessary conditions\n */\nexport function Destroyable<T>(base: T) {\n  return new DestroyableImpl(base);\n}\n\nexport class DestroyableImpl<T> implements DestroyableType {\n  public constructor(private base: T) {}\n\n  public destroy(): this {\n    if (isDestroyable(this.base)) {\n      this.base.destroy();\n    }\n    return this;\n  }\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * An object that allows collecting all disposable objects and\n * disposing them later all together\n */\nexport function DestroyContainer() {\n  return new DestroyContainerImpl();\n}\n\nexport class DestroyContainerImpl implements DestroyableType {\n  private destructors: DestroyableType[] = [];\n\n  public add<R>(e: R): R {\n    if (isDestroyable(e)) {\n      this.destructors.push(e);\n    }\n    return e;\n  }\n\n  public destroy() {\n    this.destructors.forEach((d) => d.destroy());\n    this.destructors.length = 0;\n    return this;\n  }\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * Create local copy of source what can be destroyed\n */\nexport function Local<T>(_base: MaybeMessage<T>) {\n  const $base = ActualMessage(_base);\n  return Message<T>(function LocalImpl(r) {\n    let destroyed = false;\n    $base.then((v) => {\n      if (!destroyed) {\n        r(v);\n      }\n    });\n    return () => {\n      destroyed = true;\n    };\n  });\n}\n","import { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * A component that, on each access, returns a new instance\n * of a reference type based on the constructor function\n */\nexport function New<T>(construct: ConstructorType<[], T>) {\n  return Message<T>(function NewImpl(resolve) {\n    resolve(construct());\n  });\n}\n","/**\n * Resolver that does nothing with the passed value,\n * needed for silent message triggering\n */\nexport function Void() {\n  return () => {};\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MaybeMessage } from \"types/MessageType\";\n\ntype ExtractTypeS<T> = T extends MaybeMessage<infer U> ? U : never;\n\ntype ExtractTypesFromArrayS<T extends MaybeMessage<any>[]> = {\n  [K in keyof T]: ExtractTypeS<T[K]>;\n};\n\nconst isAllFilled = (keysFilled: Set<string>, keysKnown: Set<string>) => {\n  return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n};\n\n/**\n * A message that represents values from\n * all provided messages as an array.\n * When all messages emit their values,\n * the combined value will be returned.\n * If at least one message later emits a new\n * value, the updated array with the new value\n * will be emitted by All.\n */\nexport function All<const T extends MaybeMessage[]>(...messages: T) {\n  const $messages = messages.map(ActualMessage);\n  return Message<ExtractTypesFromArrayS<T>>(function AllImpl(r) {\n    const known = new Set<string>(Object.keys(messages));\n    const filled = new Set<string>();\n    const result: unknown[] = [];\n    if (known.size === 0) {\n      r([] as ExtractTypesFromArrayS<T>);\n      return;\n    }\n    $messages.map((m, key) => {\n      m.then((v) => {\n        filled.add(key.toString());\n        result[key] = v;\n        if (isAllFilled(filled, known)) {\n          r(result as ExtractTypesFromArrayS<T>);\n        }\n      });\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * A message that emits values received from\n * any of its bound messages\n */\nexport function Any<const T>(...messages: MaybeMessage<T>[]) {\n  const $messages = messages.map(ActualMessage);\n  return Message(function AnyImpl(r) {\n    $messages.forEach((message) => {\n      message.then(r);\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * An message that applies a function\n * to the value of the base message\n */\nexport function Applied<const T, R>(\n  base: MaybeMessage<T>,\n  applier: ConstructorType<[T], R>,\n) {\n  const $base = ActualMessage(base);\n  return Message<R>(function AppliedImpl(r) {\n    $base.then((v) => {\n      r(applier(v));\n    });\n  });\n}\n","import { Applied } from \"components/Applied\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * Allows applying variables from an message that passes an array to a function,\n * where each element of the array will be passed as a separate argument\n */\nexport function AppliedDestructured<const T extends any[], R>(\n  $base: MaybeMessage<T>,\n  applier: ConstructorType<T[number][], R>,\n) {\n  return Applied($base, function AppliedDestructuredImpl(args) {\n    return applier(...args);\n  });\n}\n","import { Rejections } from \"base/Rejections\";\nimport { isFilled } from \"helpers/guards\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MessageSourceType } from \"types/SourceType\";\n\n/**\n * A component that allows creating linked objects of information and its owner\n * in such a way that if a new value is assigned to the owner, this value\n * will become the value of the linked information source\n * https://silentium-lab.github.io/silentium/#/en/information/of\n */\nexport function Late<T>(v?: T) {\n  return new LateImpl<T>(v);\n}\n\nexport class LateImpl<T> implements MessageSourceType<T> {\n  private rejections = new Rejections();\n  private lateR: ConstructorType<[T]> | null = null;\n  private notify = () => {\n    if (isFilled(this.v) && this.lateR) {\n      try {\n        this.lateR(this.v);\n      } catch (e: any) {\n        this.rejections.reject(e);\n      }\n    }\n  };\n\n  public constructor(private v?: T) {}\n\n  public then(r: ConstructorType<[T]>): this {\n    if (this.lateR) {\n      throw new Error(\n        \"Late component gets new resolver, when another was already connected!\",\n      );\n    }\n    this.lateR = r;\n    this.notify();\n    return this;\n  }\n\n  public use(value: T): this {\n    this.v = value;\n    this.notify();\n    return this;\n  }\n\n  public catch(rejected: ConstructorType<[unknown]>) {\n    this.rejections.catch(rejected);\n    return this;\n  }\n}\n","import { Rejections } from \"base/Rejections\";\nimport { Late } from \"components/Late\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Message with error catched\n * inside another message\n */\nexport function Catch<T>($base: MessageType) {\n  const rejections = new Rejections();\n  $base.catch(rejections.reject);\n  const $error = Late<T>();\n  rejections.catch((e) => {\n    $error.use(e as T);\n  });\n\n  return $error;\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MessageType, MessageTypeValue } from \"types/MessageType\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends readonly any[]> = T extends readonly [...infer _, infer L]\n  ? L\n  : never;\n\n/**\n * Chains messages together and triggers\n * the last message only when all previous messages\n * have emitted their values. The value of Chain will be the value\n * of the last message. If any messages\n * emit a value again after the overall Chain response was already returned,\n * then Chain emits again with the value of the last message.\n */\nexport function Chain<T extends readonly MessageType[]>(...messages: T) {\n  const $messages = messages.map(ActualMessage);\n  return Message<MessageTypeValue<Last<T>>>(function ChainImpl(r) {\n    let $latest: MessageTypeValue<Last<T>> | undefined;\n    const handleMessage = (index: number) => {\n      const message = $messages[index] as Last<T>;\n      const next = $messages[index + 1] as Last<T> | undefined;\n      message.then((v) => {\n        oneMessage(v as MessageTypeValue<Last<T>>, next, index);\n      });\n    };\n    function oneMessage(\n      v: MessageTypeValue<Last<T>>,\n      next: Last<T> | undefined,\n      index: number,\n    ) {\n      if (!next) {\n        $latest = v as MessageTypeValue<Last<T>>;\n      }\n      if ($latest) {\n        r($latest);\n      }\n      if (next && !$latest) {\n        handleMessage(index + 1);\n      }\n    }\n    handleMessage(0);\n  });\n}\n","import { Message } from \"base/Message\";\nimport { MessageType } from \"types/MessageType\";\n\ntype ExecutorApplier<T> = (executor: (v: T) => void) => (v: T) => void;\n\n/**\n * Applies a value transfer function to the resolver\n * and returns the same value transfer function for the resolver\n * Useful for applying functions like debounced or throttle\n */\nexport function ExecutorApplied<T>(\n  $base: MessageType<T>,\n  applier: ExecutorApplier<T>,\n) {\n  return Message<T>(function ExecutorAppliedImpl(r) {\n    $base.then(applier(r));\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\n\n/**\n * Filters values from the source message based on a predicate function,\n * optionally providing a default value when the predicate fails.\n */\nexport function Filtered<T>(\n  base: MaybeMessage<T>,\n  predicate: ConstructorType<[T], boolean>,\n  defaultValue?: T,\n): MessageType<T> {\n  const $base = ActualMessage(base);\n  return Message<T>(function FilteredImpl(r) {\n    $base.then((v) => {\n      if (predicate(v)) {\n        r(v);\n      } else if (defaultValue !== undefined) {\n        r(defaultValue);\n      }\n    });\n  });\n}\n","import { MaybeMessage } from \"types/MessageType\";\nimport { All } from \"components/All\";\nimport { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * A message derived from event with a different\n * method call interface, based on callbacks.\n * Allows attaching a custom handler to an existing event source\n * and presenting it as a silentium message\n */\nexport function FromEvent<T>(\n  emitter: MaybeMessage<any>,\n  eventName: MaybeMessage<string>,\n  subscribeMethod: MaybeMessage<string>,\n  unsubscribeMethod?: MaybeMessage<string>,\n) {\n  const $emitter = ActualMessage(emitter);\n  const $eventName = ActualMessage(eventName);\n  const $subscribeMethod = ActualMessage(subscribeMethod);\n  const $unsubscribeMethod = ActualMessage(unsubscribeMethod);\n  return Message((r) => {\n    let lastR: ConstructorType<[T]> | null = null;\n    const handler = (v: T) => {\n      if (lastR) {\n        lastR(v);\n      }\n    };\n    All($emitter, $eventName, $subscribeMethod).then(\n      ([emitter, eventName, subscribe]) => {\n        lastR = r;\n        if (!emitter?.[subscribe]) {\n          return;\n        }\n        emitter[subscribe](eventName, handler);\n      },\n    );\n    return () => {\n      lastR = null;\n      if (!$unsubscribeMethod) {\n        return;\n      }\n      All($emitter, $eventName, $unsubscribeMethod).then(\n        ([emitter, eventName, unsubscribe]) => {\n          emitter?.[unsubscribe as string]?.(eventName, handler);\n        },\n      );\n    };\n  });\n}\n","import { MessageType } from \"types/MessageType\";\n\n/**\n * Helps represent an message as a primitive type, which can be useful\n * for cases when you need to always have a reference to the current value\n * without updating the shared value when the current one changes.\n * For example, this could be used when passing an authorization token.\n * It can also be useful for testing or logging purposes.\n */\nexport function Primitive<T>($base: MessageType<T>, theValue: T | null = null) {\n  return new PrimitiveImpl<T>($base, theValue);\n}\n\nexport class PrimitiveImpl<T> {\n  private touched = false;\n\n  public constructor(\n    private $base: MessageType<T>,\n    private theValue: T | null = null,\n  ) {}\n\n  private ensureTouched() {\n    if (!this.touched) {\n      this.$base.then((v) => {\n        this.theValue = v;\n      });\n    }\n    this.touched = true;\n  }\n\n  public [Symbol.toPrimitive]() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitive() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitiveWithException() {\n    this.ensureTouched();\n    if (this.theValue === null) {\n      throw new Error(\"Primitive value is null\");\n    }\n    return this.theValue;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { MessageSourceType, SourceType } from \"types/SourceType\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { isFilled } from \"helpers/guards\";\nimport { Primitive } from \"components/Primitive\";\n\n/**\n * An information object that helps multiple owners access\n * a single another information object\n */\nexport function Shared<T>($base: MessageType<T>, source?: SourceType<T>) {\n  return new SharedImpl<T>($base, source);\n}\n\nexport class SharedImpl<T> implements MessageSourceType<T> {\n  private resolver = (v: T) => {\n    this.lastV = v;\n    this.resolvers.forEach((r) => {\n      r(v);\n    });\n  };\n  private lastV: T | undefined;\n  private resolvers = new Set<ConstructorType<[T]>>();\n\n  public constructor(\n    private $base: MessageType<T>,\n    private source?: SourceType<T>,\n  ) {}\n\n  public then(resolved: ConstructorType<[T]>) {\n    this.resolvers.add(resolved);\n    if (this.resolvers.size === 1) {\n      this.$base.then(this.resolver);\n    } else if (isFilled(this.lastV)) {\n      resolved(this.lastV);\n    }\n    return this;\n  }\n\n  public use(value: T) {\n    if (this.source) {\n      this.source.use(value);\n    } else {\n      this.resolver(value);\n    }\n    return this;\n  }\n\n  public catch(rejected: ConstructorType<[unknown]>) {\n    this.$base.catch(rejected);\n    return this;\n  }\n\n  public destroy() {\n    this.resolvers.clear();\n    return this;\n  }\n\n  public value() {\n    return Primitive(this);\n  }\n}\n","import { Late } from \"components/Late\";\nimport { Shared } from \"components/Shared\";\n\n/**\n * An message with a value that will be set later,\n * capable of responding to many resolvers\n */\nexport function LateShared<T>(value?: T) {\n  const l = Late(value);\n  return Shared(l, l);\n}\n","import { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { All } from \"components/All\";\nimport { isMessage } from \"helpers/guards\";\nimport { Of } from \"base/Of\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { Message } from \"base/Message\";\nimport { ActualMessage } from \"base/ActualMessage\";\nimport { DestroyContainer } from \"base/DestroyContainer\";\n\n/**\n * Component that applies an info object constructor to each data item,\n * producing an information source with new values\n */\nexport function Map<T, TG>(\n  base: MaybeMessage<T[]>,\n  target: ConstructorType<[any], MessageType<TG>>,\n) {\n  const $base = ActualMessage(base);\n  return Message<TG[]>((r) => {\n    const infos: MessageType<TG>[] = [];\n    const dc = DestroyContainer();\n    $base.then((v) => {\n      dc.destroy();\n      v.forEach((val) => {\n        let $val: MessageType<T> | T = val;\n        if (!isMessage($val as object)) {\n          $val = Of($val);\n        }\n        const info = target($val);\n        dc.add(info);\n        infos.push(info);\n      });\n      All(...infos).then(r);\n    });\n  });\n}\n","import { Message } from \"base/Message\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Limits the number of values from the information source\n * to a single value - once the first value is emitted, no more\n * values are delivered from the source\n */\nexport function Once<T>($base: MessageType<T>) {\n  return Message<T>((r) => {\n    let isFilled = false;\n    $base.then((v) => {\n      if (!isFilled) {\n        isFilled = true;\n        r(v);\n      }\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { ContextType } from \"types/ContextType\";\nimport { MaybeMessage } from \"types/MessageType\";\n\nContext.transport = new Map<any, ConstructorType<[ContextType]>>();\n\n/**\n * The ability to call an external system through\n * sending a message in a standardized format\n * ContextType, the list of transport should be defined via\n * the Context.transport map object\n */\nexport function Context<T>(msg: MaybeMessage<ContextType>) {\n  const $msg = ActualMessage(msg);\n  return Message<T>((resolve, reject) => {\n    $msg.then((message) => {\n      const transport = Context.transport.get(message.transport);\n      if (transport === undefined) {\n        throw new Error(`Context: unknown transport ${message.transport}`);\n      }\n      if (!message.result) {\n        message.result = resolve;\n      }\n      if (!message.error) {\n        message.error = reject;\n      }\n      try {\n        transport(message);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { MaybeMessage } from \"types/MessageType\";\nimport { ContextType } from \"types/ContextType\";\n\n/**\n * Connects an external message to an RPC message chain\n */\nexport function ContextChain($base: MaybeMessage) {\n  return (context: ContextType) => {\n    if (!context.result) {\n      throw new Error(\"ContextChain did not find result in rpc message\");\n    }\n    ActualMessage($base).then(context.result);\n  };\n}\n","import { Message } from \"base/Message\";\nimport { LateShared } from \"components/LateShared\";\nimport { Context } from \"components/Context\";\nimport { ContextType } from \"types/ContextType\";\n\n/**\n * Message for the arrival of a specific RPC message\n * for specific transport\n */\nexport function ContextOf(transport: string) {\n  const $msg = LateShared<ContextType>();\n  Context.transport.set(transport, $msg.use.bind($msg));\n  return Message<ContextType>((t) => {\n    $msg.then(t);\n  });\n}\n","import { Message } from \"base/Message\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Creates a sequence that accumulates all values from the source into an array,\n * emitting the growing array with each new value.\n */\nexport function Sequence<T>($base: MessageType<T>) {\n  return Message<T[]>((r) => {\n    const result: T[] = [];\n    $base.then((v) => {\n      result.push(v);\n      r(result);\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * Component that receives a data array and yields values one by one\n */\nexport function Stream<T>(base: MaybeMessage<T[]>) {\n  const $base = ActualMessage(base);\n  return Message<T>((r) => {\n    $base.then((v) => {\n      v.forEach((cv) => {\n        r(cv);\n      });\n    });\n  });\n}\n"],"names":["Rejections","constructor","__publicField","this","reason","lastRejectReason","catchers","forEach","catcher","rejected","push","destroy","length","isFilled","value","isMessage","o","then","isDestroyable","isDestroyed","destroyed","ensureFunction","v","label","Error","ensureMessage","Message","executor","MessageRx","resolve","mbDestructor","rejections","reject","e","catch","Of","r","ActualMessage","message","Destroyable","base","DestroyableImpl","DestroyContainer","DestroyContainerImpl","add","destructors","d","Local","_base","$base","New","construct","Void","All","messages","$messages","map","known","Set","Object","keys","filled","result","size","m","key","keysFilled","keysKnown","toString","Any","Applied","applier","AppliedDestructured","args","Late","LateImpl","lateR","notify","use","Catch","$error","Chain","$latest","handleMessage","index","next","oneMessage","ExecutorApplied","Filtered","predicate","defaultValue","FromEvent","emitter","eventName","subscribeMethod","unsubscribeMethod","$emitter","$eventName","$subscribeMethod","$unsubscribeMethod","lastR","handler","subscribe","unsubscribe","Primitive","theValue","PrimitiveImpl","ensureTouched","touched","Symbol","toPrimitive","primitive","primitiveWithException","Shared","source","SharedImpl","lastV","resolvers","resolved","resolver","clear","LateShared","l","Map","target","infos","dc","val","$val","info","Once","Context","msg","$msg","transport","get","error","ContextChain","context","ContextOf","set","bind","t","Sequence","Stream","cv"],"mappings":"0JAKO,MAAMA,EAAN,WAAAC,GACLC,EAAAC,KAAQ,WAAyC,IACjDD,EAAAC,KAAQ,mBAA4B,MAE7BD,EAAAC,KAAA,UAAUC,IACfD,KAAKE,iBAAmBD,EACnBD,KAAAG,SAASC,SAASC,IACrBA,EAAQJ,EAAM,GACf,GACH,CAEO,MAAMK,GAKJ,OAJuB,OAA1BN,KAAKE,kBACPI,EAASN,KAAKE,kBAEXF,KAAAG,SAASI,KAAKD,GACZN,IAAA,CAGF,OAAAQ,GAEE,OADPR,KAAKG,SAASM,OAAS,EAChBT,IAAA,ECpBE,MAAAU,EACXC,GAEOA,QAMF,SAASC,EAAUC,GAEtB,OAAM,OAANA,GACa,iBAANA,GACP,SAAUA,GACiB,mBAAnBA,EAAUC,IAEtB,CAKO,SAASC,EAAcF,GAE1B,OAAM,OAANA,GACa,iBAANA,GACP,YAAaA,GACiB,mBAAtBA,EAAUL,OAEtB,CAKO,SAASQ,EAAYH,GAExB,OAAM,OAANA,GACa,iBAANA,GACP,cAAeA,GACiB,mBAAxBA,EAAUI,SAEtB,CC5CgB,SAAAC,EAAeC,EAAYC,GACrC,GAAa,mBAAND,EACT,MAAM,IAAIE,MAAM,GAAGD,qBAEvB,CAEgB,SAAAE,EAAcH,EAAYC,GACpC,IAACR,EAAUO,GACb,MAAM,IAAIE,MAAM,GAAGD,oBAEvB,2JCGO,SAASG,EAAWC,GAClB,OAAA,IAAIC,EAAaD,EAC1B,CAKO,MAAMC,EAIJ,WAAA3B,CAAoB0B,GAAAxB,KAAAwB,SAAAA,EAHnBzB,EAAAC,KAAA,gBACAD,EAAAC,KAAA,aAAa,IAAIH,GAGvBqB,EAAeM,EAAU,oBAAmB,CAGvC,IAAAV,CAAKY,GACN,IACF1B,KAAK2B,aAAe3B,KAAKwB,SAASE,EAAS1B,KAAK4B,WAAWC,cACpDC,GACF9B,KAAA4B,WAAWC,OAAOC,EAAC,CAEnB,OAAA9B,IAAA,CAGF,MAAMM,GAEJ,OADFN,KAAA4B,WAAWG,MAAMzB,GACfN,IAAA,CAGF,OAAAQ,GAKE,MAJ0B,mBAAtBR,KAAK2B,cACd3B,KAAK2B,iBAEP3B,KAAK4B,WAAWpB,UACTR,IAAA,EC5CJ,SAASgC,EAAMrB,GACb,OAAAY,GAAW,SAAgBU,GAChCA,EAAEtB,EAAK,GAEX,CCAO,SAASuB,EAAiBC,GAC/B,OAAOvB,EAAUuB,GAAWA,EAAUH,EAAGG,EAC3C,CCJO,SAASC,EAAeC,GACtB,OAAA,IAAIC,EAAgBD,EAC7B,CAEO,MAAMC,EACJ,WAAAxC,CAAoBuC,GAAArC,KAAAqC,KAAAA,CAAA,CAEpB,OAAA7B,GAIE,OAHHO,EAAcf,KAAKqC,OACrBrC,KAAKqC,KAAK7B,UAELR,IAAA,uICXJ,SAASuC,IACd,OAAO,IAAIC,CACb,CAEO,MAAMA,EAAN,WAAA1C,GACLC,EAAAC,KAAQ,cAAiC,GAAC,CAEnC,GAAAyC,CAAOX,GAIL,OAHHf,EAAce,IACX9B,KAAA0C,YAAYnC,KAAKuB,GAEjBA,CAAA,CAGF,OAAAtB,GAGE,OAFPR,KAAK0C,YAAYtC,SAASuC,GAAMA,EAAEnC,YAClCR,KAAK0C,YAAYjC,OAAS,EACnBT,IAAA,ECjBJ,SAAS4C,EAASC,GACjB,MAAAC,EAAQZ,EAAcW,GACrB,OAAAtB,GAAW,SAAmBU,GACnC,IAAIhB,GAAY,EAMhB,OALM6B,EAAAhC,MAAMK,IACLF,GACHgB,EAAEd,EAAC,IAGA,KACOF,GAAA,CAAA,CACd,GAEJ,CCbO,SAAS8B,EAAOC,GACd,OAAAzB,GAAW,SAAiBG,GACjCA,EAAQsB,IAAW,GAEvB,CCPO,SAASC,IACd,MAAO,MACT,CCiBO,SAASC,KAAuCC,GAC/C,MAAAC,EAAYD,EAASE,IAAInB,GACxB,OAAAX,GAAmC,SAAiBU,GACzD,MAAMqB,EAAQ,IAAIC,IAAYC,OAAOC,KAAKN,IACpCO,MAAaH,IACbI,EAAoB,GACP,IAAfL,EAAMM,KAIAR,EAAAC,KAAI,CAACQ,EAAGC,KACdD,EAAA/C,MAAMK,IAxBM,IAAC4C,EAAyBC,EAyB/BN,EAAAjB,IAAIqB,EAAIG,YACfN,EAAOG,GAAO3C,EA1BwB6C,EA2BdV,GA3BXS,EA2BGL,GA1BJE,KAAO,GAAKG,EAAWH,OAASI,EAAUJ,MA2BpD3B,EAAE0B,EAAmC,GAExC,IAVD1B,EAAE,GAWH,GAEL,CCnCO,SAASiC,KAAgBf,GACxB,MAAAC,EAAYD,EAASE,IAAInB,GACxB,OAAAX,GAAQ,SAAiBU,GACpBmB,EAAAhD,SAAS+B,IACjBA,EAAQrB,KAAKmB,EAAC,GACf,GAEL,CCNgB,SAAAkC,EACd9B,EACA+B,GAEM,MAAAtB,EAAQZ,EAAcG,GACrB,OAAAd,GAAW,SAAqBU,GAC/Ba,EAAAhC,MAAMK,IACRc,EAAAmC,EAAQjD,GAAE,GACb,GAEL,CCXgB,SAAAkD,EACdvB,EACAsB,GAEA,OAAOD,EAAQrB,GAAO,SAAiCwB,GAC9C,OAAAF,KAAWE,EAAI,GAE1B,2JCJO,SAASC,EAAQpD,GACf,OAAA,IAAIqD,EAAYrD,EACzB,CAEO,MAAMqD,EAaJ,WAAA1E,CAAoBqB,GAAAnB,KAAAmB,EAAAA,EAZnBpB,EAAAC,KAAA,aAAa,IAAIH,GACzBE,EAAAC,KAAQ,QAAqC,MAC7CD,EAAAC,KAAQ,UAAS,KACf,GAAIU,EAASV,KAAKmB,IAAMnB,KAAKyE,MACvB,IACGzE,KAAAyE,MAAMzE,KAAKmB,SACTW,GACF9B,KAAA4B,WAAWC,OAAOC,EAAC,CAC1B,GAEJ,CAIO,IAAAhB,CAAKmB,GACV,GAAIjC,KAAKyE,MACP,MAAM,IAAIpD,MACR,yEAKG,OAFPrB,KAAKyE,MAAQxC,EACbjC,KAAK0E,SACE1E,IAAA,CAGF,GAAA2E,CAAIhE,GAGF,OAFPX,KAAKmB,EAAIR,EACTX,KAAK0E,SACE1E,IAAA,CAGF,MAAMM,GAEJ,OADFN,KAAA4B,WAAWG,MAAMzB,GACfN,IAAA,ECzCJ,SAAS4E,EAAS9B,GACjB,MAAAlB,EAAa,IAAI/B,EACjBiD,EAAAf,MAAMH,EAAWC,QACvB,MAAMgD,EAASN,IAKR,OAJI3C,EAAAG,OAAOD,IAChB+C,EAAOF,IAAI7C,EAAM,IAGZ+C,CACT,CCAO,SAASC,KAA2C3B,GACnD,MAAAC,EAAYD,EAASE,IAAInB,GACxB,OAAAX,GAAmC,SAAmBU,GACvD,IAAA8C,EACE,MAAAC,EAAiBC,IACf,MAAA9C,EAAUiB,EAAU6B,GACpBC,EAAO9B,EAAU6B,EAAQ,GACvB9C,EAAArB,MAAMK,KAIP,SACPA,EACA+D,EACAD,GAEKC,IACOH,EAAA5D,GAER4D,GACF9C,EAAE8C,GAEAG,IAASH,GACXC,EAAcC,EAAQ,EACxB,CAhBaE,CAAAhE,EAAgC+D,EAAMD,EAAK,GACvD,EAiBHD,EAAc,EAAC,GAEnB,CCnCgB,SAAAI,EACdtC,EACAsB,GAEO,OAAA7C,GAAW,SAA6BU,GACvCa,EAAAhC,KAAKsD,EAAQnC,GAAE,GAEzB,CCRgB,SAAAoD,EACdhD,EACAiD,EACAC,GAEM,MAAAzC,EAAQZ,EAAcG,GACrB,OAAAd,GAAW,SAAsBU,GAChCa,EAAAhC,MAAMK,IACNmE,EAAUnE,GACZc,EAAEd,QACwB,IAAjBoE,GACTtD,EAAEsD,EAAY,GAEjB,GAEL,CCZO,SAASC,EACdC,EACAC,EACAC,EACAC,GAEM,MAAAC,EAAW3D,EAAcuD,GACzBK,EAAa5D,EAAcwD,GAC3BK,EAAmB7D,EAAcyD,GACjCK,EAAqB9D,EAAc0D,GAClC,OAAArE,GAASU,IACd,IAAIgE,EAAqC,KACnC,MAAAC,EAAW/E,IACX8E,GACFA,EAAM9E,EAAC,EAYX,OATI+B,EAAA2C,EAAUC,EAAYC,GAAkBjF,MAC1C,EAAE2E,EAASC,EAAWS,MACZF,EAAAhE,EACHwD,IAAUU,IAGfV,EAAQU,GAAWT,EAAWQ,EAAO,IAGlC,KACGD,EAAA,KACHD,GAGD9C,EAAA2C,EAAUC,EAAYE,GAAoBlF,MAC5C,EAAE2E,EAASC,EAAWU,MACpBX,IAAUW,KAAyBV,EAAWQ,EAAO,GAEzD,CACF,GAEJ,sICzCgB,SAAAG,EAAavD,EAAuBwD,EAAqB,MAChE,OAAA,IAAIC,EAAiBzD,EAAOwD,EACrC,CAEO,MAAMC,EAGJ,WAAAzG,CACGgD,EACAwD,EAAqB,MADrBtG,KAAA8C,MAAAA,EACA9C,KAAAsG,SAAAA,EAJVvG,EAAAC,KAAQ,WAAU,EAAA,CAOV,aAAAwG,GACDxG,KAAKyG,SACHzG,KAAA8C,MAAMhC,MAAMK,IACfnB,KAAKsG,SAAWnF,CAAA,IAGpBnB,KAAKyG,SAAU,CAAA,CAGjB,CAAQC,OAAOC,eAEb,OADA3G,KAAKwG,gBACExG,KAAKsG,QAAA,CAGP,SAAAM,GAEL,OADA5G,KAAKwG,gBACExG,KAAKsG,QAAA,CAGP,sBAAAO,GAED,GADJ7G,KAAKwG,gBACiB,OAAlBxG,KAAKsG,SACD,MAAA,IAAIjF,MAAM,2BAElB,OAAOrB,KAAKsG,QAAA,4JCnCA,SAAAQ,EAAUhE,EAAuBiE,GACxC,OAAA,IAAIC,EAAclE,EAAOiE,EAClC,CAEO,MAAMC,EAUJ,WAAAlH,CACGgD,EACAiE,GADA/G,KAAA8C,MAAAA,EACA9C,KAAA+G,OAAAA,EAXFhH,EAAAC,KAAA,YAAYmB,IAClBnB,KAAKiH,MAAQ9F,EACRnB,KAAAkH,UAAU9G,SAAS6B,IACtBA,EAAEd,EAAC,GACJ,IAEKpB,EAAAC,KAAA,SACAD,EAAAC,KAAA,gBAAgBuD,IAA0B,CAO3C,IAAAzC,CAAKqG,GAOH,OANFnH,KAAAkH,UAAUzE,IAAI0E,GACS,IAAxBnH,KAAKkH,UAAUtD,KACZ5D,KAAA8C,MAAMhC,KAAKd,KAAKoH,UACZ1G,EAASV,KAAKiH,QACvBE,EAASnH,KAAKiH,OAETjH,IAAA,CAGF,GAAA2E,CAAIhE,GAMF,OALHX,KAAK+G,OACF/G,KAAA+G,OAAOpC,IAAIhE,GAEhBX,KAAKoH,SAASzG,GAETX,IAAA,CAGF,MAAMM,GAEJ,OADFN,KAAA8C,MAAMf,MAAMzB,GACVN,IAAA,CAGF,OAAAQ,GAEE,OADPR,KAAKkH,UAAUG,QACRrH,IAAA,CAGF,KAAAW,GACL,OAAO0F,EAAUrG,KAAI,ECpDlB,SAASsH,EAAc3G,GACtB,MAAA4G,EAAIhD,EAAK5D,GACR,OAAAmG,EAAOS,EAAGA,EACnB,CCGgB,SAAAC,EACdnF,EACAoF,GAEM,MAAA3E,EAAQZ,EAAcG,GACrB,OAAAd,GAAeU,IACpB,MAAMyF,EAA2B,GAC3BC,EAAKpF,IACLO,EAAAhC,MAAMK,IACVwG,EAAGnH,UACDW,EAAAf,SAASwH,IACT,IAAIC,EAA2BD,EAC1BhH,EAAUiH,KACbA,EAAO7F,EAAG6F,IAEN,MAAAC,EAAOL,EAAOI,GACpBF,EAAGlF,IAAIqF,GACPJ,EAAMnH,KAAKuH,EAAI,IAEjB5E,KAAOwE,GAAO5G,KAAKmB,EAAC,GACrB,GAEL,CC3BO,SAAS8F,EAAQjF,GACf,OAAAvB,GAAYU,IACjB,IAAIvB,GAAW,EACToC,EAAAhC,MAAMK,IACLT,IACQA,GAAA,EACXuB,EAAEd,GAAC,GAEN,GAEL,CCJO,SAAS6G,EAAWC,GACnB,MAAAC,EAAOhG,EAAc+F,GACpB,OAAA1G,GAAW,CAACG,EAASG,KACrBqG,EAAApH,MAAMqB,IACT,MAAMgG,EAAYH,EAAQG,UAAUC,IAAIjG,EAAQgG,WAChD,QAAkB,IAAdA,EACF,MAAM,IAAI9G,MAAM,8BAA8Bc,EAAQgG,aAEnDhG,EAAQwB,SACXxB,EAAQwB,OAASjC,GAEdS,EAAQkG,QACXlG,EAAQkG,MAAQxG,GAEd,IACFsG,EAAUhG,SACHkG,GACPxG,EAAOwG,EAAK,IAEf,GAEL,CC5BO,SAASC,EAAaxF,GAC3B,OAAQyF,IACF,IAACA,EAAQ5E,OACL,MAAA,IAAItC,MAAM,mDAElBa,EAAcY,GAAOhC,KAAKyH,EAAQ5E,OAAM,CAE5C,CCLO,SAAS6E,EAAUL,GACxB,MAAMD,EAAOZ,IAEN,OADPU,EAAQG,UAAUM,IAAIN,EAAWD,EAAKvD,IAAI+D,KAAKR,IACxC3G,GAAsBoH,IAC3BT,EAAKpH,KAAK6H,EAAC,GAEf,CCRO,SAASC,EAAY9F,GACnB,OAAAvB,GAAcU,IACnB,MAAM0B,EAAc,GACdb,EAAAhC,MAAMK,IACVwC,EAAOpD,KAAKY,GACZc,EAAE0B,EAAM,GACT,GAEL,CCRO,SAASkF,EAAUxG,GAClB,MAAAS,EAAQZ,EAAcG,GACrB,OAAAd,GAAYU,IACXa,EAAAhC,MAAMK,IACRA,EAAAf,SAAS0I,IACT7G,EAAE6G,EAAE,GACL,GACF,GAEL,CJVAd,EAAQG,cAAgBX"}