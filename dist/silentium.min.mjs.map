{"version":3,"file":"silentium.min.mjs","sources":["../src/helpers/guards.ts","../src/base/Destroyable.ts","../src/base/DestroyContainer.ts","../src/base/Rejections.ts","../src/base/Silence.ts","../src/helpers/ensures.ts","../src/base/Message.ts","../src/base/Of.ts","../src/base/ActualMessage.ts","../src/base/Chainable.ts","../src/base/Local.ts","../src/base/MessageSource.ts","../src/base/New.ts","../src/base/Void.ts","../src/components/All.ts","../src/components/Any.ts","../src/components/Applied.ts","../src/components/AppliedDestructured.ts","../src/components/Late.ts","../src/components/Catch.ts","../src/components/Chain.ts","../src/components/Computed.ts","../src/components/Context.ts","../src/components/ContextChain.ts","../src/components/Primitive.ts","../src/components/Shared.ts","../src/components/LateShared.ts","../src/components/ContextOf.ts","../src/components/Filtered.ts","../src/components/Empty.ts","../src/components/ExecutorApplied.ts","../src/components/Freeze.ts","../src/components/FromEvent.ts","../src/components/Map.ts","../src/components/Once.ts","../src/components/Process.ts","../src/components/Sequence.ts","../src/components/Stream.ts"],"sourcesContent":["import { DestroyableType, DestroyedType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\nimport { SourceType } from \"types/SourceType\";\n\n/**\n * Checks that the value is neither undefined nor null\n */\nexport const isFilled = <T>(\n  value?: T,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\n/**\n * Checks that the object is an message\n */\nexport function isMessage(o: unknown): o is MessageType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"then\" in o &&\n    typeof (o as any).then === \"function\"\n  );\n}\n\n/**\n * Checks that the object is an message\n */\nexport function isSource(o: unknown): o is SourceType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"use\" in o &&\n    typeof (o as any).use === \"function\"\n  );\n}\n\n/**\n * Checks that the object is destroyable\n */\nexport function isDestroyable(o: unknown): o is DestroyableType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroy\" in o &&\n    typeof (o as any).destroy === \"function\"\n  );\n}\n\n/**\n * Checks that the object can indicate whether it has been destroyed or not\n */\nexport function isDestroyed(o: unknown): o is DestroyedType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroyed\" in o &&\n    typeof (o as any).destroyed === \"function\"\n  );\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * Allows creating an object that definitely has a destructor,\n * useful to avoid creating unnecessary conditions\n */\nexport function Destroyable<T>(base: T) {\n  return new DestroyableImpl(base);\n}\n\nexport class DestroyableImpl<T> implements DestroyableType {\n  public constructor(private base: T) {}\n\n  public destroy(): this {\n    if (isDestroyable(this.base)) {\n      this.base.destroy();\n    }\n\n    if (typeof this.base === \"function\") {\n      this.base();\n    }\n\n    return this;\n  }\n}\n","import { Destroyable } from \"base/Destroyable\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * An object that allows collecting all disposable objects and\n * disposing them later all together\n */\nexport function DestroyContainer() {\n  return new DestroyContainerImpl();\n}\n\nexport class DestroyContainerImpl implements DestroyableType {\n  private destructors: DestroyableType[] = [];\n\n  public add<R>(e: R): R {\n    this.destructors.push(Destroyable(e));\n    return e;\n  }\n\n  public destroy() {\n    this.destructors.forEach((d) => d.destroy());\n    this.destructors.length = 0;\n    return this;\n  }\n}\n","import { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * Handles rejections collection\n */\nexport class Rejections {\n  private catchers: ConstructorType<[unknown]>[] = [];\n  private lastRejectReason: unknown = null;\n\n  public reject = (reason: unknown) => {\n    this.lastRejectReason = reason;\n    this.catchers.forEach((catcher) => {\n      catcher(reason);\n    });\n  };\n\n  public catch(rejected: ConstructorType<[unknown]>) {\n    if (this.lastRejectReason !== null) {\n      rejected(this.lastRejectReason);\n    }\n    this.catchers.push(rejected);\n    return this;\n  }\n\n  public destroy() {\n    this.catchers.length = 0;\n    return this;\n  }\n}\n","import { isFilled } from \"helpers/guards\";\nimport { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * Silence is null or undefined or duplicated values\n * Everything else is not silence\n */\nexport function Silence<T>(resolve: ConstructorType<[T]>) {\n  let lastValue: T;\n  return (v: T) => {\n    if (isFilled(v) && v !== lastValue) {\n      lastValue = v;\n      resolve(v);\n    }\n  };\n}\n","import { isMessage } from \"helpers/guards\";\n\nexport function ensureFunction(v: unknown, label: string) {\n  if (typeof v !== \"function\") {\n    throw new Error(`${label}: is not function`);\n  }\n}\n\nexport function ensureMessage(v: unknown, label: string) {\n  if (!isMessage(v)) {\n    throw new Error(`${label}: is not message`);\n  }\n}\n","import { DestroyContainer } from \"base/DestroyContainer\";\nimport { Rejections } from \"base/Rejections\";\nimport { Silence } from \"base/Silence\";\nimport { ensureFunction } from \"helpers/ensures\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\n\nexport type MessageExecutorType<T> = (\n  resolve: ConstructorType<[T]>,\n  reject: ConstructorType<[unknown]>,\n) => MessageType | (() => void) | void;\n\n/**\n * A message created from an executor function.\n * The executor function can return a message destruction function.\n */\nexport function Message<T>(executor: MessageExecutorType<T>) {\n  return new MessageRx<T>(executor);\n}\n\n/**\n * Reactive message implementation\n */\nexport class MessageRx<T> implements MessageType<T>, DestroyableType {\n  private rejections = new Rejections();\n  private dc = DestroyContainer();\n\n  public constructor(private executor: MessageExecutorType<T>) {\n    ensureFunction(executor, \"Message: executor\");\n  }\n\n  public then(resolve: ConstructorType<[T]>) {\n    try {\n      this.dc.add(this.executor(Silence(resolve), this.rejections.reject));\n    } catch (e: any) {\n      this.rejections.reject(e);\n    }\n    return this;\n  }\n\n  public catch(rejected: ConstructorType<[unknown]>) {\n    this.rejections.catch(rejected);\n    return this;\n  }\n\n  public destroy() {\n    this.dc.destroy();\n    this.rejections.destroy();\n    return this;\n  }\n}\n","import { Message } from \"base/Message\";\n\n/**\n * Helps convert a value into a message\n */\nexport function Of<T>(value: T) {\n  return Message<T>(function OfImpl(r) {\n    r(value);\n  });\n}\n","import { Of } from \"base/Of\";\nimport { isMessage } from \"helpers/guards\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\n\n/**\n * A function that helps to ensure that\n * the message is indeed a message object\n * and not just a value\n */\nexport function ActualMessage<T>(message: MaybeMessage<T>): MessageType<T> {\n  return isMessage(message) ? message : Of(message);\n}\n","import { ChainableType } from \"types/ChainableType\";\nimport { MessageType } from \"types/MessageType\";\nimport { SourceType } from \"types/SourceType\";\n\n/**\n * Helps to connect Different\n * message and source\n */\nexport function Chainable<T>(src: SourceType<T>) {\n  return new ChainableImpl(src);\n}\n\nexport class ChainableImpl<T> implements ChainableType<T> {\n  public constructor(private src: SourceType<T>) {}\n\n  public chain($m: MessageType<T>) {\n    $m.then(this.src.use.bind(this.src));\n    return this;\n  }\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * Create local copy of source what can be destroyed\n */\nexport function Local<T>(_base: MaybeMessage<T>) {\n  const $base = ActualMessage(_base);\n  return Message<T>(function LocalImpl(resolve, reject) {\n    let destroyed = false;\n    $base.then((v) => {\n      if (!destroyed) {\n        resolve(v);\n      }\n    });\n    $base.catch(reject);\n    return () => {\n      destroyed = true;\n    };\n  });\n}\n","import { Message, MessageExecutorType, MessageRx } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MessageSourceType } from \"types/SourceType\";\n\n/**\n * Base message source object\n */\nexport function MessageSource<T>(\n  messageExecutor: MessageExecutorType<T>,\n  sourceExecutor: ConstructorType<[T]>,\n) {\n  return new MessageSourceImpl(messageExecutor, sourceExecutor);\n}\n\nexport class MessageSourceImpl<T> implements MessageSourceType<T> {\n  private message: MessageRx<T>;\n\n  public constructor(\n    messageExecutor: MessageExecutorType<T>,\n    private sourceExecutor: ConstructorType<[T]>,\n  ) {\n    this.message = Message(messageExecutor);\n  }\n\n  public use(value: T): this {\n    this.sourceExecutor(value);\n    return this;\n  }\n\n  public then(resolved: ConstructorType<[T]>): this {\n    this.message.then(resolved);\n    return this;\n  }\n\n  public catch(rejected: ConstructorType<[unknown]>): this {\n    this.message.catch(rejected);\n    return this;\n  }\n}\n","import { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * A component that, on each access, returns a new instance\n * of a reference type based on the constructor function\n */\nexport function New<T>(construct: ConstructorType<[], T>) {\n  return Message<T>(function NewImpl(resolve) {\n    resolve(construct());\n  });\n}\n","/**\n * Resolver that does nothing with the passed value,\n * needed for silent message triggering\n */\nexport function Void() {\n  return () => {};\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MaybeMessage } from \"types/MessageType\";\n\ntype ExtractTypeS<T> = T extends MaybeMessage<infer U> ? U : never;\n\ntype ExtractTypesFromArrayS<T extends MaybeMessage<any>[]> = {\n  [K in keyof T]: ExtractTypeS<T[K]>;\n};\n\nconst isAllFilled = (keysFilled: Set<string>, keysKnown: Set<string>) => {\n  return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n};\n\n/**\n * A message that represents values from\n * all provided messages as an array.\n * When all messages emit their values,\n * the combined value will be returned.\n * If at least one message later emits a new\n * value, the updated array with the new value\n * will be emitted by All.\n */\nexport function All<const T extends MaybeMessage[]>(...messages: T) {\n  const $messages = messages.map(ActualMessage);\n  return Message<ExtractTypesFromArrayS<T>>(function AllImpl(resolve, reject) {\n    const known = new Set<string>(Object.keys(messages));\n    const filled = new Set<string>();\n    const result: unknown[] = [];\n    if (known.size === 0) {\n      resolve([] as ExtractTypesFromArrayS<T>);\n      return;\n    }\n    $messages.map((m, key) => {\n      m.catch(reject);\n      m.then((v) => {\n        filled.add(key.toString());\n        result[key] = v;\n        if (isAllFilled(filled, known)) {\n          resolve(result as ExtractTypesFromArrayS<T>);\n        }\n      });\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * A message that emits values received from\n * any of its bound messages\n */\nexport function Any<const T>(...messages: MaybeMessage<T>[]) {\n  const $messages = messages.map(ActualMessage);\n  return Message<T>(function AnyImpl(resolve, reject) {\n    $messages.forEach((message) => {\n      message.catch(reject);\n      message.then(resolve);\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * An message that applies a function\n * to the value of the base message\n */\nexport function Applied<const T, R>(\n  base: MaybeMessage<T>,\n  applier: ConstructorType<[T], R>,\n) {\n  const $base = ActualMessage(base);\n  return Message<R>(function AppliedImpl(resolve, reject) {\n    $base.catch(reject);\n    $base.then((v) => {\n      resolve(applier(v));\n    });\n  });\n}\n","import { Applied } from \"components/Applied\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * Allows applying variables from an message that passes an array to a function,\n * where each element of the array will be passed as a separate argument\n */\nexport function AppliedDestructured<const T extends any[], R>(\n  $base: MaybeMessage<T>,\n  applier: ConstructorType<any[], R>,\n) {\n  return Applied($base, function AppliedDestructuredImpl(args) {\n    return applier(...args);\n  });\n}\n","import { Rejections } from \"base/Rejections\";\nimport { Silence } from \"base/Silence\";\nimport { isFilled } from \"helpers/guards\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MessageSourceType } from \"types/SourceType\";\n\n/**\n * A component that allows creating linked objects of information and its owner\n * in such a way that if a new value is assigned to the owner, this value\n * will become the value of the linked information source\n * https://silentium-lab.github.io/silentium/#/en/information/of\n */\nexport function Late<T>(v?: T) {\n  return new LateImpl<T>(v);\n}\n\nexport class LateImpl<T> implements MessageSourceType<T> {\n  private rejections = new Rejections();\n  private lateR: ConstructorType<[T]> | null = null;\n  private notify = () => {\n    if (isFilled(this.v) && this.lateR) {\n      try {\n        this.lateR(this.v);\n      } catch (e: any) {\n        this.rejections.reject(e);\n      }\n    }\n  };\n\n  public constructor(private v?: T) {}\n\n  public then(r: ConstructorType<[T]>): this {\n    if (this.lateR) {\n      throw new Error(\n        \"Late component gets new resolver, when another was already connected!\",\n      );\n    }\n    this.lateR = Silence(r);\n    this.notify();\n    return this;\n  }\n\n  public use(value: T): this {\n    this.v = value;\n    this.notify();\n    return this;\n  }\n\n  public catch(rejected: ConstructorType<[unknown]>) {\n    this.rejections.catch(rejected);\n    return this;\n  }\n}\n","import { Rejections } from \"base/Rejections\";\nimport { Late } from \"components/Late\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Message with error catched\n * inside another message\n */\nexport function Catch<T>($base: MessageType) {\n  const rejections = new Rejections();\n  $base.catch(rejections.reject);\n  const $error = Late<T>();\n  rejections.catch((e) => {\n    $error.use(e as T);\n  });\n\n  return $error;\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MessageType, MessageTypeValue } from \"types/MessageType\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends readonly any[]> = T extends readonly [...infer _, infer L]\n  ? L\n  : never;\n\n/**\n * Chains messages together and triggers\n * the last message only when all previous messages\n * have emitted their values. The value of Chain will be the value\n * of the last message. If any messages\n * emit a value again after the overall Chain response was already returned,\n * then Chain emits again with the value of the last message.\n */\nexport function Chain<T extends readonly MessageType[]>(...messages: T) {\n  const $messages = messages.map(ActualMessage);\n  return Message<MessageTypeValue<Last<T>>>(\n    function ChainImpl(resolve, reject) {\n      let $latest: MessageTypeValue<Last<T>> | undefined;\n      const handleMessage = (index: number) => {\n        const message = $messages[index] as Last<T>;\n        message.catch(reject);\n        const next = $messages[index + 1] as Last<T> | undefined;\n        message.then((v) => {\n          oneMessage(v as MessageTypeValue<Last<T>>, next, index);\n        });\n      };\n      function oneMessage(\n        v: MessageTypeValue<Last<T>>,\n        next: Last<T> | undefined,\n        index: number,\n      ) {\n        if (!next) {\n          $latest = v as MessageTypeValue<Last<T>>;\n        }\n        if ($latest) {\n          resolve($latest);\n        }\n        if (next && !$latest) {\n          handleMessage(index + 1);\n        }\n      }\n      handleMessage(0);\n    },\n  );\n}\n","import { All } from \"components/All\";\nimport { AppliedDestructured } from \"components/AppliedDestructured\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * Component what helps to compute\n * poor functions, and represent result\n * as message\n */\nexport function Computed<const T extends MaybeMessage<any>[], R>(\n  applier: ConstructorType<any[], R>,\n  ...messages: T\n) {\n  return AppliedDestructured(All(...messages), applier);\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { ContextType } from \"types/ContextType\";\nimport { MaybeMessage } from \"types/MessageType\";\n\nContext.transport = new Map<any, ConstructorType<[ContextType]>>();\n\n/**\n * The ability to call an external system through\n * sending a message in a standardized format\n * ContextType, the list of transport should be defined via\n * the Context.transport map object\n */\nexport function Context<T>(msg: MaybeMessage<ContextType>) {\n  const $msg = ActualMessage(msg);\n  return Message<T>((resolve, reject) => {\n    $msg.then((message) => {\n      const transport = Context.transport.get(message.transport);\n      if (transport === undefined) {\n        throw new Error(`Context: unknown transport ${message.transport}`);\n      }\n      if (!message.result) {\n        message.result = resolve;\n      }\n      if (!message.error) {\n        message.error = reject;\n      }\n      try {\n        transport(message);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { MaybeMessage } from \"types/MessageType\";\nimport { ContextType } from \"types/ContextType\";\n\n/**\n * Connects an external message to an RPC message chain\n */\nexport function ContextChain(base: MaybeMessage) {\n  const $base = ActualMessage(base);\n  return (context: ContextType) => {\n    if (!context.result) {\n      throw new Error(\"ContextChain did not find result in rpc message\");\n    }\n    $base.then(context.result);\n  };\n}\n","import { MessageType } from \"types/MessageType\";\n\n/**\n * Helps represent an message as a primitive type, which can be useful\n * for cases when you need to always have a reference to the current value\n * without updating the shared value when the current one changes.\n * For example, this could be used when passing an authorization token.\n * It can also be useful for testing or logging purposes.\n */\nexport function Primitive<T>($base: MessageType<T>, theValue: T | null = null) {\n  return new PrimitiveImpl<T>($base, theValue);\n}\n\nexport class PrimitiveImpl<T> {\n  private touched = false;\n\n  public constructor(\n    private $base: MessageType<T>,\n    private theValue: T | null = null,\n  ) {}\n\n  private ensureTouched() {\n    if (!this.touched) {\n      this.$base.then((v) => {\n        this.theValue = v;\n      });\n    }\n    this.touched = true;\n  }\n\n  public [Symbol.toPrimitive]() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitive() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitiveWithException() {\n    this.ensureTouched();\n    if (this.theValue === null) {\n      throw new Error(\"Primitive value is null\");\n    }\n    return this.theValue;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { MessageSourceType, SourceType } from \"types/SourceType\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { isFilled, isSource } from \"helpers/guards\";\nimport { Primitive } from \"components/Primitive\";\nimport { ChainableType } from \"types/ChainableType\";\n\n/**\n * An information object that helps multiple owners access\n * a single another information object\n */\nexport function Shared<T>($base: MessageType<T> | MessageSourceType<T>) {\n  return new SharedImpl<T>($base);\n}\n\nexport class SharedImpl<T> implements MessageSourceType<T>, ChainableType<T> {\n  private resolver = (v: T) => {\n    this.lastV = v;\n    this.resolvers.forEach((r) => {\n      r(v);\n    });\n  };\n  private lastV: T | undefined;\n  private resolvers = new Set<ConstructorType<[T]>>();\n  private source?: SourceType<T>;\n\n  public constructor(private $base: MessageType<T> | MessageSourceType<T>) {\n    if (isSource($base)) {\n      this.source = $base;\n    }\n  }\n\n  public then(resolved: ConstructorType<[T]>) {\n    this.resolvers.add(resolved);\n    if (this.resolvers.size === 1) {\n      this.$base.then(this.resolver);\n    } else if (isFilled(this.lastV)) {\n      resolved(this.lastV);\n    }\n    return this;\n  }\n\n  public use(value: T) {\n    if (this.source) {\n      this.source.use(value);\n    } else {\n      this.resolver(value);\n    }\n    return this;\n  }\n\n  public catch(rejected: ConstructorType<[unknown]>) {\n    this.$base.catch(rejected);\n    return this;\n  }\n\n  public destroy() {\n    this.resolvers.clear();\n    return this;\n  }\n\n  public value() {\n    return Primitive(this);\n  }\n\n  public chain(m: MessageType<T>) {\n    m.then(this.use.bind(this));\n    return this;\n  }\n}\n","import { Late } from \"components/Late\";\nimport { Shared } from \"components/Shared\";\n\n/**\n * An message with a value that will be set later,\n * capable of responding to many resolvers\n */\nexport function LateShared<T>(value?: T) {\n  const l = Late(value);\n  return Shared(l);\n}\n","import { Message } from \"base/Message\";\nimport { LateShared } from \"components/LateShared\";\nimport { Context } from \"components/Context\";\nimport { ContextType } from \"types/ContextType\";\n\n/**\n * Message for the arrival of a specific RPC message\n * for specific transport\n */\nexport function ContextOf(transport: string) {\n  const $msg = LateShared<ContextType>();\n  Context.transport.set(transport, $msg.use.bind($msg));\n  return Message<ContextType>((resolve, reject) => {\n    $msg.catch(reject);\n    $msg.then(resolve);\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\n\n/**\n * Filters values from the source message based on a predicate function,\n * optionally providing a default value when the predicate fails.\n */\nexport function Filtered<T>(\n  base: MaybeMessage<T>,\n  predicate: ConstructorType<[T], boolean>,\n  defaultValue?: T,\n): MessageType<T> {\n  const $base = ActualMessage(base);\n  return Message<T>(function FilteredImpl(resolve, reject) {\n    $base.catch(reject);\n    $base.then((v) => {\n      if (predicate(v)) {\n        resolve(v);\n      } else if (defaultValue !== undefined) {\n        resolve(defaultValue);\n      }\n    });\n  });\n}\n","import { Filtered } from \"components/Filtered\";\nimport { LateShared } from \"components/LateShared\";\nimport { Shared } from \"components/Shared\";\nimport { EmptyType } from \"types/EmptyType\";\nimport { MessageType } from \"types/MessageType\";\n\nexport const Nothing = Symbol(\"nothing\");\n\n/**\n * Helps to split message and empty\n * response\n */\nexport function Empty<T>($base: MessageType<T>) {\n  return new EmptyImpl<T>($base);\n}\n\nexport class EmptyImpl<T> implements EmptyType {\n  private $empty = LateShared<boolean>();\n\n  public constructor(private $base: MessageType<T>) {}\n\n  public message() {\n    Shared(this.$base).then((v) => {\n      if (v === Nothing) {\n        this.$empty.use(true);\n      }\n    });\n    return Filtered(this.$base, (v) => v !== Nothing);\n  }\n\n  public empty(): MessageType<boolean> {\n    return this.$empty;\n  }\n}\n","import { Message } from \"base/Message\";\nimport { MessageType } from \"types/MessageType\";\n\ntype ExecutorApplier<T> = (executor: (v: T) => void) => (v: T) => void;\n\n/**\n * Applies a value transfer function to the resolver\n * and returns the same value transfer function for the resolver\n * Useful for applying functions like debounced or throttle\n */\nexport function ExecutorApplied<T>(\n  $base: MessageType<T>,\n  applier: ExecutorApplier<T>,\n) {\n  return Message<T>(function ExecutorAppliedImpl(resolve, reject) {\n    $base.catch(reject);\n    $base.then(applier(resolve));\n  });\n}\n","import { Message } from \"base/Message\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Message what freezes first known value\n */\nexport function Freeze<T>($base: MessageType<T>, $invalidate?: MessageType<T>) {\n  let freezedValue: T | null = null;\n  return Message<T>(function FreezeImpl(resolve, reject) {\n    $base.catch(reject);\n    $base.then((v) => {\n      if (freezedValue === null) {\n        freezedValue = v;\n      }\n      resolve(freezedValue as T);\n    });\n\n    $invalidate?.then(() => {\n      freezedValue = null;\n    });\n  });\n}\n","import { MaybeMessage } from \"types/MessageType\";\nimport { All } from \"components/All\";\nimport { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * A message derived from event with a different\n * method call interface, based on callbacks.\n * Allows attaching a custom handler to an existing event source\n * and presenting it as a silentium message\n */\nexport function FromEvent<T>(\n  emitter: MaybeMessage<any>,\n  eventName: MaybeMessage<string>,\n  subscribeMethod: MaybeMessage<string>,\n  unsubscribeMethod?: MaybeMessage<string>,\n) {\n  const $emitter = ActualMessage(emitter);\n  const $eventName = ActualMessage(eventName);\n  const $subscribeMethod = ActualMessage(subscribeMethod);\n  const $unsubscribeMethod = ActualMessage(unsubscribeMethod);\n  return Message<T>((resolve, reject) => {\n    $emitter.catch(reject);\n    $eventName.catch(reject);\n    $subscribeMethod.catch(reject);\n    $unsubscribeMethod.catch(reject);\n    let lastR: ConstructorType<[T]> | null = null;\n    const handler = (v: T) => {\n      if (lastR) {\n        lastR(v);\n      }\n    };\n    All($emitter, $eventName, $subscribeMethod).then(\n      ([emitter, eventName, subscribe]) => {\n        lastR = resolve;\n        if (!emitter?.[subscribe]) {\n          return;\n        }\n        emitter[subscribe](eventName, handler);\n      },\n    );\n    return () => {\n      lastR = null;\n      if (!$unsubscribeMethod) {\n        return;\n      }\n      All($emitter, $eventName, $unsubscribeMethod).then(\n        ([emitter, eventName, unsubscribe]) => {\n          emitter?.[unsubscribe as string]?.(eventName, handler);\n        },\n      );\n    };\n  });\n}\n","import { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { All } from \"components/All\";\nimport { isMessage } from \"helpers/guards\";\nimport { Of } from \"base/Of\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { Message } from \"base/Message\";\nimport { ActualMessage } from \"base/ActualMessage\";\nimport { DestroyContainer } from \"base/DestroyContainer\";\n\n/**\n * Component that applies an info object constructor to each data item,\n * producing an information source with new values\n */\nexport function Map<T, TG>(\n  base: MaybeMessage<T[]>,\n  target: ConstructorType<[any], MessageType<TG>>,\n) {\n  const $base = ActualMessage(base);\n  return Message<TG[]>((resolve, reject) => {\n    $base.catch(reject);\n    const infos: MessageType<TG>[] = [];\n    const dc = DestroyContainer();\n    $base.then((v) => {\n      infos.length = 0;\n      dc.destroy();\n      v.forEach((val) => {\n        let $val: MessageType<T> | T = val;\n        if (!isMessage($val as object)) {\n          $val = Of($val);\n        }\n        const info = target($val);\n        dc.add(info);\n        infos.push(info);\n      });\n      All(...infos).then(resolve);\n    });\n  });\n}\n","import { Message } from \"base/Message\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Limits the number of values from the information source\n * to a single value - once the first value is emitted, no more\n * values are delivered from the source\n */\nexport function Once<T>($base: MessageType<T>) {\n  return Message<T>((resolve, reject) => {\n    let isFilled = false;\n    $base.catch(reject);\n    $base.then((v) => {\n      if (!isFilled) {\n        isFilled = true;\n        resolve(v);\n      }\n    });\n  });\n}\n","import { DestroyContainer } from \"base/DestroyContainer\";\nimport { Message } from \"base/Message\";\nimport { LateShared } from \"components/LateShared\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MessageType } from \"types/MessageType\";\n\nexport function Process<T, R = unknown>(\n  $base: MessageType<T>,\n  builder: ConstructorType<[T], MessageType<R>>,\n) {\n  return Message<R>((resolve, reject) => {\n    const $res = LateShared<R>();\n    const dc = DestroyContainer();\n\n    $base.then((v) => {\n      dc.destroy();\n      const $msg = builder(v);\n      dc.add($msg);\n      $res.chain($msg);\n      $msg.catch(reject);\n    });\n    $base.catch(reject);\n    $res.then(resolve);\n\n    return () => {\n      dc.destroy();\n    };\n  });\n}\n","import { Message } from \"base/Message\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Creates a sequence that accumulates all values from the source into an array,\n * emitting the growing array with each new value.\n */\nexport function Sequence<T>($base: MessageType<T>) {\n  return Message<T[]>((resolve, reject) => {\n    const result: T[] = [];\n    $base.catch(reject);\n    $base.then((v) => {\n      result.push(v);\n      resolve(result.slice());\n    });\n  });\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Message } from \"base/Message\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * Component that receives a data array and yields values one by one\n */\nexport function Stream<T>(base: MaybeMessage<T[]>) {\n  const $base = ActualMessage(base);\n  return Message<T>((resolve, reject) => {\n    $base.catch(reject);\n    $base.then((v) => {\n      v.forEach((cv) => {\n        resolve(cv);\n      });\n    });\n  });\n}\n"],"names":["isFilled","value","isMessage","o","then","isSource","use","isDestroyable","destroy","isDestroyed","destroyed","Destroyable","base","DestroyableImpl","constructor","this","DestroyContainer","DestroyContainerImpl","__publicField","add","e","destructors","push","forEach","d","length","Rejections","reason","lastRejectReason","catchers","catcher","rejected","Silence","resolve","lastValue","v","ensureFunction","label","Error","ensureMessage","Message","executor","MessageRx","dc","rejections","reject","catch","Of","r","ActualMessage","message","Chainable","src","ChainableImpl","chain","$m","bind","Local","_base","$base","MessageSource","messageExecutor","sourceExecutor","MessageSourceImpl","resolved","New","construct","Void","All","messages","$messages","map","known","Set","Object","keys","filled","result","size","m","key","keysFilled","keysKnown","toString","Any","Applied","applier","AppliedDestructured","args","Late","LateImpl","lateR","notify","Catch","$error","Chain","$latest","handleMessage","index","next","oneMessage","Computed","Context","msg","$msg","transport","get","error","ContextChain","context","Map","Primitive","theValue","PrimitiveImpl","ensureTouched","touched","Symbol","toPrimitive","primitive","primitiveWithException","Shared","SharedImpl","lastV","resolvers","source","resolver","clear","LateShared","ContextOf","set","Filtered","predicate","defaultValue","Nothing","Empty","EmptyImpl","$empty","empty","ExecutorApplied","Freeze","$invalidate","freezedValue","FromEvent","emitter","eventName","subscribeMethod","unsubscribeMethod","$emitter","$eventName","$subscribeMethod","$unsubscribeMethod","lastR","handler","subscribe","unsubscribe","target","infos","val","$val","info","Once","Process","builder","$res","Sequence","slice","Stream","cv"],"mappings":"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"}