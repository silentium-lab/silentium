{"version":3,"file":"silentium.min.mjs","sources":["../src/base/Of.ts","../src/helpers/guards.ts","../src/base/ActualMessage.ts","../src/base/Destroyable.ts","../src/base/DestroyContainer.ts","../src/helpers/ensures.ts","../src/base/Tap.ts","../src/base/Local.ts","../src/base/Message.ts","../src/base/New.ts","../src/base/TapOptional.ts","../src/base/Void.ts","../src/components/All.ts","../src/components/Any.ts","../src/components/Applied.ts","../src/components/AppliedDestructured.ts","../src/components/Catch.ts","../src/components/Chain.ts","../src/components/ExecutorApplied.ts","../src/components/Filtered.ts","../src/components/FromEvent.ts","../src/components/FromPromise.ts","../src/components/Late.ts","../src/components/Once.ts","../src/helpers/TapPool.ts","../src/components/Shared.ts","../src/components/SharedSource.ts","../src/components/Primitive.ts","../src/components/LateShared.ts","../src/components/Map.ts","../src/components/RPC.ts","../src/components/RPCChain.ts","../src/components/RPCOf.ts","../src/components/Sequence.ts","../src/components/Stream.ts","../src/components/TapApplied.ts","../src/components/TapArgs.ts","../src/components/TapDestroyable.ts"],"sourcesContent":["import { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Helps convert a value into a message\n */\nexport function Of<T>(value: T) {\n  return new OfImpl<T>(value);\n}\n\nexport class OfImpl<T> implements MessageType<T> {\n  public constructor(private value: T) {}\n\n  public pipe(tap: TapType<T>): this {\n    tap.use(this.value);\n    return this;\n  }\n}\n","import { DestroyableType, DestroyedType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Checks that the value is neither undefined nor null\n */\nexport const isFilled = <T>(\n  value?: T,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\n/**\n * Checks that the object is an message\n */\nexport function isMessage<T>(o: T): o is T & MessageType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"pipe\" in o &&\n    typeof (o as any).pipe === \"function\"\n  );\n}\n\n/**\n * Checks that the object is destroyable\n */\nexport function isDestroyable<T>(o: T): o is T & DestroyableType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroy\" in o &&\n    typeof (o as any).destroy === \"function\"\n  );\n}\n\n/**\n * Checks that the object can indicate whether it has been destroyed or not\n */\nexport function isDestroyed<T>(o: T): o is T & DestroyedType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroyed\" in o &&\n    typeof (o as any).destroyed === \"function\"\n  );\n}\n\n/**\n * Checks that the object is a tap\n */\nexport function isTap<T>(o: T): o is T & TapType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"use\" in o &&\n    typeof (o as any).use === \"function\"\n  );\n}\n","import { Of } from \"base/Of\";\nimport { isMessage } from \"helpers/guards\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\n\n/**\n * A function that helps to ensure that\n * the message is indeed a message object\n * and not just a value\n */\nexport function ActualMessage<T>(message: MaybeMessage<T>): MessageType<T> {\n  return isMessage(message) ? message : Of(message);\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * Allows creating an object that definitely has a destructor,\n * useful to avoid creating unnecessary conditions\n */\nexport function Destroyable<T>(base: T) {\n  return new DestroyableImpl(base);\n}\n\nexport class DestroyableImpl<T> implements DestroyableType {\n  public constructor(private base: T) {}\n\n  public destroy(): this {\n    if (isDestroyable(this.base)) {\n      this.base.destroy();\n    }\n    return this;\n  }\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * An object that allows collecting all disposable objects and\n * disposing them later all together\n */\nexport function DestroyContainer() {\n  return new DestroyContainerImpl();\n}\n\nexport class DestroyContainerImpl implements DestroyableType {\n  private destructors: DestroyableType[] = [];\n\n  public add<R>(e: R): R {\n    if (isDestroyable(e)) {\n      this.destructors.push(e);\n    }\n    return e;\n  }\n\n  public destroy() {\n    this.destructors.forEach((d) => d.destroy());\n    this.destructors.length = 0;\n    return this;\n  }\n}\n","import { isMessage, isTap } from \"helpers/guards\";\n\nexport function ensureFunction(v: unknown, label: string) {\n  if (typeof v !== \"function\") {\n    throw new Error(`${label}: is not function`);\n  }\n}\n\nexport function ensureMessage(v: unknown, label: string) {\n  if (!isMessage(v)) {\n    throw new Error(`${label}: is not message`);\n  }\n}\n\nexport function ensureTap(v: unknown, label: string) {\n  if (!isTap(v)) {\n    throw new Error(`${label}: is not tap`);\n  }\n}\n","import { ensureFunction } from \"helpers/ensures\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Type of value transfer logic executor\n */\nexport type TapExecutor<T> = (v: T) => void;\n\n/**\n * Base tap that accepts the passed value,\n * acts as a conductor to deliver the value from a message to somewhere\n */\nexport function Tap<T>(executor: TapExecutor<T>) {\n  return new TapImpl<T>(executor);\n}\n\nexport class TapImpl<T> implements TapType<T> {\n  public constructor(private executor: TapExecutor<T>) {\n    ensureFunction(executor, \"Tap: tap executor\");\n  }\n\n  public use(value: T) {\n    this.executor(value);\n    return this;\n  }\n}\n\n/**\n * Type of executor for value passing logic and message returning\n */\nexport type TapMessageExecutor<T, ET = T> = (v: T) => MessageType<ET>;\n\n/**\n * A tap that delivers a value from one message\n * and returns another message based on the value\n */\nexport function TapMessage<T, ET = any>(executor: TapMessageExecutor<T, ET>) {\n  return new TapMessageImpl<T, ET>(executor);\n}\n\nexport class TapMessageImpl<T, ET = T> implements TapType<T, MessageType<ET>> {\n  public constructor(private executor: TapMessageExecutor<T, ET>) {\n    ensureFunction(executor, \"TapMessage: tap executor\");\n  }\n\n  public use(value: T) {\n    return this.executor(value);\n  }\n}\n\n/**\n * A tap that accepts a child tap\n * to perform some transformation on the value\n * during its transmission\n */\nexport function TapParent<T>(\n  executor: (this: TapType, v: T, ...context: any[]) => void,\n  ...args: any[]\n) {\n  return new TapParentImpl<T>(executor, args);\n}\n\nexport class TapParentImpl<T> implements TapType<T> {\n  public constructor(\n    private executor: (this: TapType, v: T, ...context: any[]) => void,\n    private args: any[] = [],\n    private _child?: TapType<T>,\n  ) {\n    ensureFunction(executor, \"TapParent: executor\");\n  }\n\n  public use(value: T): this {\n    if (this._child === undefined) {\n      throw new Error(\"no base tap\");\n    }\n    this.executor.call(this._child, value, ...this.args);\n    return this;\n  }\n\n  public child(tap: TapType, ...args: any[]) {\n    return new TapParentImpl(this.executor, [...this.args, ...args], tap);\n  }\n}\n","import { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { TapParent } from \"base/Tap\";\nimport { ensureMessage } from \"helpers/ensures\";\nimport { TapType } from \"types/TapType\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { ActualMessage } from \"base/ActualMessage\";\n\n/**\n * Create local copy of source what can be destroyed\n */\nexport function Local<T>($base: MaybeMessage<T>) {\n  return new LocalImpl<T>(ActualMessage($base));\n}\n\nexport class LocalImpl<T> implements MessageType<T>, DestroyableType {\n  private destroyed = false;\n\n  public constructor(private $base: MessageType<T>) {\n    ensureMessage($base, \"Local: $base\");\n  }\n\n  public pipe(tap: TapType<T>): this {\n    this.$base.pipe(this.tap.child(tap));\n    return this;\n  }\n\n  private tap = TapParent(function (v: T, child: LocalImpl<T>) {\n    if (!child.destroyed) {\n      this.use(v);\n    }\n  }, this);\n\n  public destroy(): this {\n    this.destroyed = true;\n    return this;\n  }\n}\n","import { ensureFunction } from \"helpers/ensures\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\ntype MessageExecutorType<T> = (\n  this: TapType<T>,\n  tap: TapType<T>,\n) => void | (() => void);\n\n/**\n * A message created from an executor function.\n * The executor function can return a message destruction function.\n */\nexport function Message<T>(executor: MessageExecutorType<T>) {\n  return new MessageImpl<T>(executor);\n}\n\nexport class MessageImpl<T> implements MessageType<T>, DestroyableType {\n  private mbDestructor: unknown;\n\n  public constructor(private executor: MessageExecutorType<T>) {\n    ensureFunction(executor, \"Message: executor\");\n  }\n\n  public pipe(tap: TapType<T>) {\n    this.mbDestructor = this.executor.call(tap, tap);\n    return this;\n  }\n\n  public destroy() {\n    if (typeof this.mbDestructor === \"function\") {\n      this.mbDestructor?.();\n    }\n    return this;\n  }\n}\n","import { Message } from \"base/Message\";\nimport { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * A component that, on each access, returns a new instance\n * of a reference type based on the constructor function\n */\nexport function New<T>(construct: ConstructorType<[], T>) {\n  return Message<T>((tap) => {\n    tap.use(construct());\n  });\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Allows subscribing a tap to a message\n * even if the tap reference does not exist,\n * helps avoid unnecessary conditions in application code\n */\nexport function TapOptional(base?: TapType) {\n  return new TapOptionalImpl(base);\n}\n\nexport class TapOptionalImpl {\n  public constructor(private base?: TapType) {}\n\n  public wait(m: MessageType) {\n    if (this.base !== undefined) {\n      m.pipe(this.base);\n    }\n    return this;\n  }\n}\n","import { TapType } from \"types/TapType\";\n\n/**\n * Tap that does nothing with the passed value,\n * needed for silent message triggering\n */\nexport function Void() {\n  return new VoidImpl();\n}\n\nexport class VoidImpl implements TapType {\n  public use(): this {\n    return this;\n  }\n}\n","import { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { TapParent } from \"base/Tap\";\nimport { TapType } from \"types/TapType\";\nimport { ensureMessage } from \"helpers/ensures\";\nimport { ActualMessage } from \"base/ActualMessage\";\n\ntype ExtractTypeS<T> = T extends MaybeMessage<infer U> ? U : never;\n\ntype ExtractTypesFromArrayS<T extends MaybeMessage<any>[]> = {\n  [K in keyof T]: ExtractTypeS<T[K]>;\n};\n\nconst isAllFilled = (keysFilled: Set<string>, keysKnown: Set<string>) => {\n  return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n};\n\n/**\n * A message that represents values from\n * all provided messages as an array.\n * When all messages emit their values,\n * the combined value will be returned.\n * If at least one message later emits a new\n * value, the updated array with the new value\n * will be emitted by All.\n */\nexport function All<const T extends MaybeMessage[]>(...messages: T) {\n  return new AllImpl<T>(...messages);\n}\n\nexport class AllImpl<const T extends MaybeMessage[]>\n  implements MessageType<ExtractTypesFromArrayS<T>>\n{\n  private known: Set<string>;\n  private filled = new Set<string>();\n  private $messages: MessageType[];\n  private result: unknown[] = [];\n\n  public constructor(...messages: T) {\n    this.known = new Set<string>(Object.keys(messages));\n    this.$messages = messages.map(ActualMessage);\n  }\n\n  public pipe(tap: TapType<ExtractTypesFromArrayS<T>>): this {\n    Object.entries(this.$messages).forEach(([key, message]) => {\n      ensureMessage(message, \"All: item\");\n      message.pipe(this.tap.child(tap, key));\n    });\n    if (this.known.size === 0) {\n      tap.use([] as ExtractTypesFromArrayS<T>);\n    }\n    return this;\n  }\n\n  private tap = TapParent(function (\n    v: unknown,\n    child: AllImpl<T>,\n    key: string,\n  ) {\n    child.filled.add(key);\n    child.result[parseInt(key)] = v;\n    if (isAllFilled(child.filled, child.known)) {\n      this.use(child.result as ExtractTypesFromArrayS<T>);\n    }\n  }, this);\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { ensureMessage } from \"helpers/ensures\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * A message that emits values received from\n * any of its bound messages\n */\nexport function Any<const T>(...messages: MaybeMessage<T>[]) {\n  return new AnyImpl<T>(...messages.map(ActualMessage));\n}\n\nexport class AnyImpl<T> implements MessageType<T> {\n  private $messages: MessageType<T>[];\n\n  public constructor(...messages: MessageType<T>[]) {\n    this.$messages = messages;\n  }\n\n  public pipe(tap: TapType<T>): this {\n    this.$messages.forEach((message) => {\n      ensureMessage(message, \"Any: item\");\n      message.pipe(tap);\n    });\n    return this;\n  }\n}\n","import { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { TapParent } from \"base/Tap\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { ensureMessage } from \"helpers/ensures\";\nimport { TapType } from \"types/TapType\";\nimport { ActualMessage } from \"base/ActualMessage\";\n\n/**\n * An message that applies a function\n * to the value of the base message\n */\nexport function Applied<const T, R>(\n  $base: MaybeMessage<T>,\n  applier: ConstructorType<[T], R>,\n) {\n  return new AppliedImpl<T, R>(ActualMessage($base), applier);\n}\n\nexport class AppliedImpl<T, R> implements MessageType<R> {\n  public constructor(\n    private $base: MessageType<T>,\n    private applier: ConstructorType<[T], R>,\n  ) {\n    ensureMessage($base, \"Applied: base\");\n  }\n\n  public pipe(tap: TapType<R>) {\n    this.$base.pipe(this.tap.child(tap));\n    return this;\n  }\n\n  private tap = TapParent(function (v: T, child: AppliedImpl<T, R>) {\n    this.use(child.applier(v));\n  }, this);\n}\n","import { Applied } from \"components/Applied\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { MaybeMessage } from \"types/MessageType\";\n\n/**\n * Allows applying variables from an message that passes an array to a function,\n * where each element of the array will be passed as a separate argument\n */\nexport function AppliedDestructured<const T extends any[], R>(\n  $base: MaybeMessage<T>,\n  applier: ConstructorType<T[number][], R>,\n) {\n  return Applied($base, (args) => {\n    return applier(...args);\n  });\n}\n","import { ensureMessage, ensureTap } from \"helpers/ensures\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * An message representing a base message where\n * its operation is wrapped in try-catch\n * and expects exceptions. If an exception\n * bubbles up, it's passed to the taps\n * as errorMessage and errorOriginal\n */\nexport function Catch<T>(\n  $base: MessageType<T>,\n  errorMessage: TapType,\n  errorOriginal?: TapType,\n) {\n  return new CatchImpl<T>($base, errorMessage, errorOriginal);\n}\n\nexport class CatchImpl<T> implements MessageType<T> {\n  public constructor(\n    private $base: MessageType<T>,\n    private errorMessage: TapType,\n    private errorOriginal?: TapType,\n  ) {\n    ensureMessage($base, \"Catch: base\");\n    ensureTap(errorMessage, \"Catch: errorMessage\");\n    if (errorOriginal !== undefined) {\n      ensureTap(errorOriginal, \"Catch: errorOriginal\");\n    }\n  }\n\n  public pipe(tap: TapType<T>) {\n    try {\n      this.$base.pipe(tap);\n    } catch (e: unknown) {\n      if (e instanceof Error) {\n        this.errorMessage.use(e.message);\n      } else {\n        this.errorMessage.use(String(e));\n      }\n      if (this.errorOriginal) {\n        this.errorOriginal.use(e);\n      }\n    }\n    return this;\n  }\n}\n","import { TapType } from \"types/TapType\";\nimport { TapParent } from \"base/Tap\";\nimport { MessageType, MessageTypeValue } from \"types/MessageType\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends readonly any[]> = T extends readonly [...infer _, infer L]\n  ? L\n  : never;\n\n/**\n * Chains messages together and triggers\n * the last message only when all previous messages\n * have emitted their values. The value of Chain will be the value\n * of the last message. If any messages\n * emit a value again after the overall Chain response was already returned,\n * then Chain emits again with the value of the last message.\n */\nexport function Chain<T extends readonly MessageType[]>(...messages: T) {\n  return new ChainImpl<T>(...messages);\n}\n\nexport class ChainImpl<T extends readonly MessageType[]>\n  implements MessageType<MessageTypeValue<Last<T>>>\n{\n  private $messages: T;\n  private $latest: MessageTypeValue<Last<T>> | undefined;\n\n  public constructor(...messages: T) {\n    this.$messages = messages;\n  }\n\n  public pipe(tap: TapType<MessageTypeValue<Last<T>>>) {\n    this.handleMessage(0, tap);\n    return this;\n  }\n\n  private handleMessage = (index: number, tap: TapType) => {\n    const message = this.$messages[index] as Last<T>;\n    const next = this.$messages[index + 1] as Last<T> | undefined;\n    message.pipe(this.oneMessageTap.child(tap, next, index));\n  };\n\n  private oneMessageTap = TapParent(function (\n    v: MessageTypeValue<Last<T>>,\n    child: ChainImpl<T>,\n    next: Last<T> | undefined,\n    index: number,\n  ) {\n    if (!next) {\n      child.$latest = v as MessageTypeValue<Last<T>>;\n    }\n    if (child.$latest) {\n      this.use(child.$latest);\n    }\n    if (next && !child.$latest) {\n      child.handleMessage(index + 1, this);\n    }\n  }, this);\n}\n","import { Tap, TapExecutor } from \"base/Tap\";\nimport { ensureMessage } from \"helpers/ensures\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\ntype ExecutorApplier<T> = (executor: TapExecutor<T>) => TapExecutor<T>;\n\n/**\n * Applies a value transfer function to the tap\n * and returns the same value transfer function for the tap\n * Useful for applying functions like debounced or throttle\n */\nexport function ExecutorApplied<T>(\n  $base: MessageType<T>,\n  applier: ExecutorApplier<T>,\n) {\n  return new ExecutorAppliedImpl<T>($base, applier);\n}\n\nexport class ExecutorAppliedImpl<T> implements MessageType<T> {\n  public constructor(\n    private $base: MessageType<T>,\n    private applier: ExecutorApplier<T>,\n  ) {\n    ensureMessage($base, \"ExecutorApplied: base\");\n  }\n\n  public pipe(tap: TapType<T>) {\n    this.$base.pipe(Tap(this.applier(tap.use.bind(tap))));\n    return this;\n  }\n}\n","import { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { TapParent } from \"base/Tap\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { TapType } from \"types/TapType\";\nimport { ActualMessage } from \"base/ActualMessage\";\n\n/**\n * Filters values from the source message based on a predicate function,\n * optionally providing a default value when the predicate fails.\n */\nexport function Filtered<T>(\n  $base: MaybeMessage<T>,\n  predicate: ConstructorType<[T], boolean>,\n  defaultValue?: T,\n): MessageType<T> {\n  return new FilteredImpl<T>(ActualMessage($base), predicate, defaultValue);\n}\n\nexport class FilteredImpl<T> implements MessageType<T> {\n  public constructor(\n    private $base: MessageType<T>,\n    private predicate: ConstructorType<[T], boolean>,\n    private defaultValue?: T,\n  ) {}\n\n  public pipe(tap: TapType<T>) {\n    this.$base.pipe(this.parent.child(tap));\n    return this;\n  }\n\n  private parent = TapParent<T>(function (v, child: FilteredImpl<T>) {\n    if (child.predicate(v)) {\n      this.use(v);\n    } else if (child.defaultValue !== undefined) {\n      this.use(child.defaultValue);\n    }\n  }, this);\n}\n","import { TapType } from \"types/TapType\";\nimport { Tap, TapParent } from \"base/Tap\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { All } from \"components/All\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { ActualMessage } from \"base/ActualMessage\";\n\n/**\n * A message derived from event with a different\n * method call interface, based on callbacks.\n * Allows attaching a custom handler to an existing event source\n * and presenting it as a silentium message\n */\nexport function FromEvent<T>(\n  $emitter: MaybeMessage<any>,\n  $eventName: MaybeMessage<string>,\n  $subscribeMethod: MaybeMessage<string>,\n  $unsubscribeMethod?: MaybeMessage<string>,\n) {\n  return new FromEventImpl<T>(\n    ActualMessage($emitter),\n    ActualMessage($eventName),\n    ActualMessage($subscribeMethod),\n    ActualMessage($unsubscribeMethod),\n  );\n}\n\nexport class FromEventImpl<T> implements MessageType<T>, DestroyableType {\n  private lastTap: TapType<T> | null = null;\n  private handler = (v: T) => {\n    if (this.lastTap) {\n      this.lastTap.use(v);\n    }\n  };\n\n  public constructor(\n    private $emitter: MessageType<any>,\n    private $eventName: MessageType<string>,\n    private $subscribeMethod: MessageType<string>,\n    private $unsubscribeMethod?: MessageType<string>,\n  ) {}\n\n  public pipe(tap: TapType<T>): this {\n    All(this.$emitter, this.$eventName, this.$subscribeMethod).pipe(\n      this.parent.child(tap),\n    );\n    return this;\n  }\n\n  private parent = TapParent<[any, string, string]>(function (\n    [emitter, eventName, subscribe],\n    child,\n  ) {\n    child.lastTap = this;\n    if (!emitter?.[subscribe]) {\n      return;\n    }\n    emitter[subscribe](eventName, child.handler);\n  }, this);\n\n  public destroy(): this {\n    this.lastTap = null;\n    if (!this.$unsubscribeMethod) {\n      return this;\n    }\n    All(this.$emitter, this.$eventName, this.$unsubscribeMethod).pipe(\n      Tap(([emitter, eventName, unsubscribe]) => {\n        emitter?.[unsubscribe]?.(eventName, this.handler);\n      }),\n    );\n    return this;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Creates an message from a Promise, allowing the promise's resolution or rejection\n * to be handled as an message. The resolved value is emitted to the tap,\n * and if an error is provided, rejections are forwarded to it.\n */\nexport function FromPromise<T>(p: Promise<T>, error?: TapType) {\n  return new FromPromiseImpl<T>(p, error);\n}\n\nexport class FromPromiseImpl<T> implements MessageType<T> {\n  public constructor(\n    private p: Promise<T>,\n    private error?: TapType,\n  ) {}\n\n  public pipe(tap: TapType<T>): this {\n    this.p\n      .then((v) => {\n        tap.use(v);\n      })\n      .catch((e) => {\n        this.error?.use(e);\n      });\n    return this;\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { isFilled } from \"helpers/guards\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * A component that allows creating linked objects of information and its owner\n * in such a way that if a new value is assigned to the owner, this value\n * will become the value of the linked information source\n * https://silentium-lab.github.io/silentium/#/en/information/of\n */\nexport function Late<T>(v?: T) {\n  return new LateImpl<T>(v);\n}\n\nexport class LateImpl<T> implements SourceType<T> {\n  private lateTap: TapType<T> | null = null;\n  private notify = (v?: T) => {\n    if (isFilled(v) && this.lateTap) {\n      this.lateTap.use(v);\n    }\n  };\n\n  public constructor(private v?: T) {}\n\n  public pipe(tap: TapType<T>): this {\n    if (this.lateTap) {\n      throw new Error(\n        \"Late component gets new tap, when another was already connected!\",\n      );\n    }\n    this.lateTap = tap;\n    this.notify(this.v);\n    return this;\n  }\n\n  public use(value: T): this {\n    this.notify(value);\n    return this;\n  }\n}\n","import { TapParent } from \"base/Tap\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Limits the number of values from the information source\n * to a single value - once the first value is emitted, no more\n * values are delivered from the source\n */\nexport function Once<T>($base: MessageType<T>) {\n  return new OnceImpl<T>($base);\n}\n\nexport class OnceImpl<T> implements MessageType<T> {\n  private isFilled = false;\n\n  public constructor(private $base: MessageType<T>) {}\n\n  public pipe(tap: TapType<T>): this {\n    this.$base.pipe(this.parent.child(tap));\n    return this;\n  }\n\n  private parent = TapParent<T>(function (v, child) {\n    if (!child.isFilled) {\n      child.isFilled = true;\n      this.use(v);\n    }\n  }, this);\n}\n","import { TapType } from \"types/TapType\";\nimport { Tap } from \"base/Tap\";\nimport { isDestroyed } from \"helpers/guards\";\n\n/**\n * Helps maintain an owner list allowing different\n * owners to get information from a common source\n * https://silentium-lab.github.io/silentium/#/en/utils/owner-pool\n */\nexport class TapPool<T> {\n  private taps: Set<TapType<T>>;\n  private innerTap: TapType<T>;\n\n  public constructor() {\n    this.taps = new Set<TapType<T>>();\n    this.innerTap = Tap((v) => {\n      this.taps.forEach((tap) => {\n        if (isDestroyed(tap) && tap.destroyed()) {\n          this.taps.delete(tap);\n          return;\n        }\n        tap.use(v);\n      });\n    });\n  }\n\n  public tap() {\n    return this.innerTap;\n  }\n\n  public size(): number {\n    return this.taps.size;\n  }\n\n  public has(owner: TapType<T>): boolean {\n    return this.taps.has(owner);\n  }\n\n  public add(owner: TapType<T>) {\n    this.taps.add(owner);\n    return this;\n  }\n\n  public remove(g: TapType<T>) {\n    this.taps.delete(g);\n    return this;\n  }\n\n  public destroy() {\n    this.taps.forEach((g) => {\n      this.remove(g);\n    });\n    return this;\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { Late } from \"components/Late\";\nimport { Once } from \"components/Once\";\nimport { SourceType } from \"types/SourceType\";\nimport { TapPool } from \"helpers/TapPool\";\nimport { TapType } from \"types/TapType\";\nimport { isFilled } from \"helpers/guards\";\nimport { Tap } from \"base/Tap\";\n\n/**\n * An information object that helps multiple owners access\n * a single another information object\n */\nexport function Shared<T>($base: MessageType<T>, stateless = false) {\n  return new SharedImpl<T>($base, stateless);\n}\n\nexport class SharedImpl<T> implements SourceType<T> {\n  private tapPool = new TapPool<T>();\n  private lastValue: T | undefined;\n  private calls = Late();\n\n  public constructor(\n    private $base: MessageType<T>,\n    private stateless = false,\n  ) {\n    Once(this.calls).pipe(\n      Tap(() => {\n        this.$base.pipe(this.firstCallTap);\n      }),\n    );\n  }\n\n  public pipe(tap: TapType<T>) {\n    this.calls.use(1);\n    if (!this.stateless && isFilled(this.lastValue) && !this.tapPool.has(tap)) {\n      tap.use(this.lastValue);\n    }\n    this.tapPool.add(tap);\n    return this;\n  }\n\n  public use(value: T) {\n    this.calls.use(1);\n    this.lastValue = value;\n    this.tapPool.tap().use(value);\n    return this;\n  }\n\n  private firstCallTap = Tap<T>((v: T) => {\n    this.lastValue = v;\n    this.tapPool.tap().use(v);\n  });\n\n  public touched() {\n    this.calls.use(1);\n  }\n\n  public pool() {\n    return this.tapPool;\n  }\n\n  public destroy() {\n    return this.tapPool.destroy();\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { Shared } from \"components/Shared\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Creates a shared source that allows multiple taps to subscribe to the same underlying source.\n * The stateless parameter controls whether the sharing maintains state or not.\n */\nexport function SharedSource<T>($base: SourceType<T>, stateless = false) {\n  return new SharedSourceImpl<T>($base, stateless);\n}\n\nexport class SharedSourceImpl<T> implements SourceType<T> {\n  private $sharedBase: SourceType<T> & { touched: () => void };\n\n  public constructor(\n    private $base: SourceType<T>,\n    stateless = false,\n  ) {\n    this.$sharedBase = Shared(this.$base, stateless);\n  }\n\n  public pipe(tap: TapType<T>) {\n    this.$sharedBase.pipe(tap);\n    return this;\n  }\n\n  public use(value: T) {\n    this.$sharedBase.touched();\n    this.$base.use(value);\n    return this;\n  }\n}\n","import { Tap } from \"base/Tap\";\nimport { MessageType } from \"types/MessageType\";\n\n/**\n * Helps represent an message as a primitive type, which can be useful\n * for cases when you need to always have a reference to the current value\n * without updating the shared value when the current one changes.\n * For example, this could be used when passing an authorization token.\n * It can also be useful for testing or logging purposes.\n */\nexport function Primitive<T>($base: MessageType<T>, theValue: T | null = null) {\n  return new PrimitiveImpl<T>($base, theValue);\n}\n\nexport class PrimitiveImpl<T> {\n  private touched = false;\n\n  public constructor(\n    private $base: MessageType<T>,\n    private theValue: T | null = null,\n  ) {}\n\n  private ensureTouched() {\n    if (!this.touched) {\n      this.$base.pipe(\n        Tap((v) => {\n          this.theValue = v;\n        }),\n      );\n    }\n    this.touched = true;\n  }\n\n  public [Symbol.toPrimitive]() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitive() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitiveWithException() {\n    this.ensureTouched();\n    if (this.theValue === null) {\n      throw new Error(\"Primitive value is null\");\n    }\n    return this.theValue;\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { Late } from \"components/Late\";\nimport { SharedSource } from \"components/SharedSource\";\nimport { TapType } from \"types/TapType\";\nimport { Primitive, PrimitiveImpl } from \"components/Primitive\";\n\n/**\n * An message with a value that will be set later,\n * capable of responding to different taps\n */\nexport function LateShared<T>(value?: T) {\n  return new LateSharedImpl<T>(value);\n}\n\nexport class LateSharedImpl<T> implements SourceType<T> {\n  private $msg: SourceType<T>;\n  private primitive: PrimitiveImpl<T>;\n\n  public constructor(value?: T) {\n    this.$msg = SharedSource(Late(value));\n    this.primitive = Primitive(this, value);\n  }\n\n  public pipe(tap: TapType<T>) {\n    this.$msg.pipe(tap);\n    return this;\n  }\n\n  public use(value: T) {\n    this.$msg.use(value);\n    return this;\n  }\n\n  public value() {\n    return this.primitive;\n  }\n}\n","import { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { All } from \"components/All\";\nimport { TapType } from \"types/TapType\";\nimport { isMessage } from \"helpers/guards\";\nimport { TapParent } from \"base/Tap\";\nimport { Of } from \"base/Of\";\nimport { ActualMessage } from \"base/ActualMessage\";\n\n/**\n * Component that applies an info object constructor to each data item,\n * producing an information source with new values\n */\nexport function Map<T, TG>(\n  $base: MaybeMessage<T[]>,\n  $target: TapType<any, MessageType<TG>>,\n) {\n  return new MapImpl<T, TG>(ActualMessage($base), $target);\n}\n\nexport class MapImpl<T, TG> implements MessageType<TG[]> {\n  public constructor(\n    private $base: MessageType<T[]>,\n    private $target: TapType<any, MessageType<TG>>,\n  ) {}\n\n  public pipe(tap: TapType<TG[]>): this {\n    this.$base.pipe(this.parent.child(tap));\n    return this;\n  }\n\n  private parent = TapParent<T[]>(function (v, child) {\n    const infos: MessageType<TG>[] = [];\n    v.forEach((val) => {\n      let $val: MessageType<T> | T = val;\n      if (!isMessage($val as object)) {\n        $val = Of($val);\n      }\n      const info = child.$target.use($val);\n      infos.push(info);\n    });\n    All(...infos).pipe(this);\n  }, this);\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Tap } from \"base/Tap\";\nimport { LateShared } from \"components/LateShared\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { RPCType } from \"types/RPCType\";\nimport { TapType } from \"types/TapType\";\n\ninterface RPCImplType<T> {\n  result(): MessageType<T>;\n  error(): MessageType<Error | string>;\n}\n\n/**\n * The ability to call an external system through\n * sending a message in a standardized format\n * RPCType, the list of taps should be defined via\n * the RPC.tap object\n */\nexport function RPC<T>($rpc: MaybeMessage<RPCType>): RPCImplType<T> {\n  return new RPCImpl(ActualMessage($rpc));\n}\n\nRPC.tap = {} as { default: TapType<RPCType> } & Record<\n  string,\n  TapType<RPCType>\n>;\n\nexport class RPCImpl {\n  private $result = LateShared();\n  private $error = LateShared();\n\n  public constructor(private $rpc: MessageType<RPCType>) {}\n\n  public result() {\n    this.$rpc.pipe(\n      Tap((rpc) => {\n        const tap =\n          rpc.tap === undefined\n            ? RPC.tap.default\n            : RPC.tap[rpc.tap] || RPC.tap.default;\n        if (!tap) {\n          throw new Error(`RPCImpl: Tap not found ${rpc.tap}`);\n        }\n        if (!rpc.result) {\n          rpc.result = this.$result;\n        }\n        if (!rpc.error) {\n          rpc.error = this.$error;\n        }\n        tap.use(rpc);\n      }),\n    );\n    return this.$result;\n  }\n\n  public error() {\n    return this.$error;\n  }\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { Tap } from \"base/Tap\";\nimport { MaybeMessage } from \"types/MessageType\";\nimport { RPCType } from \"types/RPCType\";\n\n/**\n * Connects an external message to an RPC message chain\n */\nexport function RPCChain($base: MaybeMessage) {\n  return Tap<RPCType>((rpc) => {\n    if (!rpc.result) {\n      throw new Error(\"RPCChain did not find result in rpc message\");\n    }\n    ActualMessage($base).pipe(rpc.result);\n  });\n}\n","import { Message } from \"base/Message\";\nimport { LateShared } from \"components/LateShared\";\nimport { RPC } from \"components/RPC\";\nimport { RPCType } from \"types/RPCType\";\n\n/**\n * Message for the arrival of a specific RPC message\n * for specific tap\n */\nexport function RPCOf(tap: string) {\n  const $tap = LateShared<RPCType>();\n  RPC.tap[tap] = $tap;\n  return Message<RPCType>((tap) => {\n    $tap.pipe(tap);\n  });\n}\n","import { TapParent } from \"base/Tap\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Creates a sequence that accumulates all values from the source into an array,\n * emitting the growing array with each new value.\n */\nexport function Sequence<T>($base: MessageType<T>) {\n  return new SequenceImpl<T>($base);\n}\n\nexport class SequenceImpl<T> implements MessageType<T[]> {\n  private result: T[] = [];\n\n  public constructor(private $base: MessageType<T>) {}\n\n  public pipe(tap: TapType<T[]>): this {\n    this.$base.pipe(this.parent.child(tap));\n    return this;\n  }\n\n  private parent = TapParent<T>(function (v, child) {\n    child.result.push(v);\n    this.use(child.result);\n  }, this);\n}\n","import { ActualMessage } from \"base/ActualMessage\";\nimport { TapParent } from \"base/Tap\";\nimport { MaybeMessage, MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Component that receives a data array and yields values one by one\n */\nexport function Stream<T>($base: MaybeMessage<T[]>) {\n  return new StreamImpl<T>(ActualMessage($base));\n}\n\nexport class StreamImpl<T> implements MessageType<T> {\n  public constructor(private $base: MessageType<T[]>) {}\n\n  public pipe(tap: TapType<T>): this {\n    this.$base.pipe(this.parent.child(tap));\n    return this;\n  }\n\n  private parent = TapParent<T[]>(function (v) {\n    v.forEach((cv) => {\n      this.use(cv);\n    });\n  });\n}\n","import { ConstructorType } from \"types/ConstructorType\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Creates a tap that applies a constructor to the result of another tap.\n */\nexport function TapApplied<T>(\n  baseTap: TapType<any, MessageType<T>>,\n  applier: ConstructorType<[MessageType], MessageType<T>>,\n) {\n  return new TapAppliedImpl(baseTap, applier);\n}\n\nexport class TapAppliedImpl<T> implements TapType<unknown, MessageType<T>> {\n  public constructor(\n    private baseTap: TapType<any, MessageType<T>>,\n    private applier: ConstructorType<[MessageType], MessageType<T>>,\n  ) {}\n\n  public use(args: unknown) {\n    return this.applier(this.baseTap.use(args));\n  }\n}\n","import { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Creates a tap that merges additional arguments into the base tap's arguments\n * at a specified index position, allowing for flexible argument composition\n */\nexport function TapArgs(\n  baseTap: TapType<any[], MessageType>,\n  args: unknown[],\n  startFromArgIndex: number = 0,\n) {\n  return new TapArgsImpl(baseTap, args, startFromArgIndex);\n}\n\nexport class TapArgsImpl implements TapType<unknown[], MessageType<unknown>> {\n  public constructor(\n    private baseTap: TapType<any[], MessageType>,\n    private args: unknown[],\n    private startFromArgIndex: number = 0,\n  ) {}\n\n  public use(runArgs: unknown[]): MessageType<unknown> {\n    return this.baseTap.use(\n      mergeAtIndex(runArgs, this.args, this.startFromArgIndex),\n    );\n  }\n}\n\nfunction mergeAtIndex(arr1: unknown[], arr2: unknown[], index: number) {\n  const result = arr1.slice(0, index);\n  while (result.length < index) result.push(undefined);\n  return result.concat(arr2);\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { MessageType } from \"types/MessageType\";\nimport { TapType } from \"types/TapType\";\n\n/**\n * Creates a tap wrapper that automatically manages destruction of created instances\n */\nexport function TapDestroyable<T>(baseTap: TapType<any[], MessageType<T>>) {\n  return new TapDestroyableImpl<T>(baseTap);\n}\n\nexport class TapDestroyableImpl<T>\n  implements TapType<unknown, MessageType<T>>, DestroyableType\n{\n  private destructors: DestroyableType[] = [];\n\n  public constructor(private baseTap: TapType<any[], MessageType<T>>) {}\n\n  public use(args: any[]) {\n    const inst = this.baseTap.use(args);\n    if (isDestroyable(inst)) {\n      this.destructors.push(inst);\n    }\n    return inst;\n  }\n\n  public destroy(): this {\n    this.destructors.forEach((i) => i.destroy());\n    return this;\n  }\n}\n"],"names":["Of","value","OfImpl","constructor","this","pipe","tap","use","isFilled","isMessage","o","isDestroyable","destroy","isDestroyed","destroyed","isTap","ActualMessage","message","Destroyable","base","DestroyableImpl","DestroyContainer","DestroyContainerImpl","__publicField","add","e","destructors","push","forEach","d","length","ensureFunction","v","label","Error","ensureMessage","ensureTap","Tap","executor","TapImpl","TapMessage","TapMessageImpl","TapParent","args","TapParentImpl","_child","call","child","Local","$base","LocalImpl","Message","MessageImpl","mbDestructor","New","construct","TapOptional","TapOptionalImpl","wait","m","Void","VoidImpl","All","messages","AllImpl","Set","key","keysFilled","keysKnown","filled","result","parseInt","known","size","Object","keys","$messages","map","entries","Any","AnyImpl","Applied","applier","AppliedImpl","AppliedDestructured","Catch","errorMessage","errorOriginal","CatchImpl","String","Chain","ChainImpl","index","next","oneMessageTap","$latest","handleMessage","ExecutorApplied","ExecutorAppliedImpl","bind","Filtered","predicate","defaultValue","FilteredImpl","parent","FromEvent","$emitter","$eventName","$subscribeMethod","$unsubscribeMethod","FromEventImpl","lastTap","emitter","eventName","subscribe","handler","unsubscribe","FromPromise","p","error","FromPromiseImpl","then","catch","Late","LateImpl","lateTap","notify","Once","OnceImpl","TapPool","taps","innerTap","delete","has","owner","remove","g","Shared","stateless","SharedImpl","lastValue","tapPool","calls","firstCallTap","touched","pool","SharedSource","SharedSourceImpl","$sharedBase","Primitive","theValue","PrimitiveImpl","ensureTouched","Symbol","toPrimitive","primitive","primitiveWithException","LateShared","LateSharedImpl","$msg","Map","$target","MapImpl","infos","val","$val","info","RPC","$rpc","RPCImpl","rpc","default","$result","$error","RPCChain","RPCOf","$tap","Sequence","SequenceImpl","Stream","StreamImpl","cv","TapApplied","baseTap","TapAppliedImpl","TapArgs","startFromArgIndex","TapArgsImpl","runArgs","arr1","arr2","slice","concat","mergeAtIndex","TapDestroyable","TapDestroyableImpl","inst","i"],"mappings":"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"}