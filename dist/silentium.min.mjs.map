{"version":3,"file":"silentium.min.mjs","sources":["../src/base/Component.ts","../src/base/ComponentClass.ts","../src/helpers/guards.ts","../src/base/Destroyable.ts","../src/base/DestroyContainer.ts","../src/helpers/ensures.ts","../src/base/Event.ts","../src/base/Transport.ts","../src/base/Local.ts","../src/base/New.ts","../src/base/Of.ts","../src/base/TransportOptional.ts","../src/base/Void.ts","../src/components/All.ts","../src/components/Any.ts","../src/components/Applied.ts","../src/components/AppliedDestructured.ts","../src/components/Catch.ts","../src/components/Chain.ts","../src/components/ExecutorApplied.ts","../src/components/Filtered.ts","../src/components/FromEvent.ts","../src/components/FromPromise.ts","../src/components/Late.ts","../src/components/Once.ts","../src/helpers/TransportPool.ts","../src/components/Shared.ts","../src/components/SharedSource.ts","../src/components/Primitive.ts","../src/components/LateShared.ts","../src/components/Map.ts","../src/components/RPC.ts","../src/components/RPCOf.ts","../src/components/Sequence.ts","../src/components/Stream.ts","../src/components/TransportApplied.ts","../src/components/TransportArgs.ts","../src/components/TransportDestroyable.ts"],"sourcesContent":["import { DestroyableType } from \"types/DestroyableType\";\nimport { EventType, EventTypeValue } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Create a function component that\n * will emit an event with specified arguments\n * and specified type\n */\nexport function Component<T, P extends Array<any>>(\n  executor: (\n    this: TransportType<P[0] extends EventType ? EventTypeValue<P[0]> : T>,\n    ...args: P\n  ) => void | (() => void),\n): (\n  ...args: P\n) => (P[0] extends EventType ? EventType<EventTypeValue<P[0]>> : EventType<T>) &\n  DestroyableType {\n  return (...args) => {\n    let destructor: void | (() => void);\n    return {\n      event(\n        transport: TransportType<\n          P[0] extends EventType ? EventTypeValue<P[0]> : T\n        >,\n      ) {\n        destructor = executor.call(transport, ...args);\n        return this;\n      },\n      destroy() {\n        if (destructor !== undefined) {\n          destructor();\n        }\n        return this;\n      },\n    } as any;\n  };\n}\n","import { DestroyableType } from \"types/DestroyableType\";\nimport { EventType, EventTypeValue } from \"types/EventType\";\nimport { SourceType } from \"types/SourceType\";\n\ntype ConstructableType = { new (...args: any[]): any };\n\n/**\n * Creates a type-safe factory function for instantiating components with proper interface inference\n * Automatically determines return types based on whether the class implements SourceType, EventType, and DestroyableType\n */\nexport function ComponentClass<T extends ConstructableType>(\n  classConstructor: T,\n): <R = null>(\n  ...args: ConstructorParameters<T>\n) => R extends null\n  ? ConstructorParameters<T>[0] extends EventType\n    ? InstanceType<T> extends SourceType\n      ? InstanceType<T> extends DestroyableType\n        ? SourceType<EventTypeValue<ConstructorParameters<T>[0]>> &\n            DestroyableType\n        : SourceType<EventTypeValue<ConstructorParameters<T>[0]>>\n      : InstanceType<T> extends DestroyableType\n        ? EventType<EventTypeValue<ConstructorParameters<T>[0]>> &\n            DestroyableType\n        : EventType<EventTypeValue<ConstructorParameters<T>[0]>>\n    : InstanceType<T>\n  : R extends EventType\n    ? R\n    : EventType<R> {\n  return (...args) => new classConstructor(...args);\n}\n","import { DestroyableType, DestroyedType } from \"types/DestroyableType\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Checks that the value is neither undefined nor null\n */\nexport const isFilled = <T>(\n  value?: T,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n\n/**\n * Checks that the object is an event\n */\nexport function isEvent<T>(o: T): o is T & EventType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"event\" in o &&\n    typeof (o as any).event === \"function\"\n  );\n}\n\n/**\n * Checks that the object is destroyable\n */\nexport function isDestroyable<T>(o: T): o is T & DestroyableType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroy\" in o &&\n    typeof (o as any).destroy === \"function\"\n  );\n}\n\n/**\n * Checks that the object can indicate whether it has been destroyed or not\n */\nexport function isDestroyed<T>(o: T): o is T & DestroyedType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"destroyed\" in o &&\n    typeof (o as any).destroy === \"function\"\n  );\n}\n\n/**\n * Checks that the object is a transport\n */\nexport function isTransport<T>(o: T): o is T & TransportType {\n  return (\n    o !== null &&\n    typeof o === \"object\" &&\n    \"use\" in o &&\n    typeof (o as any).use === \"function\"\n  );\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * Allows creating an object that definitely has a destructor,\n * useful to avoid creating unnecessary conditions\n */\nexport function Destroyable<T>(base: T) {\n  return new DestroyableImpl(base);\n}\n\nexport class DestroyableImpl<T> implements DestroyableType {\n  public constructor(private base: T) {}\n\n  public destroy(): this {\n    if (isDestroyable(this.base)) {\n      this.base.destroy();\n    }\n    return this;\n  }\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * An object that allows collecting all disposable objects and\n * disposing them later all together\n */\nexport function DestroyContainer() {\n  return new DestroyContainerImpl();\n}\n\nexport class DestroyContainerImpl implements DestroyableType {\n  private destructors: DestroyableType[] = [];\n\n  public add<R>(e: R): R {\n    if (isDestroyable(e)) {\n      this.destructors.push(e);\n    }\n    return e;\n  }\n\n  public destroy() {\n    this.destructors.forEach((d) => d.destroy());\n    this.destructors.length = 0;\n    return this;\n  }\n}\n","import { isEvent, isTransport } from \"helpers/guards\";\n\nexport function ensureFunction(v: unknown, label: string) {\n  if (typeof v !== \"function\") {\n    throw new Error(`${label}: is not function`);\n  }\n}\n\nexport function ensureEvent(v: unknown, label: string) {\n  if (!isEvent(v)) {\n    throw new Error(`${label}: is not event`);\n  }\n}\n\nexport function ensureTransport(v: unknown, label: string) {\n  if (!isTransport(v)) {\n    throw new Error(`${label}: is not transport`);\n  }\n}\n","import { ensureFunction } from \"helpers/ensures\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\ntype EventExecutor<T> = (transport: TransportType<T>) => void | (() => void);\n\n/**\n * An event created from an executor function.\n * The executor function can return an event destruction function.\n */\nexport function Event<T>(eventExecutor: EventExecutor<T>) {\n  return new EventImpl<T>(eventExecutor);\n}\n\nexport class EventImpl<T> implements EventType<T>, DestroyableType {\n  private mbDestructor: unknown;\n\n  public constructor(private eventExecutor: EventExecutor<T>) {\n    ensureFunction(eventExecutor, \"Event: eventExecutor\");\n  }\n\n  public event(transport: TransportType<T>) {\n    this.mbDestructor = this.eventExecutor(transport);\n    return this;\n  }\n\n  public destroy() {\n    if (typeof this.mbDestructor === \"function\") {\n      this.mbDestructor?.();\n    }\n    return this;\n  }\n}\n","import { ensureFunction } from \"helpers/ensures\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Type of value transfer logic executor\n */\nexport type TransportExecutor<T> = (v: T) => void;\n\n/**\n * Base transport that accepts the passed value,\n * acts as a conductor to deliver the value from an event to somewhere\n */\nexport function Transport<T>(transportExecutor: TransportExecutor<T>) {\n  return new TransportImpl<T>(transportExecutor);\n}\n\nclass TransportImpl<T> implements TransportType<T> {\n  public constructor(private transportExecutor: TransportExecutor<T>) {\n    ensureFunction(transportExecutor, \"Transport: transport executor\");\n  }\n\n  public use(value: T) {\n    this.transportExecutor(value);\n    return this;\n  }\n}\n\n/**\n * Type of executor for value passing logic and event returning\n */\nexport type TransportEventExecutor<T, ET = T> = (v: T) => EventType<ET>;\n\n/**\n * A transport that delivers a value from one event\n * and returns another event based on the value\n */\nexport function TransportEvent<T, ET = any>(\n  transportExecutor: TransportEventExecutor<T, ET>,\n) {\n  return new TransportEventImpl<T, ET>(transportExecutor);\n}\n\nclass TransportEventImpl<T, ET = T> implements TransportType<T, EventType<ET>> {\n  public constructor(private executor: TransportEventExecutor<T, ET>) {\n    ensureFunction(executor, \"TransportEvent: transport executor\");\n  }\n\n  public use(value: T) {\n    return this.executor(value);\n  }\n}\n\n/**\n * A transport that accepts a child transport\n * to perform some transformation on the value\n * during its transmission\n */\nexport function TransportParent<T>(\n  executor: (this: TransportType, v: T, ...context: any[]) => void,\n  ...args: any[]\n) {\n  return new TransportParentImpl<T>(executor, args);\n}\n\nexport class TransportParentImpl<T> implements TransportType<T> {\n  public constructor(\n    private executor: (this: TransportType, v: T, ...context: any[]) => void,\n    private args: any[] = [],\n    private _child?: TransportType<T>,\n  ) {\n    ensureFunction(executor, \"TransportParent: executor\");\n  }\n\n  public use(value: T): this {\n    if (this._child === undefined) {\n      throw new Error(\"no base transport\");\n    }\n    this.executor.call(this._child, value, ...this.args);\n    return this;\n  }\n\n  public child(transport: TransportType, ...args: any[]) {\n    return new TransportParentImpl(\n      this.executor,\n      [...this.args, ...args],\n      transport,\n    );\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { TransportParent } from \"base/Transport\";\nimport { ensureEvent } from \"helpers/ensures\";\nimport { TransportType } from \"types/TransportType\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * Create local copy of source what can be destroyed\n */\nexport function Local<T>($base: EventType<T>) {\n  return new LocalEvent<T>($base);\n}\n\nexport class LocalEvent<T> implements EventType<T>, DestroyableType {\n  private destroyed = false;\n\n  public constructor(private $base: EventType<T>) {\n    ensureEvent($base, \"Local: $base\");\n  }\n\n  public event(transport: TransportType<T>): this {\n    this.$base.event(this.transport.child(transport));\n    return this;\n  }\n\n  private transport = TransportParent(function (v: T, child: LocalEvent<T>) {\n    if (!child.destroyed) {\n      this.use(v);\n    }\n  }, this);\n\n  public destroy(): this {\n    this.destroyed = true;\n    return this;\n  }\n}\n","import { Event } from \"base/Event\";\nimport { ConstructorType } from \"types/ConstructorType\";\n\n/**\n * A component that, on each access, returns a new instance\n * of a reference type based on the constructor function\n */\nexport function New<T>(construct: ConstructorType<[], T>) {\n  return Event<T>((transport) => {\n    transport.use(construct());\n  });\n}\n","import { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Helps convert a value into an event\n */\nexport function Of<T>(value: T) {\n  return new OfEvent<T>(value);\n}\n\nexport class OfEvent<T> implements EventType<T> {\n  public constructor(private value: T) {}\n\n  public event(transport: TransportType<T>): this {\n    transport.use(this.value);\n    return this;\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Allows subscribing a transport to an event\n * even if the transport reference does not exist,\n * helps avoid unnecessary conditions in application code\n */\nexport function TransportOptional(base?: TransportType) {\n  return new TransportOptionalImpl(base);\n}\n\nexport class TransportOptionalImpl {\n  public constructor(private base?: TransportType) {}\n\n  public wait(event: EventType) {\n    if (this.base !== undefined) {\n      event.event(this.base);\n    }\n    return this;\n  }\n}\n","import { TransportType } from \"types/TransportType\";\n\n/**\n * Transport that does nothing with the passed value,\n * needed for silent event triggering\n */\nexport function Void() {\n  return new VoidImpl();\n}\n\nexport class VoidImpl implements TransportType {\n  public use(): this {\n    return this;\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { TransportParent } from \"base/Transport\";\nimport { TransportType } from \"types/TransportType\";\nimport { ensureEvent } from \"helpers/ensures\";\n\ntype ExtractTypeS<T> = T extends EventType<infer U> ? U : never;\n\ntype ExtractTypesFromArrayS<T extends EventType<any>[]> = {\n  [K in keyof T]: ExtractTypeS<T[K]>;\n};\n\nconst isAllFilled = (keysFilled: Set<string>, keysKnown: Set<string>) => {\n  return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n};\n\n/**\n * An event that represents values from\n * all provided events as an array.\n * When all events emit their values,\n * the combined value will be returned.\n * If at least one event later emits a new\n * value, the updated array with the new value\n * will be emitted by All.\n */\nexport function All<const T extends EventType[]>(...events: T) {\n  return new AllEvent<T>(...events);\n}\n\nexport class AllEvent<const T extends EventType[]>\n  implements EventType<ExtractTypesFromArrayS<T>>\n{\n  private known: Set<string>;\n  private filled = new Set<string>();\n  private $events: T;\n  private result: unknown[] = [];\n\n  public constructor(...events: T) {\n    this.known = new Set<string>(Object.keys(events));\n    this.$events = events;\n  }\n\n  public event(transport: TransportType<ExtractTypesFromArrayS<T>>): this {\n    Object.entries(this.$events).forEach(([key, event]) => {\n      ensureEvent(event, \"All: item\");\n      event.event(this.transport.child(transport, key));\n    });\n    if (this.known.size === 0) {\n      transport.use([] as ExtractTypesFromArrayS<T>);\n    }\n    return this;\n  }\n\n  private transport = TransportParent(function (\n    v: unknown,\n    child: AllEvent<T>,\n    key: string,\n  ) {\n    child.filled.add(key);\n    child.result[parseInt(key)] = v;\n    if (isAllFilled(child.filled, child.known)) {\n      this.use(child.result as ExtractTypesFromArrayS<T>);\n    }\n  }, this);\n}\n","import { ensureEvent } from \"helpers/ensures\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * An event that emits values received from\n * any of its bound events\n */\nexport function Any<const T>(...events: EventType<T>[]) {\n  return new AnyEvent<T>(...events);\n}\n\nexport class AnyEvent<T> implements EventType<T> {\n  private $events: EventType<T>[];\n\n  public constructor(...events: EventType<T>[]) {\n    this.$events = events;\n  }\n\n  public event(transport: TransportType<T>): this {\n    this.$events.forEach((event) => {\n      ensureEvent(event, \"Any: item\");\n      event.event(transport);\n    });\n    return this;\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { TransportParent } from \"base/Transport\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { ensureEvent } from \"helpers/ensures\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * An event that applies a function\n * to the value of the base event\n */\nexport function Applied<const T, R>(\n  $base: EventType<T>,\n  applier: ConstructorType<[T], R>,\n) {\n  return new AppliedEvent<T, R>($base, applier);\n}\n\nexport class AppliedEvent<T, R> implements EventType<R> {\n  public constructor(\n    private $base: EventType<T>,\n    private applier: ConstructorType<[T], R>,\n  ) {\n    ensureEvent($base, \"Applied: base\");\n  }\n\n  public event(transport: TransportType<R>) {\n    this.$base.event(this.transport.child(transport));\n    return this;\n  }\n\n  private transport = TransportParent(function (\n    v: T,\n    child: AppliedEvent<T, R>,\n  ) {\n    this.use(child.applier(v));\n  }, this);\n}\n","import { Applied } from \"components/Applied\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { EventType } from \"types/EventType\";\n\n/**\n * Allows applying variables from an event that passes an array to a function,\n * where each element of the array will be passed as a separate argument\n */\nexport function AppliedDestructured<const T extends any[], R>(\n  $base: EventType<T>,\n  applier: ConstructorType<T[number][], R>,\n) {\n  return Applied($base, (args) => {\n    return applier(...args);\n  });\n}\n","import { ensureEvent, ensureTransport } from \"helpers/ensures\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * An event representing a base event where\n * its operation is wrapped in try-catch\n * and expects exceptions. If an exception\n * bubbles up, it's passed to the transports\n * as errorMessage and errorOriginal\n */\nexport function Catch<T>(\n  $base: EventType<T>,\n  errorMessage: TransportType,\n  errorOriginal?: TransportType,\n) {\n  return new CatchEvent<T>($base, errorMessage, errorOriginal);\n}\n\nexport class CatchEvent<T> implements EventType<T> {\n  public constructor(\n    private $base: EventType<T>,\n    private errorMessage: TransportType,\n    private errorOriginal?: TransportType,\n  ) {\n    ensureEvent($base, \"Catch: base\");\n    ensureTransport(errorMessage, \"Catch: errorMessage\");\n    if (errorOriginal !== undefined) {\n      ensureTransport(errorOriginal, \"Catch: errorOriginal\");\n    }\n  }\n\n  public event(transport: TransportType<T>) {\n    try {\n      this.$base.event(transport);\n    } catch (e: unknown) {\n      if (e instanceof Error) {\n        this.errorMessage.use(e.message);\n      } else {\n        this.errorMessage.use(String(e));\n      }\n      if (this.errorOriginal) {\n        this.errorOriginal.use(e);\n      }\n    }\n    return this;\n  }\n}\n","import { TransportType } from \"types/TransportType\";\nimport { TransportParent } from \"base/Transport\";\nimport { EventType, EventTypeValue } from \"types/EventType\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends readonly any[]> = T extends readonly [...infer _, infer L]\n  ? L\n  : never;\n\n/**\n * Chains events together and triggers\n * the last event only when all previous events\n * have emitted their values. The value of Chain will be the value\n * of the last event. If any events\n * emit a value again after the overall Chain response was already returned,\n * then Chain emits again with the value of the last event.\n */\nexport function Chain<T extends readonly EventType[]>(...events: T) {\n  return new ChainEvent<T>(...events);\n}\n\nexport class ChainEvent<T extends readonly EventType[]>\n  implements EventType<EventTypeValue<Last<T>>>\n{\n  private $events: T;\n  private $latest: EventTypeValue<Last<T>> | undefined;\n\n  public constructor(...events: T) {\n    this.$events = events;\n  }\n\n  public event(transport: TransportType<EventTypeValue<Last<T>>>) {\n    this.handleEvent(0, transport);\n    return this;\n  }\n\n  private handleEvent = (index: number, transport: TransportType) => {\n    const event = this.$events[index] as Last<T>;\n    const next = this.$events[index + 1] as Last<T> | undefined;\n    event.event(this.oneEventTransport.child(transport, next, index));\n  };\n\n  private oneEventTransport = TransportParent(function (\n    v: EventTypeValue<Last<T>>,\n    child: ChainEvent<T>,\n    next: Last<T> | undefined,\n    index: number,\n  ) {\n    if (!next) {\n      child.$latest = v as EventTypeValue<Last<T>>;\n    }\n    if (child.$latest) {\n      this.use(child.$latest);\n    }\n    if (next && !child.$latest) {\n      child.handleEvent(index + 1, this);\n    }\n  }, this);\n}\n","import { Transport, TransportExecutor } from \"base/Transport\";\nimport { ensureEvent } from \"helpers/ensures\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\ntype ExecutorApplier<T> = (\n  executor: TransportExecutor<T>,\n) => TransportExecutor<T>;\n\n/**\n * Applies a value transfer function to the transport\n * and returns the same value transfer function for the transport\n * Useful for applying functions like debounced or throttle\n */\nexport function ExecutorApplied<T>(\n  $base: EventType<T>,\n  applier: ExecutorApplier<T>,\n) {\n  return new ExecutorAppliedEvent<T>($base, applier);\n}\n\nexport class ExecutorAppliedEvent<T> implements EventType<T> {\n  public constructor(\n    private $base: EventType<T>,\n    private applier: ExecutorApplier<T>,\n  ) {\n    ensureEvent($base, \"ExecutorApplied: base\");\n  }\n\n  public event(transport: TransportType<T>) {\n    const ExecutorAppliedBaseTransport = this.applier(\n      transport.use.bind(transport),\n    );\n    this.$base.event(Transport(ExecutorAppliedBaseTransport));\n    return this;\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { TransportParent } from \"base/Transport\";\nimport { ConstructorType } from \"types/ConstructorType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Filters values from the source event based on a predicate function,\n * optionally providing a default value when the predicate fails.\n */\nexport function Filtered<T>(\n  $base: EventType<T>,\n  predicate: ConstructorType<[T], boolean>,\n  defaultValue?: T,\n): EventType<T> {\n  return new FilteredEvent<T>($base, predicate, defaultValue);\n}\n\nexport class FilteredEvent<T> implements EventType<T> {\n  public constructor(\n    private $base: EventType<T>,\n    private predicate: ConstructorType<[T], boolean>,\n    private defaultValue?: T,\n  ) {}\n\n  public event(transport: TransportType<T>) {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T>(function (v, child: FilteredEvent<T>) {\n    if (child.predicate(v)) {\n      this.use(v);\n    } else if (child.defaultValue !== undefined) {\n      this.use(child.defaultValue);\n    }\n  }, this);\n}\n","import { TransportType } from \"types/TransportType\";\nimport { Transport, TransportParent } from \"base/Transport\";\nimport { EventType } from \"types/EventType\";\nimport { All } from \"components/All\";\nimport { DestroyableType } from \"types/DestroyableType\";\n\n/**\n * An event derived from another event with a different\n * method call interface, based on callbacks.\n * Allows attaching a custom handler to an existing event source\n * and presenting it as a silentium event\n */\nexport function FromEvent<T>(\n  $emitter: EventType<any>,\n  $eventName: EventType<string>,\n  $subscribeMethod: EventType<string>,\n  $unsubscribeMethod?: EventType<string>,\n) {\n  return new FromEventAdapter<T>(\n    $emitter,\n    $eventName,\n    $subscribeMethod,\n    $unsubscribeMethod,\n  );\n}\n\nexport class FromEventAdapter<T> implements EventType<T>, DestroyableType {\n  private lastTransport: TransportType<T> | null = null;\n  private handler = (v: T) => {\n    if (this.lastTransport) {\n      this.lastTransport.use(v);\n    }\n  };\n\n  public constructor(\n    private $emitter: EventType<any>,\n    private $eventName: EventType<string>,\n    private $subscribeMethod: EventType<string>,\n    private $unsubscribeMethod?: EventType<string>,\n  ) {}\n\n  public event(transport: TransportType<T>): this {\n    All(this.$emitter, this.$eventName, this.$subscribeMethod).event(\n      this.parent.child(transport),\n    );\n    return this;\n  }\n\n  private parent = TransportParent<[any, string, string]>(function (\n    [emitter, eventName, subscribe],\n    child,\n  ) {\n    child.lastTransport = this;\n    if (!emitter?.[subscribe]) {\n      return;\n    }\n    emitter[subscribe](eventName, child.handler);\n  }, this);\n\n  public destroy(): this {\n    this.lastTransport = null;\n    if (!this.$unsubscribeMethod) {\n      return this;\n    }\n    All(this.$emitter, this.$eventName, this.$unsubscribeMethod).event(\n      Transport(([emitter, eventName, unsubscribe]) => {\n        emitter?.[unsubscribe]?.(eventName, this.handler);\n      }),\n    );\n    return this;\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates an event from a Promise, allowing the promise's resolution or rejection\n * to be handled as an event. The resolved value is emitted to the transport,\n * and if an error is provided, rejections are forwarded to it.\n */\nexport function FromPromise<T>(p: Promise<T>, error?: TransportType) {\n  return new FromPromiseEvent<T>(p, error);\n}\n\nexport class FromPromiseEvent<T> implements EventType<T> {\n  public constructor(\n    private p: Promise<T>,\n    private error?: TransportType,\n  ) {}\n\n  public event(transport: TransportType<T>): this {\n    this.p\n      .then((v) => {\n        transport.use(v);\n      })\n      .catch((e) => {\n        this.error?.use(e);\n      });\n    return this;\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { isFilled } from \"helpers/guards\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * A component that allows creating linked objects of information and its owner\n * in such a way that if a new value is assigned to the owner, this value\n * will become the value of the linked information source\n * https://silentium-lab.github.io/silentium/#/en/information/of\n */\nexport function Late<T>(v?: T) {\n  return new LateEvent<T>(v);\n}\n\nexport class LateEvent<T> implements SourceType<T> {\n  private lateTransport: TransportType<T> | null = null;\n  private notify = (v?: T) => {\n    if (isFilled(v) && this.lateTransport) {\n      this.lateTransport.use(v);\n    }\n  };\n\n  public constructor(private v?: T) {}\n\n  public event(transport: TransportType<T>): this {\n    if (this.lateTransport) {\n      throw new Error(\n        \"Late component gets new transport, when another was already connected!\",\n      );\n    }\n    this.lateTransport = transport;\n    this.notify(this.v);\n    return this;\n  }\n\n  public use(value: T): this {\n    this.notify(value);\n    return this;\n  }\n}\n","import { TransportParent } from \"base/Transport\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Limits the number of values from the information source\n * to a single value - once the first value is emitted, no more\n * values are delivered from the source\n */\nexport function Once<T>($base: EventType<T>) {\n  return new OnceEvent<T>($base);\n}\n\nexport class OnceEvent<T> implements EventType<T> {\n  private isFilled = false;\n\n  public constructor(private $base: EventType<T>) {}\n\n  public event(transport: TransportType<T>): this {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T>(function (v, child) {\n    if (!child.isFilled) {\n      child.isFilled = true;\n      this.use(v);\n    }\n  }, this);\n}\n","import { TransportType } from \"types/TransportType\";\nimport { Transport } from \"base/Transport\";\nimport { isDestroyed } from \"helpers/guards\";\n\n/**\n * Helps maintain an owner list allowing different\n * owners to get information from a common source\n * https://silentium-lab.github.io/silentium/#/en/utils/owner-pool\n */\nexport class TransportPool<T> {\n  private transports: Set<TransportType<T>>;\n  private innerTransport: TransportType<T>;\n\n  public constructor() {\n    this.transports = new Set<TransportType<T>>();\n    this.innerTransport = Transport((v) => {\n      this.transports.forEach((transport) => {\n        if (isDestroyed(transport) && transport.destroyed()) {\n          this.transports.delete(transport);\n          return;\n        }\n        transport.use(v);\n      });\n    });\n  }\n\n  public transport() {\n    return this.innerTransport;\n  }\n\n  public size(): number {\n    return this.transports.size;\n  }\n\n  public has(owner: TransportType<T>): boolean {\n    return this.transports.has(owner);\n  }\n\n  public add(owner: TransportType<T>) {\n    this.transports.add(owner);\n    return this;\n  }\n\n  public remove(g: TransportType<T>) {\n    this.transports.delete(g);\n    return this;\n  }\n\n  public destroy() {\n    this.transports.forEach((g) => {\n      this.remove(g);\n    });\n    return this;\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { Late } from \"components/Late\";\nimport { Once } from \"components/Once\";\nimport { SourceType } from \"types/SourceType\";\nimport { TransportPool } from \"helpers/TransportPool\";\nimport { TransportType } from \"types/TransportType\";\nimport { isFilled } from \"helpers/guards\";\nimport { Transport } from \"base/Transport\";\n\n/**\n * An information object that helps multiple owners access\n * a single another information object\n */\nexport function Shared<T>($base: EventType<T>, stateless = false) {\n  return new SharedEvent<T>($base, stateless);\n}\n\nexport class SharedEvent<T> implements SourceType<T> {\n  private transportPool = new TransportPool<T>();\n  private lastValue: T | undefined;\n  private calls = Late();\n\n  public constructor(\n    private $base: EventType<T>,\n    private stateless = false,\n  ) {\n    Once(this.calls).event(\n      Transport(() => {\n        this.$base.event(this.firstCallTransport);\n      }),\n    );\n  }\n\n  public event(transport: TransportType<T>) {\n    this.calls.use(1);\n    if (\n      !this.stateless &&\n      isFilled(this.lastValue) &&\n      !this.transportPool.has(transport)\n    ) {\n      transport.use(this.lastValue);\n    }\n    this.transportPool.add(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.calls.use(1);\n    this.lastValue = value;\n    this.transportPool.transport().use(value);\n    return this;\n  }\n\n  private firstCallTransport = Transport<T>((v: T) => {\n    this.lastValue = v;\n    this.transportPool.transport().use(v);\n  });\n\n  public touched() {\n    this.calls.use(1);\n  }\n\n  public pool() {\n    return this.transportPool;\n  }\n\n  public destroy() {\n    return this.transportPool.destroy();\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { Shared } from \"components/Shared\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a shared source that allows multiple transports to subscribe to the same underlying source.\n * The stateless parameter controls whether the sharing maintains state or not.\n */\nexport function SharedSource<T>($base: SourceType<T>, stateless = false) {\n  return new SharedSourceEvent<T>($base, stateless);\n}\n\nexport class SharedSourceEvent<T> implements SourceType<T> {\n  private $sharedBase: SourceType<T> & { touched: () => void };\n\n  public constructor(\n    private $base: SourceType<T>,\n    stateless = false,\n  ) {\n    this.$sharedBase = Shared(this.$base, stateless);\n  }\n\n  public event(transport: TransportType<T>) {\n    this.$sharedBase.event(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.$sharedBase.touched();\n    this.$base.use(value);\n    return this;\n  }\n}\n","import { Transport } from \"base/Transport\";\nimport { EventType } from \"types/EventType\";\n\n/**\n * Helps represent an event as a primitive type, which can be useful\n * for cases when you need to always have a reference to the current value\n * without updating the shared value when the current one changes.\n * For example, this could be used when passing an authorization token.\n * It can also be useful for testing or logging purposes.\n */\nexport function Primitive<T>($base: EventType<T>, theValue: T | null = null) {\n  return new PrimitiveImpl<T>($base, theValue);\n}\n\nexport class PrimitiveImpl<T> {\n  private touched = false;\n\n  public constructor(\n    private $base: EventType<T>,\n    private theValue: T | null = null,\n  ) {}\n\n  private ensureTouched() {\n    if (!this.touched) {\n      this.$base.event(\n        Transport((v) => {\n          this.theValue = v;\n        }),\n      );\n    }\n    this.touched = true;\n  }\n\n  public [Symbol.toPrimitive]() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitive() {\n    this.ensureTouched();\n    return this.theValue;\n  }\n\n  public primitiveWithException() {\n    this.ensureTouched();\n    if (this.theValue === null) {\n      throw new Error(\"Primitive value is null\");\n    }\n    return this.theValue;\n  }\n}\n","import { SourceType } from \"types/SourceType\";\nimport { Late } from \"components/Late\";\nimport { SharedSource } from \"components/SharedSource\";\nimport { TransportType } from \"types/TransportType\";\nimport { Primitive, PrimitiveImpl } from \"components/Primitive\";\n\n/**\n * An event with a value that will be set later,\n * capable of responding to different transports\n */\nexport function LateShared<T>(value?: T) {\n  return new LateSharedEvent<T>(value);\n}\n\nexport class LateSharedEvent<T> implements SourceType<T> {\n  private $event: SourceType<T>;\n  private primitive: PrimitiveImpl<T>;\n\n  public constructor(value?: T) {\n    this.$event = SharedSource(Late(value));\n    this.primitive = Primitive(this, value);\n  }\n\n  public event(transport: TransportType<T>) {\n    this.$event.event(transport);\n    return this;\n  }\n\n  public use(value: T) {\n    this.$event.use(value);\n    return this;\n  }\n\n  public value() {\n    return this.primitive;\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { All } from \"components/All\";\nimport { TransportType } from \"types/TransportType\";\nimport { isEvent } from \"helpers/guards\";\nimport { TransportParent } from \"base/Transport\";\nimport { Of } from \"base/Of\";\n\n/**\n * Component that applies an info object constructor to each data item,\n * producing an information source with new values\n */\nexport function Map<T, TG>(\n  $base: EventType<T[]>,\n  $target: TransportType<any, EventType<TG>>,\n) {\n  return new MapEvent<T, TG>($base, $target);\n}\n\nexport class MapEvent<T, TG> implements EventType<TG[]> {\n  public constructor(\n    private $base: EventType<T[]>,\n    private $target: TransportType<any, EventType<TG>>,\n  ) {}\n\n  public event(transport: TransportType<TG[]>): this {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T[]>(function (v, child) {\n    const infos: EventType<TG>[] = [];\n    v.forEach((val) => {\n      let $val: EventType<T> | T = val;\n      if (!isEvent($val as object)) {\n        $val = Of($val);\n      }\n      const info = child.$target.use($val);\n      infos.push(info);\n    });\n    All(...infos).event(this);\n  }, this);\n}\n","import { Transport } from \"base/Transport\";\nimport { LateShared } from \"components/LateShared\";\nimport { EventType } from \"types/EventType\";\nimport { RPCType } from \"types/RPCType\";\nimport { TransportType } from \"types/TransportType\";\n\ninterface RPCImplType<T> {\n  result(): EventType<T>;\n  error(): EventType<Error | string>;\n}\n\n/**\n * The ability to call an external system through\n * sending a message in a standardized format\n * RPCType, the list of transports should be defined via\n * the RPC.transport object\n */\nexport function RPC<T>($rpc: EventType<RPCType>): RPCImplType<T> {\n  return new RPCImpl($rpc);\n}\n\nRPC.transport = {} as { default: TransportType<RPCType> } & Record<\n  string,\n  TransportType<RPCType>\n>;\n\nexport class RPCImpl {\n  private $result = LateShared();\n  private $error = LateShared();\n\n  public constructor(private $rpc: EventType<RPCType>) {}\n\n  public result() {\n    this.$rpc.event(\n      Transport((rpc) => {\n        const transport =\n          rpc.transport === undefined\n            ? RPC.transport.default\n            : RPC.transport[rpc.transport] || RPC.transport.default;\n        if (!transport) {\n          throw new Error(`RPCImpl: Transport not found ${rpc.transport}`);\n        }\n        if (!rpc.result) {\n          rpc.result = this.$result;\n        }\n        if (!rpc.error) {\n          rpc.error = this.$error;\n        }\n        transport.use(rpc);\n      }),\n    );\n    return this.$result;\n  }\n\n  public error() {\n    return this.$error;\n  }\n}\n","import { Event } from \"base/Event\";\nimport { LateShared } from \"components/LateShared\";\nimport { RPC } from \"components/RPC\";\nimport { RPCType } from \"types/RPCType\";\n\n/**\n * Event for the arrival of a specific RPC message\n * for specific transport\n */\nexport function RPCOf(transport: string) {\n  const $transport = LateShared<RPCType>();\n  RPC.transport[transport] = $transport;\n  return Event<RPCType>((transport) => {\n    $transport.event(transport);\n  });\n}\n","import { TransportParent } from \"base/Transport\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a sequence that accumulates all values from the source into an array,\n * emitting the growing array with each new value.\n */\nexport function Sequence<T>($base: EventType<T>) {\n  return new SequenceEvent<T>($base);\n}\n\nexport class SequenceEvent<T> implements EventType<T[]> {\n  private result: T[] = [];\n\n  public constructor(private $base: EventType<T>) {}\n\n  public event(transport: TransportType<T[]>): this {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T>(function (v, child) {\n    child.result.push(v);\n    this.use(child.result);\n  }, this);\n}\n","import { TransportParent } from \"base/Transport\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Component that receives a data array and yields values one by one\n */\nexport function Stream<T>($base: EventType<T[]>) {\n  return new StreamEvent<T>($base);\n}\n\nexport class StreamEvent<T> implements EventType<T> {\n  public constructor(private $base: EventType<T[]>) {}\n\n  public event(transport: TransportType<T>): this {\n    this.$base.event(this.parent.child(transport));\n    return this;\n  }\n\n  private parent = TransportParent<T[]>(function (v) {\n    v.forEach((cv) => {\n      this.use(cv);\n    });\n  });\n}\n","import { ConstructorType } from \"types/ConstructorType\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a transport that applies a constructor to the result of another transport.\n */\nexport function TransportApplied<T>(\n  baseTransport: TransportType<any, EventType<T>>,\n  applier: ConstructorType<[EventType], EventType<T>>,\n) {\n  return new TransportAppliedImpl(baseTransport, applier);\n}\n\nexport class TransportAppliedImpl<T>\n  implements TransportType<unknown, EventType<T>>\n{\n  public constructor(\n    private baseTransport: TransportType<any, EventType<T>>,\n    private applier: ConstructorType<[EventType], EventType<T>>,\n  ) {}\n\n  public use(args: unknown) {\n    return this.applier(this.baseTransport.use(args));\n  }\n}\n","import { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a transport that merges additional arguments into the base transport's arguments\n * at a specified index position, allowing for flexible argument composition\n */\nexport function TransportArgs(\n  baseTransport: TransportType<any[], EventType>,\n  args: unknown[],\n  startFromArgIndex: number = 0,\n) {\n  return new TransportArgsImpl(baseTransport, args, startFromArgIndex);\n}\n\nexport class TransportArgsImpl\n  implements TransportType<unknown[], EventType<unknown>>\n{\n  public constructor(\n    private baseTransport: TransportType<any[], EventType>,\n    private args: unknown[],\n    private startFromArgIndex: number = 0,\n  ) {}\n\n  public use(runArgs: unknown[]): EventType<unknown> {\n    return this.baseTransport.use(\n      mergeAtIndex(runArgs, this.args, this.startFromArgIndex),\n    );\n  }\n}\n\nfunction mergeAtIndex(arr1: unknown[], arr2: unknown[], index: number) {\n  const result = arr1.slice(0, index);\n  while (result.length < index) result.push(undefined);\n  return result.concat(arr2);\n}\n","import { isDestroyable } from \"helpers/guards\";\nimport { DestroyableType } from \"types/DestroyableType\";\nimport { EventType } from \"types/EventType\";\nimport { TransportType } from \"types/TransportType\";\n\n/**\n * Creates a transport wrapper that automatically manages destruction of created instances\n */\nexport function TransportDestroyable<T>(\n  baseTransport: TransportType<any[], EventType<T>>,\n) {\n  return new TransportDestroyableEvent<T>(baseTransport);\n}\n\nexport class TransportDestroyableEvent<T>\n  implements TransportType<unknown, EventType<T>>, DestroyableType\n{\n  private destructors: DestroyableType[] = [];\n\n  public constructor(\n    private baseTransport: TransportType<any[], EventType<T>>,\n  ) {}\n\n  public use(args: any[]) {\n    const inst = this.baseTransport.use(args);\n    if (isDestroyable(inst)) {\n      this.destructors.push(inst);\n    }\n    return inst;\n  }\n\n  public destroy(): this {\n    this.destructors.forEach((i) => i.destroy());\n    return this;\n  }\n}\n"],"names":["Component","executor","args","destructor","event","transport","call","this","destroy","ComponentClass","classConstructor","isFilled","value","isEvent","o","isDestroyable","isDestroyed","isTransport","use","Destroyable","base","DestroyableImpl","constructor","DestroyContainer","DestroyContainerImpl","__publicField","add","e","destructors","push","forEach","d","length","ensureFunction","v","label","Error","ensureEvent","ensureTransport","Event","eventExecutor","EventImpl","mbDestructor","Transport","transportExecutor","TransportImpl","TransportEvent","TransportEventImpl","TransportParent","TransportParentImpl","_child","child","Local","$base","LocalEvent","destroyed","New","construct","Of","OfEvent","TransportOptional","TransportOptionalImpl","wait","Void","VoidImpl","All","events","AllEvent","Set","key","keysFilled","keysKnown","filled","result","parseInt","known","size","Object","keys","$events","entries","Any","AnyEvent","Applied","applier","AppliedEvent","AppliedDestructured","Catch","errorMessage","errorOriginal","CatchEvent","message","String","Chain","ChainEvent","index","next","oneEventTransport","$latest","handleEvent","ExecutorApplied","ExecutorAppliedEvent","ExecutorAppliedBaseTransport","bind","Filtered","predicate","defaultValue","FilteredEvent","parent","FromEvent","$emitter","$eventName","$subscribeMethod","$unsubscribeMethod","FromEventAdapter","lastTransport","emitter","eventName","subscribe","handler","unsubscribe","FromPromise","p","error","FromPromiseEvent","then","catch","Late","LateEvent","lateTransport","notify","Once","OnceEvent","TransportPool","transports","innerTransport","delete","has","owner","remove","g","Shared","stateless","SharedEvent","lastValue","transportPool","calls","firstCallTransport","touched","pool","SharedSource","SharedSourceEvent","$sharedBase","Primitive","theValue","PrimitiveImpl","ensureTouched","Symbol","toPrimitive","primitive","primitiveWithException","LateShared","LateSharedEvent","$event","Map","$target","MapEvent","infos","val","$val","info","RPC","$rpc","RPCImpl","rpc","default","$result","$error","RPCOf","$transport","Sequence","SequenceEvent","Stream","StreamEvent","cv","TransportApplied","baseTransport","TransportAppliedImpl","TransportArgs","startFromArgIndex","TransportArgsImpl","runArgs","arr1","arr2","slice","concat","mergeAtIndex","TransportDestroyable","TransportDestroyableEvent","inst","i"],"mappings":"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"}