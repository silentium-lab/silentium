{"version":3,"file":"silentium.min.mjs","sources":["../src/components/All.ts","../src/components/Any.ts","../src/components/Applied.ts","../src/components/Chain.ts","../src/components/ExecutorApplied.ts","../src/components/Filtered.ts","../src/components/FromEvent.ts","../src/components/FromPromise.ts","../src/helpers/isFilled.ts","../src/helpers/OwnerPool.ts","../src/components/Late.ts","../src/components/Once.ts","../src/components/Shared.ts","../src/components/SharedSource.ts","../src/components/LateShared.ts","../src/components/LazyApplied.ts","../src/components/LazyArgs.ts","../src/components/LazyDestroyable.ts","../src/base/Destructor.ts","../src/base/Local.ts","../src/base/Of.ts","../src/base/On.ts","../src/base/Void.ts","../src/components/Map.ts","../src/components/PrimitiveSource.ts","../src/components/Sequence.ts","../src/components/Stream.ts"],"sourcesContent":["import { DataType } from \"../types\";\n\ntype ExtractTypeS<T> = T extends DataType<infer U> ? U : never;\n\nexport type ExtractTypesFromArrayS<T extends DataType<any>[]> = {\n  [K in keyof T]: ExtractTypeS<T[K]>;\n};\n\nconst isAllFilled = (keysFilled: Set<string>, keysKnown: Set<string>) => {\n  return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n};\n\n/**\n * Combines multiple information sources into a single unified source\n * represented as an array containing values from all sources\n * https://silentium-lab.github.io/silentium/#/en/information/all\n */\nexport const all = <const T extends DataType[]>(\n  ...theInfos: T\n): DataType<ExtractTypesFromArrayS<T>> => {\n  const keysKnown = new Set<string>(Object.keys(theInfos));\n  const keysFilled = new Set<string>();\n\n  return function AllData(u) {\n    const result: Record<string, unknown> = {};\n\n    Object.entries(theInfos).forEach(([key, info]) => {\n      keysKnown.add(key);\n      info(function AllItemUser(v) {\n        keysFilled.add(key);\n        result[key] = v;\n        if (isAllFilled(keysFilled, keysKnown)) {\n          u(Object.values(result) as ExtractTypesFromArrayS<T>);\n        }\n      });\n    });\n  };\n};\n","import { DataType } from \"../types\";\n\n/**\n * From a set of information sources we get\n * a common response from any source for a single owner\n * https://silentium-lab.github.io/silentium/#/en/information/any\n */\nexport const any = <T>(...infos: DataType<T>[]): DataType<T> => {\n  return function AnyData(u) {\n    infos.forEach((info) => {\n      info(u);\n    });\n  };\n};\n","import { DataType, ValueType } from \"../types\";\n\n/**\n * Information to which the function was applied to change the value\n * https://silentium-lab.github.io/silentium/#/en/information/applied\n */\nexport const applied = <T, R>(\n  baseSrc: DataType<T>,\n  applier: ValueType<[T], R>,\n): DataType<R> => {\n  return function AppliedData(u) {\n    baseSrc(function AppliedBaseUser(v) {\n      u(applier(v));\n    });\n  };\n};\n","import { DataTypeValue } from \"../types/DataType\";\nimport { DataType } from \"../types\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends any[]> = T extends [...infer _, infer L] ? L : never;\n\n/**\n * The set of information sources forms a sequential chain where each source provides\n * an answer. The final answer will be the output result. If any source in the chain\n * provides a new answer, the component's overall response will be repeated.\n * https://silentium-lab.github.io/silentium/#/en/information/applied\n */\nexport const chain = <T extends DataType[]>(...infos: T): Last<T> => {\n  return <Last<T>>function ChainData(u) {\n    let lastValue: DataTypeValue<Last<T>> | undefined;\n\n    const handleI = (index: number) => {\n      const info = infos[index] as Last<T>;\n      const nextI = infos[index + 1] as Last<T> | undefined;\n\n      info(function ChainItemUser(v) {\n        if (!nextI) {\n          lastValue = v as DataTypeValue<Last<T>>;\n        }\n\n        if (lastValue) {\n          u(lastValue);\n        }\n\n        if (nextI && !lastValue) {\n          handleI(index + 1);\n        }\n      });\n    };\n\n    handleI(0);\n  };\n};\n","import { DataType, DataUserType } from \"../types\";\n\n/**\n * Information to which a function is applied in order\n * to control the value passing process\n * https://silentium-lab.github.io/silentium/#/en/information/applied\n */\nexport const executorApplied = <T>(\n  baseSrc: DataType<T>,\n  applier: (executor: DataUserType<T>) => DataUserType<T>,\n): DataType<T> => {\n  return function ExecutorAppliedData(u) {\n    const ExecutorAppliedBaseUser = applier(u);\n    baseSrc(ExecutorAppliedBaseUser);\n  };\n};\n","import { DataType, ValueType } from \"../types\";\n\n/**\n * Information whose value is being validated\n * via a predicate; if the predicate returns true, the value\n * can be passed to the output\n * https://silentium-lab.github.io/silentium/#/en/information/filtered\n */\nexport const filtered = <T>(\n  baseSrc: DataType<T>,\n  predicate: ValueType<[T], boolean>,\n  defaultValue?: T,\n): DataType<T> => {\n  return function FilteredData(u) {\n    baseSrc(function FilteredBaseUser(v) {\n      if (predicate(v)) {\n        u(v);\n      } else if (defaultValue !== undefined) {\n        u(defaultValue);\n      }\n    });\n  };\n};\n","import { DataTypeDestroyable } from \"src/types/DataType\";\nimport { DataType, DataUserType } from \"../types\";\nimport { all } from \"./All\";\n\n/**\n * A component that receives data from an event and\n * presents it as an information object\n * https://silentium-lab.github.io/silentium/#/en/information/from-event\n */\nexport const fromEvent = <T>(\n  emitterSrc: DataType<any>,\n  eventNameSrc: DataType<string>,\n  subscribeMethodSrc: DataType<string>,\n  unsubscribeMethodSrc?: DataType<string>,\n): DataTypeDestroyable<T> => {\n  let lastU: DataUserType<T> | null = null;\n  const handler = function FromEventHandler(v: T) {\n    if (lastU) {\n      lastU(v);\n    }\n  };\n  return function FromEventData(u) {\n    lastU = u;\n    const a = all(emitterSrc, eventNameSrc, subscribeMethodSrc);\n    a(function FromEventAllUser([emitter, eventName, subscribe]) {\n      if (!emitter?.[subscribe]) {\n        return;\n      }\n      emitter[subscribe](eventName, handler);\n    });\n\n    return function FromEventDestructor() {\n      lastU = null;\n      if (!unsubscribeMethodSrc) {\n        return;\n      }\n      const a = all(emitterSrc, eventNameSrc, unsubscribeMethodSrc);\n      a(([emitter, eventName, unsubscribe]) => {\n        emitter?.[unsubscribe]?.(eventName, handler);\n      });\n    };\n  };\n};\n","import { DataType, DataUserType } from \"../types\";\n\n/**\n * Component that gets a value from a promise and\n * presents it as information\n * https://silentium-lab.github.io/silentium/#/en/information/from-promise\n */\nexport const fromPromise = <T>(\n  p: Promise<T>,\n  errorOwner?: DataUserType,\n): DataType<T> => {\n  return function FromPromiseData(u) {\n    p.then(function FromPromiseThen(v) {\n      u(v);\n    }).catch(function FromPromiseCatch(e) {\n      errorOwner?.(e);\n    });\n  };\n};\n","export const isFilled = <T>(\n  value?: T,\n): value is Exclude<T, null | undefined> => {\n  return value !== undefined && value !== null;\n};\n","import { DataUserType } from \"../types\";\n\n/**\n * Helps maintain an owner list allowing different\n * owners to get information from a common source\n * https://silentium-lab.github.io/silentium/#/en/utils/owner-pool\n */\nexport class OwnerPool<T> {\n  private owners: Set<DataUserType<T>>;\n  private innerOwner: DataUserType<T>;\n\n  public constructor() {\n    this.owners = new Set<DataUserType<T>>();\n    this.innerOwner = (v) => {\n      this.owners.forEach((g) => {\n        g(v);\n      });\n    };\n  }\n\n  public owner() {\n    return this.innerOwner;\n  }\n\n  public size(): number {\n    return this.owners.size;\n  }\n\n  public has(owner: DataUserType<T>): boolean {\n    return this.owners.has(owner);\n  }\n\n  public add(owner: DataUserType<T>) {\n    this.owners.add(owner);\n    return this;\n  }\n\n  public remove(g: DataUserType<T>) {\n    this.owners.delete(g);\n    return this;\n  }\n\n  public destroy() {\n    this.owners.forEach((g) => {\n      this.remove(g);\n    });\n    return this;\n  }\n}\n","import { DataUserType, SourceType } from \"../types\";\nimport { isFilled } from \"../helpers\";\n\n/**\n * A component that allows creating linked objects of information and its owner\n * in such a way that if a new value is assigned to the owner, this value\n * will become the value of the linked information source\n * https://silentium-lab.github.io/silentium/#/en/information/of\n */\nexport const late = <T>(v?: T): SourceType<T> => {\n  let lateUser: DataUserType<T> | null = null;\n  const notify = (v?: T) => {\n    if (isFilled(v) && lateUser) {\n      lateUser(v);\n    }\n  };\n\n  return {\n    value: function Late(u) {\n      if (lateUser) {\n        throw new Error(\n          \"Late component gets new user, when another was already connected!\",\n        );\n      }\n\n      lateUser = u;\n      notify(v);\n    },\n    give: function LateUser(v) {\n      notify(v);\n    },\n  };\n};\n","import { DataType } from \"../types\";\n\n/**\n * Limits the number of values from the information source\n * to a single value - once the first value is emitted, no more\n * values are delivered from the source\n * https://silentium-lab.github.io/silentium/#/en/information/once\n */\nexport const once = <T>(baseSrc: DataType<T>): DataType<T> => {\n  return function OnceData(u) {\n    let isFilled = false;\n    baseSrc(function OnceBaseUser(v) {\n      if (!isFilled) {\n        isFilled = true;\n        u(v);\n      }\n    });\n  };\n};\n","import { DataType, DestroyableType, SourceType } from \"../types\";\nimport { isFilled, OwnerPool } from \"../helpers\";\nimport { late } from \"../components/Late\";\nimport { once } from \"../components/Once\";\n\n/**\n * An information object that helps multiple owners access\n * a single another information object\n * https://silentium-lab.github.io/silentium/#/en/information/pool\n */\nexport const shared = <T>(\n  baseSrc: DataType<T>,\n  stateless = false,\n): SourceType<T> & {\n  pool: () => OwnerPool<T>;\n  touched: () => void;\n} & DestroyableType => {\n  const ownersPool = new OwnerPool<T>();\n  let lastValue: T | undefined;\n\n  const calls = late();\n  once(calls.value)(function SharedCallsUser() {\n    baseSrc(function SharedBaseUser(v) {\n      lastValue = v;\n      ownersPool.owner()(v);\n    });\n  });\n\n  return {\n    value: function Shared(u) {\n      calls.give(1);\n      if (!stateless && isFilled(lastValue) && !ownersPool.has(u)) {\n        u(lastValue);\n      }\n      ownersPool.add(u);\n      return () => {\n        ownersPool.remove(u);\n      };\n    },\n    give: function SharedUser(value: T) {\n      calls.give(1);\n      lastValue = value;\n      ownersPool.owner()(value);\n    },\n    touched() {\n      calls.give(1);\n    },\n    pool() {\n      return ownersPool;\n    },\n    destroy() {\n      ownersPool.destroy();\n    },\n  };\n};\n","import { SourceType } from \"../types\";\nimport { shared } from \"../components/Shared\";\n\nexport const sharedSource = <T>(\n  baseSrc: SourceType<T>,\n  stateless = false,\n): SourceType<T> => {\n  const sharedSrc = shared(baseSrc.value, stateless);\n\n  return {\n    value: function SharedSource(u) {\n      sharedSrc.value(u);\n    },\n    give: function SharedSourceUser(v) {\n      sharedSrc.touched();\n      baseSrc.give(v);\n    },\n  };\n};\n","import { late } from \"../components/Late\";\nimport { sharedSource } from \"../components/SharedSource\";\nimport { SourceType } from \"../types\";\n\nexport const lateShared = <T>(theValue?: T): SourceType<T> => {\n  const src = sharedSource(late(theValue));\n  return {\n    value: src.value,\n    give: src.give,\n  };\n};\n","import { DataType, ValueType } from \"../types\";\n\n/**\n * Lazy with applied function to its results\n */\nexport const lazyApplied = <T>(\n  baseLazy: ValueType<any[], DataType>,\n  applier: (i: DataType) => DataType<T>,\n): ValueType<DataType[], DataType<T>> => {\n  return function LazyAppliedData(...args) {\n    return applier(baseLazy(...args));\n  };\n};\n","import { DataType, ValueType } from \"../types\";\n\nexport const lazyArgs = (\n  baseLazy: ValueType<any[], DataType>,\n  args: unknown[],\n  startFromArgIndex: number = 0,\n) => {\n  return function LazyArgsData(...runArgs: any[]) {\n    return baseLazy(...mergeAtIndex(runArgs, args, startFromArgIndex));\n  };\n};\n\nfunction mergeAtIndex(arr1: unknown[], arr2: unknown[], index: number) {\n  const result = arr1.slice(0, index);\n  while (result.length < index) result.push(undefined);\n  return result.concat(arr2);\n}\n","import { DestroyableType, DestructorType, ValueType } from \"../types\";\n\n/**\n * Lazy what can be destroyed\n */\nexport const lazyDestroyable = (\n  baseLazy: ValueType<any[], DestroyableType>,\n): { get: ValueType<any[], DestroyableType>; destroy: DestructorType } => {\n  const instances: DestroyableType[] = [];\n  return {\n    get: function lazyDestroyable(...args) {\n      const inst = baseLazy(...args);\n      instances.push(inst);\n      return inst;\n    },\n    destroy: function LazyDestructor() {\n      instances.forEach((i) => i.destroy());\n    },\n  };\n};\n","import { DataType, DataUserType, DestructorType } from \"../types\";\n\nexport const destructor = <T>(\n  src: DataType<T>,\n  destructorUser?: DataUserType<DestructorType>,\n) => {\n  let mbDestructor: DestructorType | void;\n  let theUser: DataUserType<T> | null = null;\n  const destroy = () => {\n    theUser = null;\n    mbDestructor?.();\n  };\n  return {\n    value: function DestructorData(u: any) {\n      theUser = u;\n      mbDestructor = src((v) => {\n        if (theUser) {\n          theUser(v);\n        }\n      });\n      if (mbDestructor && destructorUser) {\n        destructorUser(destroy);\n      }\n      return destroy;\n    } as DataType<T>,\n    destroy,\n  };\n};\n","import { DataType } from \"../types\";\n\n/**\n * Create local copy of source what can be destroyed\n */\nexport const local = <T>(baseSrc: DataType<T>): DataType<T> => {\n  return function LocalData(user) {\n    let destroyed = false;\n    const d = baseSrc(function LocalBaseUser(v) {\n      if (!destroyed) {\n        user(v);\n      }\n    });\n    return () => {\n      destroyed = true;\n      d?.();\n    };\n  };\n};\n","import { DataType } from \"../types\";\n\nexport const of = <T>(v: T): DataType<T> =>\n  function OfData(u) {\n    return u(v);\n  };\n","import { DataType, DataUserType } from \"../types\";\n\n/**\n * Run data with user\n */\nexport const on = <T>(src: DataType<T>, user: DataUserType<T>) => src(user);\n","import { DataUserType } from \"../types\";\n\n/**\n * Silent user\n */\nexport const _void = (): DataUserType => function VoidData() {};\n","import { DataType, ValueType } from \"../types\";\nimport { of } from \"../base\";\nimport { all } from \"./All\";\n\n/**\n * Component that applies an info object constructor to each data item,\n * producing an information source with new values\n * https://silentium-lab.github.io/silentium/#/en/information/map\n */\nexport const map = <T, TG>(\n  baseSrc: DataType<T[]>,\n  targetSrc: ValueType<any[], DataType<TG>>,\n): DataType<TG[]> => {\n  return function MapData(u) {\n    baseSrc(function MapBaseUser(v) {\n      const infos: DataType<TG>[] = [];\n      v.forEach((val) => {\n        let valInfo: DataType<T> | T = val;\n        if (typeof valInfo !== \"function\") {\n          valInfo = of(valInfo);\n        }\n        const info = targetSrc(valInfo);\n        infos.push(info);\n      });\n      const allI = all(...infos);\n      allI(u);\n    });\n  };\n};\n","import { DataType } from \"../types\";\n\nexport const primitive = <T>(\n  baseSrc: DataType<T>,\n  theValue: T | null = null,\n) => {\n  baseSrc(function PrimitiveBaseUser(v) {\n    theValue = v;\n  });\n\n  return {\n    [Symbol.toPrimitive]() {\n      return theValue;\n    },\n    primitive() {\n      return theValue;\n    },\n    primitiveWithException() {\n      if (theValue === null) {\n        throw new Error(\"Primitive value is null\");\n      }\n      return theValue;\n    },\n  };\n};\n","import { DataType } from \"../types\";\n\n/**\n * A component that takes one value at a time and returns\n * an array of all previous values\n * https://silentium-lab.github.io/silentium/#/en/information/sequence\n */\nexport const sequence = <T>(baseSrc: DataType<T>): DataType<T[]> => {\n  return function SequenceData(u) {\n    const result: T[] = [];\n    baseSrc(function SequenceBaseUser(v) {\n      result.push(v);\n      u(result);\n    });\n  };\n};\n","import { DataType } from \"../types\";\n\n/**\n * Component that receives a data array and yields values one by one\n * https://silentium-lab.github.io/silentium/#/en/information/stream\n */\nexport const stream = <T>(baseSrc: DataType<T[]>): DataType<T> => {\n  return function StreamData(u) {\n    baseSrc(function StreamBaseUser(v) {\n      v.forEach((cv) => {\n        u(cv);\n      });\n    });\n  };\n};\n"],"names":["all","theInfos","keysKnown","Set","Object","keys","keysFilled","u","result","entries","forEach","key","info","add","v","size","isAllFilled","values","any","infos","applied","baseSrc","applier","chain","lastValue","handleI","index","nextI","executorApplied","ExecutorAppliedBaseUser","filtered","predicate","defaultValue","fromEvent","emitterSrc","eventNameSrc","subscribeMethodSrc","unsubscribeMethodSrc","lastU","handler","a","emitter","eventName","subscribe","unsubscribe","fromPromise","p","errorOwner","then","catch","e","isFilled","value","OwnerPool","constructor","__publicField","this","owners","innerOwner","g","owner","has","remove","delete","destroy","late","lateUser","notify","Error","give","once","shared","stateless","ownersPool","calls","touched","pool","sharedSource","sharedSrc","lateShared","theValue","src","lazyApplied","baseLazy","args","lazyArgs","startFromArgIndex","runArgs","arr1","arr2","slice","length","push","concat","mergeAtIndex","lazyDestroyable","instances","get","inst","i","destructor","destructorUser","mbDestructor","theUser","local","user","destroyed","d","of","on","_void","map","targetSrc","val","valInfo","allI","primitive","Symbol","toPrimitive","primitiveWithException","sequence","stream","cv"],"mappings":"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"}