{"version":3,"file":"silentium.min.mjs","sources":["../src/Source/Source.ts","../src/Guest/Guest.ts","../src/Guest/GuestCast.ts","../src/Guest/GuestSync.ts","../src/Guest/GuestDisposable.ts","../src/Guest/GuestApplied.ts","../src/Guest/GuestExecutorApplied.ts","../src/Patron/Patron.ts","../src/Patron/PatronOnce.ts","../src/Patron/PatronPool.ts","../src/Patron/PatronApplied.ts","../src/Patron/PatronExecutorApplied.ts","../src/Source/SourceSync.ts","../src/Source/SourceChangeable.ts","../src/Source/SourceAll.ts","../src/Source/SourceSequence.ts","../src/Source/SourceMap.ts","../src/Source/SourceRace.ts","../src/Source/SourceChain.ts","../src/Source/SourceDynamic.ts","../src/Source/SourceApplied.ts","../src/Source/SourceExecutorApplied.ts","../src/Source/SourceFiltered.ts","../src/Source/SourceOnce.ts","../src/Source/SourceCombined.ts","../src/Source/SourceResettable.ts","../src/Source/SourceAny.ts","../src/Source/SourceLazy.ts","../src/Lazy/LazyClass.ts","../src/Lazy/Lazy.ts"],"sourcesContent":["import { give, GuestType } from \"../Guest/Guest\";\n\nexport type SourceExecutorType<T> = (guest: GuestType<T>) => unknown;\n\nexport interface SourceObjectType<T> {\n  value: SourceExecutorType<T>;\n}\n\nexport type SourceDataType<T> = Extract<\n  T,\n  string | number | boolean | Date | object | Array<unknown> | symbol\n>;\n\nexport type SourceType<T = any> =\n  | SourceExecutorType<T>\n  | SourceObjectType<T>\n  | SourceDataType<T>;\n\n/**\n * Helps to connect source and guest, if you need to get value in guest from source\n * helpful because we don't know what shape of source do we have, it can be function or object or primitive\n * @url https://silentium-lab.github.io/silentium/#/utils/value\n */\nexport const value = <T>(source: SourceType<T>, guest: GuestType<T>) => {\n  if (source === undefined || source === null) {\n    throw new Error(\"value didn't receive source argument\");\n  }\n  if (guest === undefined || source === null) {\n    throw new Error(\"value didn't receive guest argument\");\n  }\n  if (typeof source === \"function\") {\n    source(guest);\n  } else if (\n    typeof source === \"object\" &&\n    \"value\" in source &&\n    typeof source.value === \"function\"\n  ) {\n    source.value(guest);\n  } else {\n    give(source as T, guest);\n  }\n\n  return source;\n};\n\n/**\n * Helps to check what some information is of source shape\n * @url https://silentium-lab.github.io/silentium/#/utils/is-source\n */\nexport const isSource = <T>(\n  mbSource: T | SourceType<T>,\n): mbSource is SourceType<T> => {\n  if (\n    mbSource !== null &&\n    typeof mbSource === \"object\" &&\n    \"value\" in mbSource &&\n    typeof mbSource.value === \"function\"\n  ) {\n    return true;\n  }\n  return mbSource !== null && mbSource !== undefined;\n};\n\n/**\n * Represents source as function\n * @url https://silentium-lab.github.io/silentium/#/source\n */\nexport const source = <T>(source: SourceType<T>): SourceExecutorType<T> => {\n  if (source === undefined) {\n    throw new Error(\"Source constructor didn't receive executor function\");\n  }\n\n  return (guest: GuestType<T>) => {\n    value(source, guest);\n  };\n};\n","import { source, SourceExecutorType, SourceType } from \"../Source/Source\";\n\ntype GuestIntroduction = \"guest\" | \"patron\";\n\nexport type GuestExecutorType<T = any, This = void> = (value: T) => This;\n\nexport interface GuestObjectType<T = any> {\n  give(value: T): this;\n  introduction?(): GuestIntroduction;\n}\n\nexport type GuestType<T = any> = GuestExecutorType<T> | GuestObjectType<T>;\n\n/**\n * Helps to give data to guest, guests can be of different shapes\n * function guest or object guest\n * @url https://silentium-lab.github.io/silentium/#/utils/give\n */\nexport const give = <T>(\n  data: T,\n  guest?: GuestType<T>,\n): GuestType<T> | SourceExecutorType<T> => {\n  if (data === undefined) {\n    throw new Error(\"give didn't receive data argument\");\n  }\n  if (guest === undefined) {\n    return source<T>(data as SourceType<T>) as SourceExecutorType<T>;\n  }\n  if (typeof guest === \"function\") {\n    guest(data);\n  } else {\n    guest.give(data);\n  }\n  return guest;\n};\n\n/**\n * Helps to check if mbGuest can be used to retrieve value\n * @url https://silentium-lab.github.io/silentium/#/utils/is-guest\n */\nexport const isGuest = (mbGuest: any): mbGuest is GuestType => {\n  if (mbGuest === undefined) {\n    throw new Error(\"isGuest didnt receive mbGuest argument\");\n  }\n  return typeof mbGuest === \"function\" || typeof mbGuest?.give === \"function\";\n};\n\n/**\n * Helps to create guest of object type\n * @url https://silentium-lab.github.io/silentium/#/guest\n */\nexport const guest = <T>(receiver: GuestExecutorType<T>) => {\n  if (!receiver) {\n    throw new Error(\"receiver function was not passed to Guest constructor\");\n  }\n  const result = {\n    give(value: T) {\n      receiver(value);\n      return result;\n    },\n  };\n  return result;\n};\n","import { give, GuestType } from \"./Guest\";\nimport { GuestDisposableType, MaybeDisposableType } from \"./GuestDisposable\";\n\n/**\n * Helps to inherit guest behavior, its introduction and dispose settings\n * @url https://silentium-lab.github.io/silentium/#/guest/guest-cast\n */\nexport const guestCast = <T>(\n  sourceGuest: GuestType<any>,\n  targetGuest: GuestType<T>,\n): GuestDisposableType<T> => {\n  if (sourceGuest === undefined) {\n    throw new Error(\"GuestCast didn't receive sourceGuest argument\");\n  }\n  if (targetGuest === undefined) {\n    throw new Error(\"GuestCast didn't receive targetGuest argument\");\n  }\n\n  const result = {\n    disposed(value: T | null): boolean {\n      const maybeDisposable = sourceGuest as MaybeDisposableType;\n      return maybeDisposable.disposed ? maybeDisposable.disposed(value) : false;\n    },\n    give(value: T) {\n      give(value, targetGuest);\n      return result;\n    },\n    introduction() {\n      if (typeof sourceGuest === \"function\") {\n        return \"guest\";\n      }\n      if (!sourceGuest.introduction) {\n        return \"guest\";\n      }\n      return sourceGuest.introduction();\n    },\n  };\n\n  return result;\n};\n","import { GuestObjectType } from \"./Guest\";\n\nexport interface GuestValueType<T = any> extends GuestObjectType<T> {\n  value(): T;\n}\n\n/**\n * @url https://silentium-lab.github.io/silentium/#/guest/guest-sync\n */\nexport const guestSync = <T>(theValue?: T): GuestValueType<T> => {\n  const result = {\n    give(value: T) {\n      theValue = value;\n      return result;\n    },\n    value() {\n      if (theValue === undefined) {\n        throw new Error(\"no value in GuestSync!\");\n      }\n      return theValue;\n    },\n  };\n\n  return result;\n};\n","import { give, GuestObjectType, GuestType } from \"./Guest\";\n\nexport interface GuestDisposableType<T = any> extends GuestObjectType<T> {\n  disposed(value: T | null): boolean;\n}\n\nexport type MaybeDisposableType<T = any> = Partial<GuestDisposableType<T>>;\n\n/**\n * Connects to guest logic what can tell PatronPool\n * what guest don't need to receive new values\n * @url https://silentium-lab.github.io/silentium/#/guest/guest-disposable\n */\nexport const guestDisposable = <T>(\n  guest: GuestType,\n  disposeCheck: (value: T | null) => boolean,\n): GuestDisposableType<T> => {\n  if (guest === undefined) {\n    throw new Error(\"GuestDisposable didn't receive guest argument\");\n  }\n  if (disposeCheck === undefined) {\n    throw new Error(\"GuestDisposable didn't receive disposeCheck argument\");\n  }\n\n  const result = {\n    disposed(value: T | null): boolean {\n      return disposeCheck(value);\n    },\n    give(value: T) {\n      give(value, guest);\n      return result;\n    },\n  };\n\n  return result;\n};\n","import { give, GuestObjectType, GuestType } from \"../Guest/Guest\";\n\n/**\n * Helps to apply function to value before baseGuest will receive it\n * @url https://silentium-lab.github.io/silentium/#/guest/guest-applied\n */\nexport const guestApplied = <T, R>(\n  baseGuest: GuestType<R>,\n  applier: (value: T) => R,\n): GuestObjectType<T> => {\n  const result = {\n    give(value: T) {\n      give(applier(value), baseGuest);\n      return result;\n    },\n  };\n  return result;\n};\n","import {\n  give,\n  GuestExecutorType,\n  GuestObjectType,\n  GuestType,\n} from \"../Guest/Guest\";\n\n/**\n * Apply function to guest function of receiving value, useful for debouncing or throttling\n * @url https://silentium-lab.github.io/silentium/#/guest/guest-executor-applied\n */\nexport const guestExecutorApplied = <T>(\n  baseGuest: GuestType<T>,\n  applier: (executor: GuestExecutorType<T>) => GuestExecutorType<T>,\n): GuestObjectType<T> => {\n  const result = {\n    give: applier((v) => give(v, baseGuest)),\n  };\n\n  return result as GuestObjectType<T>;\n};\n","import { give, GuestType } from \"../Guest/Guest\";\nimport { GuestDisposableType } from \"../Guest/GuestDisposable\";\n\nexport type PatronType<T> = GuestDisposableType<T> & {\n  introduction(): \"patron\";\n};\n\n/**\n * Helps to check what incoming object is patron\n * @url https://silentium-lab.github.io/silentium/#/utils/is-patron\n */\nexport const isPatron = (guest: GuestType): guest is PatronType<unknown> =>\n  typeof guest === \"object\" &&\n  guest !== null &&\n  guest?.introduction?.() === \"patron\";\n\nexport const introduction = () => \"patron\" as const;\n\n/**\n * Help to turn existed guest intro patron\n * @url https://silentium-lab.github.io/silentium/#/patron\n */\nexport const patron = <T>(\n  willBePatron: GuestType<T>,\n): GuestDisposableType<T> => {\n  if (willBePatron === undefined) {\n    throw new Error(\"Patron didn't receive willBePatron argument\");\n  }\n\n  const result = {\n    give(value: T) {\n      give(value, willBePatron);\n      return result;\n    },\n    disposed(value: T | null): boolean {\n      const maybeDisposable = willBePatron as GuestDisposableType;\n      return maybeDisposable?.disposed?.(value) || false;\n    },\n    introduction,\n  };\n\n  return result;\n};\n","import { introduction } from \"../Patron/Patron\";\nimport { give, GuestType } from \"../Guest/Guest\";\nimport {\n  GuestDisposableType,\n  MaybeDisposableType,\n} from \"../Guest/GuestDisposable\";\n\n/**\n * Helps to call patron only once, this will be helpful when you\n * need value but you know what value can not be existed at a time of requesting\n * @url https://silentium-lab.github.io/silentium/#/patron/patron-once\n */\nexport const patronOnce = <T>(\n  baseGuest: GuestType<T>,\n): GuestDisposableType<T> => {\n  if (baseGuest === undefined) {\n    throw new Error(\"PatronOnce didn't receive baseGuest argument\");\n  }\n\n  let received = false;\n\n  const result = {\n    give(value: T) {\n      if (!received) {\n        received = true;\n        give(value, baseGuest);\n      }\n      return result;\n    },\n    disposed(value: T | null): boolean {\n      if (received) {\n        return true;\n      }\n      const maybeDisposable = baseGuest as MaybeDisposableType;\n      return maybeDisposable.disposed ? maybeDisposable.disposed(value) : false;\n    },\n    introduction,\n  };\n\n  return result;\n};\n","import { source, SourceType } from \"../Source/Source\";\nimport { give, GuestObjectType, GuestType } from \"../Guest/Guest\";\nimport { GuestDisposableType } from \"../Guest/GuestDisposable\";\n\nconst poolSets = new Map<PoolType, Set<GuestObjectType>>();\nconst poolsOfInitiators = new Map<SourceType, PoolType>();\nconst subSources = new Map<SourceType, SourceType[]>();\n\nconst poolsChangeFns: (() => void)[] = [];\nconst notifyPoolsChange = () => {\n  poolsChangeFns.forEach((fn) => fn());\n};\nconst lastPatronPoolsStatistic = {\n  poolsCount: 0,\n  patronsCount: 0,\n};\n/**\n * Helps to debug application and see is it have problems with frozen pools\n * @url https://silentium-lab.github.io/silentium/#/utils/patron-pools-statistic\n */\nexport const patronPoolsStatistic = source<{\n  poolsCount: number;\n  patronsCount: number;\n}>((g) => {\n  give(lastPatronPoolsStatistic, g);\n  poolsChangeFns.push(() => {\n    let patronsCount = 0;\n    poolSets.forEach((set) => {\n      patronsCount += set.size;\n    });\n    lastPatronPoolsStatistic.poolsCount = poolSets.size;\n    lastPatronPoolsStatistic.patronsCount = patronsCount;\n    give(lastPatronPoolsStatistic, g);\n  });\n});\n\n/**\n * Helps to connect source and subsource, needed to destroy all sub sources\n * when base source will be destroyed\n * @url https://silentium-lab.github.io/silentium/#/utils/sub-source\n */\nexport const subSource = <T>(\n  subSource: SourceType,\n  source: SourceType<T>,\n): SourceType<T> => {\n  // sub sources can appear only on SourceObjectType\n  if (source !== null && typeof source !== \"object\") {\n    return source;\n  }\n\n  if (!subSources.has(source)) {\n    subSources.set(source, []);\n  }\n\n  subSources.get(source)?.push(subSource);\n\n  return subSource;\n};\n\n/**\n * Helps to define many sources of one sub source\n */\nexport const subSourceMany = <T>(\n  subSourceSrc: SourceType<T>,\n  sourcesSrc: SourceType[],\n): SourceType<T> => {\n  sourcesSrc.forEach((source) => {\n    subSource(subSourceSrc, source);\n  });\n  return subSourceSrc;\n};\n\n/**\n * Helps to remove all pools of related initiators\n * @url https://silentium-lab.github.io/silentium/#/utils/destroy\n */\nexport const destroy = (initiators: SourceType[]) => {\n  initiators.forEach((initiator) => {\n    const pool = poolsOfInitiators.get(initiator);\n    pool?.destroy();\n    const relatedInitiators = subSources.get(initiator);\n    if (relatedInitiators) {\n      destroy(relatedInitiators);\n    }\n  });\n};\n\n/**\n * Returns all pools related to one patron\n * @url https://silentium-lab.github.io/silentium/#/utils/patron-pools\n */\nexport const patronPools = (patron: GuestObjectType) => {\n  const pools: PoolType[] = [];\n  poolSets.forEach((pool, poolInstance) => {\n    if (pool.has(patron)) {\n      pools.push(poolInstance);\n    }\n  });\n  return pools;\n};\n\n/**\n * Removes patron from all existed pools\n * @url https://silentium-lab.github.io/silentium/#/utils/remove-patron-from-pools\n */\nexport const removePatronFromPools = (patron: GuestObjectType) => {\n  if (patron === undefined) {\n    throw new Error(\"removePatronFromPools didn't receive patron argument\");\n  }\n  poolSets.forEach((pool) => {\n    pool.delete(patron);\n  });\n};\n\n/**\n * Checks what patron is connected with any pool\n * @url https://silentium-lab.github.io/silentium/#/utils/is-patron-in-pools\n */\nexport const isPatronInPools = (patron: GuestObjectType) => {\n  if (patron === undefined) {\n    throw new Error(\"isPatronInPools didn't receive patron argument\");\n  }\n  let inPool = false;\n  poolSets.forEach((pool) => {\n    if (!inPool) {\n      inPool = pool.has(patron);\n    }\n  });\n  return inPool;\n};\n\nexport interface PoolType<T = any> extends GuestObjectType<T> {\n  add(guest: GuestObjectType<T>): this;\n  distribute(receiving: T, possiblePatron: GuestObjectType<T>): this;\n  remove(patron: GuestObjectType<T>): this;\n  size(): number;\n  destroy(): void;\n}\n\n/**\n * Pool class helps to implement dispatching for patron about new values\n * what may appear in sources\n * @url https://silentium-lab.github.io/silentium/#/patron/patron-pool\n */\nexport class PatronPool<T> implements PoolType<T> {\n  private patrons: Set<GuestObjectType<T>>;\n\n  public give: (value: T) => this;\n\n  public constructor(private initiator: SourceType) {\n    this.patrons = new Set<GuestObjectType<T>>();\n    poolSets.set(this, this.patrons);\n    poolsOfInitiators.set(this.initiator, this);\n    const doReceive = (value: T) => {\n      this.patrons.forEach((target) => {\n        this.sendValueToGuest(value, target);\n      });\n    };\n    this.give = (value: T) => {\n      doReceive(value);\n      return this;\n    };\n    notifyPoolsChange();\n  }\n\n  public size(): number {\n    return this.patrons.size;\n  }\n\n  public add(shouldBePatron: GuestType<T>) {\n    if (!shouldBePatron) {\n      throw new Error(\"PatronPool add method received nothing!\");\n    }\n    if (\n      typeof shouldBePatron !== \"function\" &&\n      shouldBePatron.introduction &&\n      shouldBePatron.introduction() === \"patron\"\n    ) {\n      this.patrons.add(shouldBePatron);\n    }\n    notifyPoolsChange();\n    return this;\n  }\n\n  public remove(patron: GuestObjectType<T>) {\n    this.patrons.delete(patron);\n    notifyPoolsChange();\n    return this;\n  }\n\n  public distribute(receiving: T, possiblePatron: GuestType<T>): this {\n    this.add(possiblePatron);\n    this.sendValueToGuest(receiving, possiblePatron);\n    return this;\n  }\n\n  public destroy() {\n    this.patrons.forEach((patron) => {\n      this.remove(patron);\n    });\n    poolSets.delete(this);\n    poolsOfInitiators.delete(this.initiator);\n    notifyPoolsChange();\n    return this;\n  }\n\n  private sendValueToGuest(value: T, guest: GuestType<T>) {\n    const isDisposed = this.guestDisposed(value, guest);\n    if (!isDisposed) {\n      give(value, guest);\n    }\n    return this;\n  }\n\n  private guestDisposed(value: T, guest: GuestType<T>) {\n    if ((guest as GuestDisposableType).disposed?.(value)) {\n      this.remove(guest as GuestObjectType);\n      return true;\n    }\n    return false;\n  }\n}\n","import { introduction } from \"../Patron/Patron\";\nimport { GuestObjectType, GuestType } from \"../Guest/Guest\";\nimport { guestApplied } from \"../Guest/GuestApplied\";\n\n/**\n * Helps to apply function to patron\n * @url https://silentium-lab.github.io/silentium/#/patron/patron-applied\n */\nexport const patronApplied = <T, R>(\n  baseGuest: GuestType<R>,\n  applier: (value: T) => R,\n): GuestObjectType<T> => {\n  const applied = guestApplied(baseGuest, applier);\n\n  const result = {\n    give(value: T) {\n      applied.give(value);\n      return result;\n    },\n    introduction,\n  };\n\n  return result;\n};\n","import { introduction } from \"../Patron/Patron\";\nimport { GuestExecutorType, GuestType } from \"../Guest/Guest\";\nimport { guestExecutorApplied } from \"../Guest/GuestExecutorApplied\";\n\n/**\n * Helps to apply function to patrons executor\n * @url https://silentium-lab.github.io/silentium/#/patron/patron-executor-applied\n */\nexport const patronExecutorApplied = <T>(\n  baseGuest: GuestType<T>,\n  applier: (executor: GuestExecutorType) => GuestExecutorType,\n) => {\n  const guestApplied = guestExecutorApplied(baseGuest, applier);\n\n  const result = {\n    give(value: T) {\n      guestApplied.give(value);\n      return result;\n    },\n    introduction,\n  };\n\n  return result;\n};\n","import { GuestType } from \"../Guest/Guest\";\nimport { guestSync } from \"../Guest/GuestSync\";\nimport { patron } from \"../Patron/Patron\";\nimport { SourceObjectType, SourceType, value } from \"../Source/Source\";\n\n/**\n * Helps to represent source value as sync value, what can be returned\n * useful for example in tests\n * @url https://silentium-lab.github.io/silentium/#/source/source-sync\n */\nexport const sourceSync = <T>(\n  baseSource: SourceType<T>,\n  defaultValue?: unknown,\n): SourceObjectType<T> & { syncValue(): T } => {\n  const syncGuest = guestSync<T>(defaultValue as T);\n  value(baseSource, patron(syncGuest));\n\n  return {\n    value(guest: GuestType<T>) {\n      value(baseSource, guest);\n      return this;\n    },\n    syncValue() {\n      try {\n        return syncGuest.value() as T;\n      } catch {\n        throw new Error(\"No value in SourceSync\");\n      }\n    },\n  };\n};\n","import { sourceSync } from \"../Source/SourceSync\";\nimport { give, guest, GuestObjectType, GuestType } from \"../Guest/Guest\";\nimport { isPatron } from \"../Patron/Patron\";\nimport { patronOnce } from \"../Patron/PatronOnce\";\nimport { PatronPool } from \"../Patron/PatronPool\";\nimport {\n  isSource,\n  SourceDataType,\n  SourceObjectType,\n  SourceType,\n  value,\n} from \"./Source\";\n\nexport type SourceChangeableType<T = any> = SourceObjectType<T> &\n  GuestObjectType<T>;\n\nconst sourceIsEmpty = (source: unknown) =>\n  source === undefined || source === null;\n\n/**\n * Ability to create source what can be changed later\n * @url https://silentium-lab.github.io/silentium/#/source/source-of\n */\nexport const sourceOf = <T>(source?: SourceType<T>) => {\n  const createdSource = {} as SourceChangeableType<T>;\n  const thePool = new PatronPool(createdSource);\n  let isEmpty = sourceIsEmpty(source);\n\n  if (!isEmpty && isSource(source)) {\n    value(\n      source,\n      patronOnce((unwrappedSourceDocument) => {\n        isEmpty = sourceIsEmpty(unwrappedSourceDocument);\n        source = unwrappedSourceDocument as SourceDataType<T>;\n      }),\n    );\n  }\n\n  createdSource.value = (g: GuestType<T>) => {\n    if (isEmpty) {\n      if (isPatron(g)) {\n        thePool.add(g);\n      }\n      return createdSource;\n    }\n\n    if (typeof g === \"function\") {\n      thePool.distribute(source, guest(g));\n    } else {\n      thePool.distribute(source, g);\n    }\n\n    return createdSource;\n  };\n\n  createdSource.give = (value: T) => {\n    isEmpty = sourceIsEmpty(value);\n    source = value as SourceDataType<T>;\n\n    if (!isEmpty) {\n      thePool.give(source);\n    }\n\n    return createdSource;\n  };\n\n  return createdSource as SourceChangeableType<T>;\n};\n\n/**\n * Changeable source what can be changed only once with specified value\n * @url https://silentium-lab.github.io/silentium/#/source/source-memo-of\n */\nexport const sourceMemoOf = <T>(\n  source?: SourceType<T>,\n): SourceChangeableType<T> => {\n  const result = sourceOf(source);\n  const baseSrcSync = sourceSync(result, null);\n\n  const resultMemo = {\n    value: result.value,\n    give(value: T) {\n      if (baseSrcSync.syncValue() !== value) {\n        give(value, result.give);\n      }\n      return resultMemo;\n    },\n  };\n\n  return resultMemo;\n};\n","import { subSource } from \"../Patron/PatronPool\";\nimport { give, guest, GuestType } from \"../Guest/Guest\";\nimport { guestCast } from \"../Guest/GuestCast\";\nimport { patron } from \"../Patron/Patron\";\nimport { SourceType, value } from \"./Source\";\nimport { sourceOf } from \"./SourceChangeable\";\n\ntype ExtractType<T> = T extends SourceType<infer U> ? U : never;\n\nexport type ExtractTypesFromArray<T extends SourceType<any>[]> = {\n  [K in keyof T]: ExtractType<T[K]>;\n};\n\n/**\n * Represents common value as Array of bunch of sources,\n * when all sources will gets it's values\n * @url https://silentium-lab.github.io/silentium/#/source/source-all\n */\nexport const sourceAll = <const T extends SourceType[]>(\n  sources: T,\n): SourceType<ExtractTypesFromArray<T>> => {\n  const keysKnown = new Set<string>(Object.keys(sources));\n  const keysFilled = new Set();\n  const isAllFilled = () => {\n    return keysFilled.size > 0 && keysFilled.size === keysKnown.size;\n  };\n  const theAll = sourceOf({});\n\n  Object.entries(sources).forEach(([key, source]) => {\n    subSource(theAll, source);\n    keysKnown.add(key);\n    value(\n      source,\n      patron((v) => {\n        theAll.value(\n          guest((all: Record<string, unknown>) => {\n            keysFilled.add(key);\n            const lastAll = {\n              ...all,\n              [key]: v,\n            };\n            theAll.give(lastAll);\n          }),\n        );\n      }),\n    );\n  });\n\n  return (guest: GuestType<ExtractTypesFromArray<T>>) => {\n    value((g) => {\n      theAll.value(\n        guestCast(g, (value) => {\n          if (isAllFilled()) {\n            give(Object.values(value) as ExtractTypesFromArray<T>, g);\n          }\n        }),\n      );\n    }, guest);\n  };\n};\n","import { give, GuestType } from \"../Guest/Guest\";\nimport { guestCast } from \"../Guest/GuestCast\";\nimport { patronOnce } from \"../Patron/PatronOnce\";\nimport { LazyType } from \"../Lazy/Lazy\";\nimport { isSource, SourceType, value } from \"./Source\";\nimport { sourceAll } from \"./SourceAll\";\nimport { sourceOf, SourceChangeableType } from \"./SourceChangeable\";\n\n/**\n * Ability to apply source to source of array values sequentially\n * @url https://silentium-lab.github.io/silentium/#/source/source-sequence\n */\nexport const sourceSequence = <T, TG>(\n  baseSource: SourceType<T[]>,\n  targetSource: LazyType<SourceType<TG>>,\n) => {\n  if (baseSource === undefined) {\n    throw new Error(\"SourceSequence didn't receive baseSource argument\");\n  }\n  if (targetSource === undefined) {\n    throw new Error(\"SourceSequence didn't receive targetSource argument\");\n  }\n\n  return (guest: GuestType<TG[]>) => {\n    const sequenceSource = sourceOf();\n    const source = targetSource.get(sequenceSource);\n\n    value(\n      baseSource,\n      guestCast(guest, (theValue) => {\n        let index = 0;\n\n        const sources: SourceChangeableType[] = [];\n        theValue.forEach(() => {\n          sources.push(sourceOf());\n        });\n\n        const nextItemHandle = () => {\n          if (theValue[index + 1] !== undefined) {\n            index = index + 1;\n            handle();\n          }\n        };\n\n        function handle() {\n          const currentSource = sources[index];\n          const nextValue = theValue[index];\n          if (isSource(nextValue)) {\n            value(\n              nextValue,\n              patronOnce((theNextValue) => {\n                sequenceSource.give(theNextValue);\n                value(source, currentSource);\n                nextItemHandle();\n              }),\n            );\n          } else {\n            sequenceSource.give(nextValue);\n            value(source, currentSource);\n            nextItemHandle();\n          }\n        }\n\n        if (theValue[index] !== undefined) {\n          handle();\n          value(sourceAll(sources), guest);\n        } else {\n          give([], guest);\n        }\n      }),\n    );\n  };\n};\n","import { patron } from \"../Patron/Patron\";\nimport { patronOnce } from \"../Patron/PatronOnce\";\nimport { sourceOf } from \"../Source/SourceChangeable\";\nimport { give } from \"../Guest/Guest\";\nimport { LazyType } from \"../Lazy/Lazy\";\nimport { destroy, subSource } from \"../Patron/PatronPool\";\nimport { SourceType, value } from \"./Source\";\nimport { sourceAll } from \"./SourceAll\";\n\n/**\n * Helps to modify many sources with one private source\n * @url https://silentium-lab.github.io/silentium/#/source/source-map\n */\nexport const sourceMap = <T, TG>(\n  baseSource: SourceType<T[]>,\n  targetSource: LazyType<SourceType<TG>>,\n) => {\n  if (baseSource === undefined) {\n    throw new Error(\"SourceMap didn't receive baseSource argument\");\n  }\n  if (targetSource === undefined) {\n    throw new Error(\"SourceMap didn't receive targetSource argument\");\n  }\n\n  const result = sourceOf<TG[]>();\n\n  value(\n    baseSource,\n    patron((theValue) => {\n      const sources: SourceType[] = [];\n      theValue.forEach((val) => {\n        const source = targetSource.get(val);\n        subSource(source, baseSource);\n        sources.push(source);\n      });\n      value(\n        sourceAll(sources),\n        patronOnce((v) => {\n          destroy(sources);\n          give(v, result);\n        }),\n      );\n    }),\n  );\n\n  return result.value;\n};\n","import { give, GuestType } from \"../Guest/Guest\";\nimport { guestCast } from \"../Guest/GuestCast\";\nimport { SourceType, value } from \"./Source\";\n\n/**\n * Connects guest with source what give response faster than others\n * @url https://silentium-lab.github.io/silentium/#/source/source-race\n */\nexport const sourceRace = <T>(sources: SourceType<T>[]) => {\n  if (sources === undefined) {\n    throw new Error(\"SourceRace didnt receive sources argument\");\n  }\n\n  return (guest: GuestType<T>) => {\n    let connectedWithSource: SourceType | null = null;\n    sources.forEach((source) => {\n      value(\n        source,\n        guestCast(<GuestType>guest, (value) => {\n          if (!connectedWithSource || connectedWithSource === source) {\n            give(value as T, guest);\n            connectedWithSource = source;\n          }\n        }),\n      );\n    });\n  };\n};\n","import { patron } from \"../Patron/Patron\";\nimport { SourceType, value } from \"../Source/Source\";\nimport { sourceOf } from \"../Source/SourceChangeable\";\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ntype Last<T extends any[]> = T extends [...infer U, infer L] ? L : never;\n\n/**\n * Returns value of some source when all sources before it gives their response\n * @url https://silentium-lab.github.io/silentium/#/source/source-chain\n */\nexport const sourceChain = <T extends SourceType[]>(\n  ...sources: T\n): SourceType<Last<T>> => {\n  const resultSrc = sourceOf<Last<T>>();\n  const respondedSources = new Set();\n  let lastSourceValue: any = null;\n  sources.forEach((source, index) => {\n    value(\n      source,\n      patron((value) => {\n        respondedSources.add(index);\n        if (index === sources.length - 1) {\n          lastSourceValue = value;\n        }\n        if (\n          respondedSources.size === sources.length &&\n          lastSourceValue !== null\n        ) {\n          resultSrc.give(lastSourceValue);\n        }\n      }),\n    );\n  });\n\n  return resultSrc.value;\n};\n","import { give, GuestType } from \"../Guest/Guest\";\nimport { SourceType, value } from \"./Source\";\nimport { SourceChangeableType } from \"./SourceChangeable\";\n\n/**\n * Ability to build common changeable source from different guest and source\n * @url https://silentium-lab.github.io/silentium/#/source/source-dynamic\n */\nexport const sourceDynamic = <T>(\n  baseGuest: GuestType<T>,\n  baseSource: SourceType<T>,\n): SourceChangeableType<T> => {\n  if (baseGuest === undefined) {\n    throw new Error(\"SourceDynamic didn't receive baseGuest argument\");\n  }\n  if (baseSource === undefined) {\n    throw new Error(\"SourceDynamic didn't receive baseSource argument\");\n  }\n\n  const sourceObject = {\n    value(guest: GuestType<T>) {\n      value(baseSource, guest);\n      return sourceObject;\n    },\n    give(value: T) {\n      give(value, baseGuest);\n      return this;\n    },\n  };\n\n  return sourceObject;\n};\n","import { give, GuestType } from \"../Guest/Guest\";\nimport { guestCast } from \"../Guest/GuestCast\";\nimport { SourceType, value } from \"../Source/Source\";\n\n/**\n * Gives ability to apply function to source value\n * @url https://silentium-lab.github.io/silentium/#/source/source-applied\n */\nexport const sourceApplied = <T, R>(\n  baseSource: SourceType<T>,\n  applier: (v: T) => R,\n) => {\n  return (guest: GuestType<R>) => {\n    value(\n      baseSource,\n      guestCast(guest, (v) => {\n        give(applier(v), guest);\n      }),\n    );\n  };\n};\n","import { SourceExecutorType, SourceType, value } from \"../Source/Source\";\n\n/**\n * Ability to apply function to source executor, helpful when need to apply throttling or debounce\n * @url https://silentium-lab.github.io/silentium/#/source/source-executor-applied\n */\nexport const sourceExecutorApplied = <T>(\n  source: SourceType<T>,\n  applier: (executor: SourceExecutorType<T>) => SourceExecutorType<T>,\n) => {\n  return applier((g) => {\n    value(source, g);\n  });\n};\n","import { give, GuestType } from \"../Guest/Guest\";\nimport { guestCast } from \"../Guest/GuestCast\";\nimport { SourceType, value } from \"../Source/Source\";\n\n/**\n * Helps not to respond with information what checked by predicate function\n * @url https://silentium-lab.github.io/silentium/#/source/source-filtered\n */\nexport const sourceFiltered = <T>(\n  baseSource: SourceType<T>,\n  predicate: (v: T) => boolean,\n  defaultValue?: T,\n) => {\n  return (g: GuestType<T>) => {\n    value(\n      baseSource,\n      guestCast(g, (v) => {\n        if (predicate(v) === true) {\n          give(v, g);\n        } else if (defaultValue !== undefined) {\n          give(defaultValue, g);\n        }\n      }),\n    );\n  };\n};\n","import { GuestType } from \"../Guest/Guest\";\nimport { SourceType, value } from \"./Source\";\nimport { sourceOf } from \"./SourceChangeable\";\n\n/**\n * Ability set the value only once\n * @url https://silentium-lab.github.io/silentium/#/source/source-once\n */\nexport const sourceOnce = <T>(initialValue?: SourceType<T>) => {\n  let isFilled = initialValue !== undefined;\n  const source = sourceOf(initialValue);\n\n  return {\n    value(guest: GuestType<T>) {\n      value(source, guest);\n      return this;\n    },\n    give(value: T) {\n      if (!isFilled) {\n        source.give(value);\n        isFilled = true;\n      }\n      return this;\n    },\n  };\n};\n","import { GuestType } from \"../Guest/Guest\";\nimport { patron } from \"../Patron/Patron\";\nimport { subSourceMany } from \"../Patron/PatronPool\";\nimport { SourceType, value } from \"../Source/Source\";\nimport { ExtractTypesFromArray, sourceAll } from \"../Source/SourceAll\";\nimport { sourceOf } from \"../Source/SourceChangeable\";\n\n/**\n * Simplifies sources combination, when we need to create value depending on many sources\n * @url https://silentium-lab.github.io/silentium/#/source/source-combined\n */\nexport const sourceCombined =\n  <const T extends SourceType[]>(...sources: T) =>\n  <R>(\n    source: (\n      guest: GuestType<R>,\n      ...sourcesValues: ExtractTypesFromArray<T>\n    ) => void,\n  ): SourceType<R> => {\n    const result = sourceOf<R>();\n    subSourceMany(result, sources);\n\n    value(\n      sourceAll(sources),\n      patron((actualValues) => {\n        source(result.give, ...actualValues);\n      }),\n    );\n\n    return result.value;\n  };\n","import { give } from \"../Guest/Guest\";\nimport { patron } from \"../Patron/Patron\";\nimport { subSource } from \"../Patron/PatronPool\";\nimport { SourceType, value } from \"../Source/Source\";\nimport { sourceOf } from \"../Source/SourceChangeable\";\n\n/**\n * @url https://silentium-lab.github.io/silentium/#/source/source-resettable\n */\nexport const sourceResettable = <T>(\n  baseSrc: SourceType<T>,\n  resettableSrc: SourceType<unknown>,\n) => {\n  const result = sourceOf<T>();\n\n  value(\n    resettableSrc,\n    patron(() => {\n      give(null, result);\n    }),\n  );\n\n  value(baseSrc, patron(result));\n  subSource(result, baseSrc);\n\n  return result;\n};\n","import { patron } from \"../Patron/Patron\";\nimport { SourceType, value } from \"../Source/Source\";\nimport { sourceOf } from \"../Source/SourceChangeable\";\n\n/**\n * Present source of value what was last appeared in any\n * of given sources, can be used as default value, when some source\n * don't respond\n * @url https://silentium-lab.github.io/silentium/#/source/source-any\n */\nexport const sourceAny = <T>(sources: SourceType<T>[]) => {\n  const lastSrc = sourceOf<T>();\n  sources.forEach((source) => {\n    value(source, patron(lastSrc));\n  });\n\n  return lastSrc;\n};\n","import { LazyType } from \"../Lazy/Lazy\";\nimport { patron } from \"../Patron/Patron\";\nimport { destroy } from \"../Patron/PatronPool\";\nimport { SourceType, value } from \"../Source/Source\";\nimport { sourceAll } from \"../Source/SourceAll\";\nimport { sourceOf } from \"../Source/SourceChangeable\";\nimport { sourceResettable } from \"../Source/SourceResettable\";\n\n/**\n * Helps to build source only when all sources will give its values\n * @url https://silentium-lab.github.io/silentium/#/source/source-lazy\n */\nexport const sourceLazy = <T>(\n  lazySrc: LazyType<SourceType<T>>,\n  args: SourceType[],\n  resetSrc?: SourceType<unknown>,\n) => {\n  let instance: SourceType<T> | null = null;\n  const result = sourceOf<T>();\n  const resultResettable = sourceResettable(result, resetSrc ?? sourceOf());\n\n  value(\n    sourceAll(args),\n    patron(() => {\n      if (!instance) {\n        instance = lazySrc.get(...args);\n        value(instance, patron(result));\n      }\n    }),\n  );\n\n  if (resetSrc) {\n    value(\n      resetSrc,\n      patron(() => {\n        destroy([instance]);\n        instance = null;\n      }),\n    );\n  }\n\n  return resultResettable;\n};\n","import { LazyType } from \"./Lazy\";\n\ninterface Constructable<T> {\n  new (...args: unknown[]): T;\n}\n\ninterface Prototyped<T> {\n  prototype: T;\n}\n\nexport const lazyClass = <T>(\n  constructorFn: Prototyped<T>,\n  modules: Record<string, unknown> = {},\n): LazyType<T> => {\n  if (constructorFn === undefined) {\n    throw new Error(\"PrivateClass didn't receive constructorFn argument\");\n  }\n\n  return {\n    get<R extends unknown[], CT = null>(...args: R): CT extends null ? T : CT {\n      return new (constructorFn as Constructable<T>)(\n        ...args,\n        modules,\n      ) as CT extends null ? T : CT;\n    },\n  };\n};\n","export interface LazyType<T> {\n  get<R extends unknown[], CT = null>(...args: R): CT extends null ? T : CT;\n}\n\n/**\n * Helps to get lazy instance of dependency\n * @url https://silentium-lab.github.io/silentium/#/utils/lazy\n */\nexport const lazy = <T>(buildingFn: (...args: any[]) => T): LazyType<T> => {\n  if (buildingFn === undefined) {\n    throw new Error(\"lazy didn't receive buildingFn argument\");\n  }\n\n  return {\n    get<R extends unknown[], CT = null>(...args: R): CT extends null ? T : CT {\n      return buildingFn(...args) as CT extends null ? T : CT;\n    },\n  };\n};\n"],"names":["value","source","guest","Error","give","isSource","mbSource","data","isGuest","mbGuest","receiver","result","guestCast","sourceGuest","targetGuest","disposed","maybeDisposable","introduction","guestSync","theValue","guestDisposable","disposeCheck","guestApplied","baseGuest","applier","guestExecutorApplied","v","isPatron","patron","willBePatron","patronOnce","received","poolSets","Map","poolsOfInitiators","subSources","poolsChangeFns","notifyPoolsChange","forEach","fn","lastPatronPoolsStatistic","poolsCount","patronsCount","patronPoolsStatistic","g","push","set","size","subSource","has","get","subSourceMany","subSourceSrc","sourcesSrc","destroy","initiators","initiator","pool","relatedInitiators","patronPools","pools","poolInstance","removePatronFromPools","delete","isPatronInPools","inPool","PatronPool","constructor","this","__publicField","patrons","Set","doReceive","target","sendValueToGuest","add","shouldBePatron","remove","distribute","receiving","possiblePatron","guestDisposed","patronApplied","applied","patronExecutorApplied","sourceSync","baseSource","defaultValue","syncGuest","syncValue","sourceIsEmpty","sourceOf","createdSource","thePool","isEmpty","unwrappedSourceDocument","sourceMemoOf","baseSrcSync","resultMemo","sourceAll","sources","keysKnown","Object","keys","keysFilled","theAll","entries","key","all","lastAll","values","sourceSequence","targetSource","sequenceSource","index","nextItemHandle","handle","currentSource","nextValue","theNextValue","sourceMap","val","sourceRace","connectedWithSource","sourceChain","resultSrc","respondedSources","lastSourceValue","length","sourceDynamic","sourceObject","sourceApplied","sourceExecutorApplied","sourceFiltered","predicate","sourceOnce","initialValue","isFilled","sourceCombined","actualValues","sourceResettable","baseSrc","resettableSrc","sourceAny","lastSrc","sourceLazy","lazySrc","args","resetSrc","instance","resultResettable","lazyClass","constructorFn","modules","lazy","buildingFn"],"mappings":"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"}