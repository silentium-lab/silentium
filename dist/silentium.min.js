!function(e){"use strict";const r=(e,r)=>{if(null==e)throw new Error("value didn't receive source argument");if(void 0===r||null===e)throw new Error("value didn't receive guest argument");return"function"==typeof e?e(r):"object"==typeof e&&"value"in e&&"function"==typeof e.value?e.value(r):n(e,r),e},t=e=>null!==e&&"object"==typeof e&&"value"in e&&"function"==typeof e.value||null!=e,o=e=>{if(void 0===e)throw new Error("Source constructor didn't receive executor function");return t=>{r(e,t)}},n=(e,r)=>{if(void 0===e)throw new Error("give didn't receive data argument");return void 0===r?o(e):("function"==typeof r?r(e):r.give(e),r)},i=e=>{if(!e)throw new Error("receiver function was not passed to Guest constructor");const r={give:t=>(e(t),r)};return r},s=(e,r)=>{if(void 0===e)throw new Error("GuestCast didn't receive sourceGuest argument");if(void 0===r)throw new Error("GuestCast didn't receive targetGuest argument");const t={disposed(r){const t=e;return!!t.disposed&&t.disposed(r)},give:e=>(n(e,r),t),introduction:()=>"function"==typeof e?"guest":e.introduction?e.introduction():"guest"};return t},u=e=>{const r={give:t=>(e=t,r),value(){if(void 0===e)throw new Error("no value in GuestSync!");return e}};return r},c=(e,r)=>{const t={give:o=>(n(r(o),e),t)};return t},d=(e,r)=>({give:r((r=>n(r,e)))}),a=e=>"object"==typeof e&&null!==e&&"patron"===e?.introduction?.(),v=()=>"patron",l=e=>{if(void 0===e)throw new Error("Patron didn't receive willBePatron argument");const r={give:t=>(n(t,e),r),disposed(r){const t=e;return t?.disposed?.(r)||!1},introduction:v};return r},h=e=>{if(void 0===e)throw new Error("PatronOnce didn't receive baseGuest argument");let r=!1;const t={give:o=>(r||(r=!0,n(o,e)),t),disposed(t){if(r)return!0;const o=e;return!!o.disposed&&o.disposed(t)},introduction:v};return t};var g=Object.defineProperty,p=(e,r,t)=>((e,r,t)=>r in e?g(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t)(e,"symbol"!=typeof r?r+"":r,t);const f=new Map,w=new Map;class E{constructor(e){this.initiator=e,p(this,"patrons"),p(this,"give"),this.patrons=new Set,f.set(this,this.patrons),w.set(this.initiator,this);const r=e=>{this.patrons.forEach((r=>{this.sendValueToGuest(e,r)}))};this.give=e=>(r(e),this)}size(){return this.patrons.size}add(e){if(!e)throw new Error("PatronPool add method received nothing!");return"function"!=typeof e&&e.introduction&&"patron"===e.introduction()&&this.patrons.add(e),this}remove(e){return this.patrons.delete(e),this}distribute(e,r){return this.add(r),this.sendValueToGuest(e,r),this}destroy(){this.patrons.forEach((e=>{this.remove(e)})),f.delete(this),w.delete(this.initiator)}sendValueToGuest(e,r){this.guestDisposed(e,r)||n(e,r)}guestDisposed(e,r){return!!r.disposed?.(e)&&(this.remove(r),!0)}}const m=e=>{const o={},n=new E(o),s=new E(o);let u=void 0===e;return void 0!==e&&t(e)?r(e,h((r=>{u=void 0===r,e=r}))):u=void 0===e,o.value=r=>u?(a(r)&&s.add(r),o):("function"==typeof r?n.distribute(e,i(r)):n.distribute(e,r),o),o.give=r=>(u=!1,e=r,n.give(e),s.give(e),o),o},y=e=>{const t=new Set(Object.keys(e)),o=new Set,u=Array.isArray(e),c=m({});return Object.entries(e).forEach((([e,n])=>{t.add(e),r(n,l((r=>{c.value(i((t=>{o.add(e);const n={...t,[e]:r};c.give(n)})))})))})),e=>{r((e=>{c.value(s(e,(r=>{o.size>0&&o.size===t.size&&n(u?Object.values(r):r,e)})))}),e)}};e.PatronPool=E,e.destroy=e=>{e.forEach((e=>{const r=w.get(e);r?.destroy()}))},e.give=n,e.guest=i,e.guestApplied=c,e.guestCast=s,e.guestDisposable=(e,r)=>{if(void 0===e)throw new Error("GuestDisposable didn't receive guest argument");if(void 0===r)throw new Error("GuestDisposable didn't receive disposeCheck argument");const t={disposed:e=>r(e),give:r=>(n(r,e),t)};return t},e.guestExecutorApplied=d,e.guestSync=u,e.introduction=v,e.isGuest=e=>{if(void 0===e)throw new Error("isGuest didnt receive mbGuest argument");return"function"==typeof e||"function"==typeof e?.give},e.isPatron=a,e.isPatronInPools=e=>{if(void 0===e)throw new Error("isPatronInPools didnt receive patron argument");let r=!1;return f.forEach((t=>{r||(r=t.has(e))})),r},e.isSource=t,e.patron=l,e.patronApplied=(e,r)=>{const t=c(e,r),o={give:e=>(t.give(e),o),introduction:v};return o},e.patronExecutorApplied=(e,r)=>{const t=d(e,r),o={give:e=>(t.give(e),o),introduction:v};return o},e.patronOnce=h,e.patronPools=e=>{const r=[];return f.forEach(((t,o)=>{t.has(e)&&r.push(o)})),r},e.personal=e=>{if(void 0===e)throw new Error("personal didn't receive buildingFn argument");return{get:(...r)=>e(...r)}},e.personalClass=(e,r={})=>{if(void 0===e)throw new Error("PrivateClass didn't receive constructorFn argument");return{get:(...t)=>new e(...t,r)}},e.removePatronFromPools=e=>{if(void 0===e)throw new Error("removePatronFromPools didnt receive patron argument");f.forEach((r=>{r.delete(e)}))},e.source=o,e.sourceAll=y,e.sourceApplied=(e,t)=>o=>{r(e,s(o,(e=>{n(t(e),o)})))},e.sourceChangeable=m,e.sourceDynamic=(e,t)=>{if(void 0===e)throw new Error("SourceDynamic didn't receive baseGuest argument");if(void 0===t)throw new Error("SourceDynamic didn't receive baseSource argument");const o={value:e=>(r(t,e),o),give(r){return n(r,e),this}};return o},e.sourceExecutorApplied=(e,t)=>t((t=>{r(e,t)})),e.sourceFiltered=(e,t)=>o=>{r(e,s(o,(e=>{!0===t(e)&&n(e,o)})))},e.sourceMap=(e,t)=>{if(void 0===e)throw new Error("SourceMap didn't receive baseSource argument");if(void 0===t)throw new Error("SourceMap didn't receive targetSource argument");return o=>{r(e,s(o,(e=>{const n=[];e.forEach((e=>{const r=t.get(e);n.push(r)})),r(y(n),o)})))}},e.sourceOnce=e=>{let t=void 0!==e;const o=m(e);return{value(e){return r(o,e),this},give(e){return t||(o.give(e),t=!0),this}}},e.sourceRace=e=>{if(void 0===e)throw new Error("SourceRace didnt receive sources argument");return t=>{let o=null;e.forEach((e=>{r(e,s(t,(r=>{o&&o!==e||(n(r,t),o=e)})))}))}},e.sourceSequence=(e,o)=>{if(void 0===e)throw new Error("SourceSequence didn't receive baseSource argument");if(void 0===o)throw new Error("SourceSequence didn't receive targetSource argument");return i=>{const u=m(),c=o.get(u);r(e,s(i,(e=>{let o=0;const s=[];e.forEach((()=>{s.push(m())}));const d=()=>{void 0!==e[o+1]&&(o+=1,a())};function a(){const n=s[o],i=e[o];t(i)?r(i,h((e=>{u.give(e),r(c,n),d()}))):(u.give(i),r(c,n),d())}void 0!==e[o]?(a(),r(y(s),i)):n([],i)})))}},e.sourceSync=e=>{const t=u();return r(e,l(t)),{value(t){return r(e,t),this},syncValue(){try{return t.value()}catch{throw new Error("No value in SourceSync")}}}},e.value=r}({});
