!function(e){"use strict";var t=Object.defineProperty,n=(e,n,s)=>((e,n,s)=>n in e?t(e,n,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[n]=s)(e,"symbol"!=typeof n?n+"":n,s);const s=class e{constructor(t,s="unknown",r=!0){this.info=t,this.theName=s,this.onlyOneOwner=r,n(this,"theSubInfos",[]),n(this,"destructor"),n(this,"owner"),n(this,"executedCbs"),n(this,"alreadyExecuted",!1),n(this,"debugCbs",[]),e.instances+=1}next(e){return void 0!==this.owner&&(this.owner.give(e),this.doDebug("next value",e)),this}value(e){if(this.onlyOneOwner&&void 0!==this.owner)throw new Error(`owner already connected to info ${this.name()}`);if(this.owner=e,void 0===this.executedCbs||this.alreadyExecuted||(this.executedCbs.forEach((t=>t(e))),this.alreadyExecuted=!0),void 0===this.info)return this;if("function"==typeof this.info){const t=this.info(e);void 0===this.destructor&&void 0!==t&&this.info!==t&&"function"==typeof t&&(this.destructor=t)}else"object"==typeof this.info&&null!==this.info&&"value"in this.info&&"function"==typeof this.info.value?this.info.value(e):this.next(this.info);return this}destroy(){for(;this.theSubInfos.length>0;){const e=this.theSubInfos.shift();e?.destroy()}return this.destructor&&this.destructor(),this.owner=void 0,this.executedCbs=void 0,this.destructor=void 0,this.doDebug("destroyed"),this}subInfo(e){return this.theSubInfos.push(e),this}subInfos(){return this.theSubInfos}name(){return`#info_${this.theName}_${e.instances}`}executed(e){return this.doDebug("executed"),this.executedCbs||(this.executedCbs=[]),this.executedCbs.push(e),this.alreadyExecuted&&void 0!==this.owner&&e(this.owner),this}hasOwner(){return!!this.owner}debug(e){return this.debugCbs.push(e),this}doDebug(...e){this.debugCbs.forEach((t=>t(...e)))}};n(s,"instances",0);let r=s;const o=(e,t="unknown",n=!0)=>e instanceof r?e:new r(e,t,n);var i=Object.defineProperty,u=(e,t,n)=>((e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,t+"",n);class h{constructor(e,t,n){this.ownerFn=e,this.errorFn=t,this.disposedFn=n,u(this,"debugCbs",[])}give(e){return this.doDebug("value",e),this.disposed()||this.ownerFn(e),this}error(e){return this.doDebug("error",e),void 0!==this.errorFn&&this.errorFn(e),this}disposed(){return void 0!==this.disposedFn&&this.disposedFn()}debug(e){return this.debugCbs.push(e),this}doDebug(...e){this.debugCbs.forEach((t=>t(...e)))}}const d=e=>new h(e),a=(...e)=>{const t=new r((n=>{const s=new Set(Object.keys(e)),r=new Set,o={};Object.entries(e).forEach((([e,i])=>{t.subInfo(i),s.add(e),i.value(new h((t=>{r.add(e),o[e]=t,r.size>0&&r.size===s.size&&n.give(Object.values(o))})))}))}));return t};var c=Object.defineProperty,l=(e,t,n)=>((e,t,n)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n)(e,"symbol"!=typeof t?t+"":t,n);class f{constructor(){l(this,"owners"),l(this,"innerOwner"),this.owners=new Set,this.innerOwner=new h((e=>{this.owners.forEach((t=>{t.give(e)}))}),(e=>{this.owners.forEach((t=>{t.error(e)}))}))}owner(){return this.innerOwner}size(){return this.owners.size}has(e){return this.owners.has(e)}add(e){return this.owners.add(e),this}remove(e){return this.owners.delete(e),this}destroy(){return this.owners.forEach((e=>{this.remove(e)})),this}}e.I=o,e.Information=r,e.O=d,e.Owner=h,e.OwnerPool=f,e.all=a,e.any=(...e)=>o((t=>{e.forEach((e=>{e.value(t),e.subInfo(e)}))})),e.applied=(e,t)=>{const n=o((n=>{e.value(d((e=>{n.give(t(e))})))}));return n.subInfo(e),n},e.chain=(...e)=>{let t,n;const s=new WeakMap,r=o=>{const i=e[o],u=e[o+1];i.value(d((e=>{u||(n=e,t?.give(e)),u&&void 0!==n&&void 0!==t&&t.give(n),u&&!s.has(i)&&r(o+1),s.set(i,1)})))},i=o((e=>{t=e}));return i.executed((e=>{t=e,r(0)})),i},e.executorApplied=(e,t)=>{const n=new r((n=>{e.value(t(n))}));return n.subInfo(e),n},e.filtered=(e,t,n)=>new r((s=>{e.value(d((e=>{t(e)?s.give(e):void 0!==n&&s.give(n)})))})).subInfo(e),e.fromCallback=e=>o((t=>{e((e=>{t.give(e)}))})),e.fromEvent=(e,t,n,s)=>o((r=>{const o=(...e)=>{r.give(e)};return e[n](t,o),()=>{void 0!==s&&e[s](t,o)}})),e.fromPromise=e=>o((t=>{e.then((e=>{t.give(e)})).catch((e=>{t.error(e)}))})),e.lazy=e=>{if(void 0===e)throw new Error("lazy didn't receive buildingFn argument");return{get:(...t)=>e(...t)}},e.lazyClass=(e,t={})=>{if(void 0===e)throw new Error("PrivateClass didn't receive constructorFn argument");return{get:(...n)=>new e(...n,t)}},e.lazyS=(e,t)=>{const n=new r((t=>{const s=e.get();n.subInfo(s),s.value(t)}));return t&&(n.subInfo(t),t.value(d((()=>{n.destroy()})))),n},e.map=(e,t)=>{const n=new r((s=>{e.value(d((e=>{const i=[];e.forEach((e=>{let n=e;n instanceof r||(n=o(e));const s=t.get(n);i.push(s)}));const u=a(...i).value(s);n.subInfo(u)})))}));return n.subInfo(e),n},e.of=e=>{let t,n=e;const s=()=>{void 0!==t&&t.give(n)};return[new r((e=>{t=e,null!=n&&s()}),"of"),new h((e=>{n=e,s()}))]},e.once=e=>{const t=new r((t=>{let n=!1;e.value(d((e=>{n||(n=!0,t.give(e))})))}));return t.subInfo(e),t},e.ownerApplied=(e,t)=>new h((n=>{e.give(t(n))}),(t=>{e.error(t)}),(()=>e.disposed())),e.ownerExecutorApplied=(e,t)=>{const n=t((t=>e.give(t)));return new h((e=>{n(e)}))},e.ownerSync=(e,t)=>{let n;return e.value(d((e=>{n=e}))),{syncValue(){if(void 0===n&&void 0===t)throw new Error("info sync is empty");return n??t},filled:()=>void 0!==n}},e.pool=e=>{const t=new f;let n;const s=new r((e=>(void 0===n||t.has(e)||e.give(n),t.add(e),()=>{t.destroy()})),"pool",!1);return s.subInfo(e),s.executed((()=>{const s=t.owner();e.value(new h((e=>{s.give(e),n=e})))})),[s,t]},e.poolStateless=e=>{const t=new f,n=new r((e=>(t.add(e),()=>{t.destroy()})),"pool",!1);return n.subInfo(e),n.executed((n=>{t.add(n),e.value(t.owner())})),[n,t]},e.sequence=e=>{const t=o((t=>{const n=[];e.value(d((e=>{n.push(e),t.give(n)})))}));return t.subInfo(e),t},e.stream=e=>o((t=>{e.value(d((e=>{e.forEach((e=>{t.give(e)}))})))}))}({});
